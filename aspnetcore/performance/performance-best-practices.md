---
title: Рекомендации по повышению производительности ASP.NET Core
author: mjrousos
description: Советы по повышению производительности ASP.NET Core приложений и устранению распространенных проблем с производительностью.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.date: 09/26/2019
uid: performance/performance-best-practices
ms.openlocfilehash: a2952f5234cdef7f749a1af8dd4adcb887290629
ms.sourcegitcommit: 7d3c6565dda6241eb13f9a8e1e1fd89b1cfe4d18
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2019
ms.locfileid: "72259772"
---
# <a name="aspnet-core-performance-best-practices"></a>Рекомендации по повышению производительности ASP.NET Core

По [Майк Роусос](https://github.com/mjrousos)

В этой статье приводятся рекомендации по обеспечению оптимальной производительности с помощью ASP.NET Core.

## <a name="cache-aggressively"></a>Агрессивный кэш

Кэширование рассматривается в нескольких частях этого документа. Дополнительные сведения см. в разделе <xref:performance/caching/response>.

## <a name="understand-hot-code-paths"></a>Общие сведения о путях к горячему коду

В этом документе путь к *горячему коду* определяется как часто называемый путь к коду и где возникает большая часть времени выполнения. Пути с горячим кодом обычно ограничивают масштаб и производительность приложения и обсуждаются в нескольких частях этого документа.

## <a name="avoid-blocking-calls"></a>Избегайте блокирующих вызовов

ASP.NET Core приложения предназначены для одновременной обработки нескольких запросов. Асинхронные интерфейсы API позволяют небольшому пулу потоков работать с тысячами одновременных запросов, не дожидаясь блокировки вызовов. Вместо ожидания завершения длительной синхронной задачи поток может работать с другим запросом.

Распространенная проблема производительности в ASP.NET Core приложениях — блокировка вызовов, которые могут быть асинхронными. Многие синхронные блокирующие вызовы ведут к нехватке [пула потоков](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) и снижению времени отклика.

**Не выполнять**:

* Блокировать асинхронное выполнение путем вызова [Task. Wait](/dotnet/api/system.threading.tasks.task.wait) или [Task. Result](/dotnet/api/system.threading.tasks.task-1.result).
* Получение блокировок в общих путях кода. ASP.NET Core приложения являются наиболее производительными при разработке архитектуры для параллельного выполнения кода.

**Выполните**следующие действия.

* Сделайте [неактивные пути к коду](#understand-hot-code-paths) асинхронными.
* Асинхронный вызов API-интерфейсов доступа к данным и долгосрочных операций.
* Выполнение асинхронных действий контроллера/Razor Page. Весь стек вызовов является асинхронным, чтобы воспользоваться преимуществами шаблонов [async/await](/dotnet/csharp/programming-guide/concepts/async/) .

Профилировщик, например [PerfView](https://github.com/Microsoft/perfview), можно использовать для поиска потоков, часто добавляемых в [пул потоков](/windows/desktop/procthread/thread-pools). Событие `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` указывает поток, добавленный в пул потоков. <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc)  -->

## <a name="minimize-large-object-allocations"></a>Сведение к минимальному выделению больших объектов

[Сборщик мусора .NET Core](/dotnet/standard/garbage-collection/) управляет выделением и освобождением памяти автоматически в ASP.NET Core приложениях. Автоматическая сборка мусора обычно означает, что разработчикам не нужно беспокоиться о том, как или когда освобождается память. Тем не менее очистка объектов, на которые нет ссылок, занимает время ЦП, поэтому разработчики должны максимально сокращать выделение объектов в [путях горячего кода](#understand-hot-code-paths). Сборка мусора особенно затратна на большие объекты (> 85 КБайт). Большие объекты хранятся в [куче больших объектов](/dotnet/standard/garbage-collection/large-object-heap) и для очистки требуется полная сборка мусора (поколение 2). В отличие от коллекций поколений 0 и поколения 1, сборка поколения 2 требует временной приостановки выполнения приложения. Частое выделение и освобождение больших объектов могут привести к нестабильной производительности.

Проектирован

* **Рассмотрите возможность** кэширования больших объектов, которые часто используются. Кэширование больших объектов предотвращает дорогостоящее выделение памяти.
* **Сделайте** буферы пула с помощью [`ArrayPool<T>`](/dotnet/api/system.buffers.arraypool-1) для хранения больших массивов.
* **Не** выделяйте большое количество кратковременных больших объектов в [пути горячего кода](#understand-hot-code-paths).

Проблемы с памятью, например предшествующие, можно диагностировать путем просмотра статистики сборщика мусора (GC) в [PerfView](https://github.com/Microsoft/perfview) и изучения:

* Время остановки сборки мусора.
* Процент времени процессора, затраченный на сборку мусора.
* Количество сборок мусора, которые являются поколением 0, 1 и 2.

Дополнительные сведения см. в разделе [сбор мусора и производительность](/dotnet/standard/garbage-collection/performance).

## <a name="optimize-data-access"></a>Оптимизация доступа к данным

Взаимодействие с хранилищем данных и другими удаленными службами часто является наиболее медленной частью ASP.NET Core приложения. Эффективное чтение и запись данных крайне важно для обеспечения высокой производительности.

Проектирован

* **Вызывайте все** API доступа к данным в асинхронном режиме.
* **Не** извлекать больше данных, чем требуется. Напишите запросы, возвращающие только те данные, которые необходимы для текущего HTTP-запроса.
* **Рассмотрите возможность** кэширования часто используемых данных, полученных из базы данных или удаленной службы, если это приемлемо для более неактуальных данных. В зависимости от сценария используйте [MemoryCache](xref:performance/caching/memory) или [DistributedCache](xref:performance/caching/distributed). Дополнительные сведения см. в разделе <xref:performance/caching/response>.
* **Сократите** круговые обходов сети. Целью является получение необходимых данных в одном вызове, а не в нескольких вызовах.
* **Не** используйте [запросы без отслеживания](/ef/core/querying/tracking#no-tracking-queries) в Entity Framework Core при доступе к данным в целях только для чтения. EF Core могут более эффективно возвращать результаты запросов без отслеживания.
* **Выполните** фильтрацию и агрегирование запросов LINQ (например, с помощью `.Where`, `.Select` или `.Sum`), чтобы фильтрация выполнялась базой данных.
* **Учтите,** что EF Core разрешает некоторые операторы запросов на клиенте, что может привести к неэффективному выполнению запроса. Дополнительные сведения см. в статье [проблемы с производительностью оценки клиента](/ef/core/querying/client-eval#client-evaluation-performance-issues).
* **Не** Используйте проекции запросов к коллекциям, что может привести к выполнению запросов SQL N + 1. Дополнительные сведения см. в разделе [Оптимизация коррелированных вложенных запросов](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).

Методы, которые могут повысить производительность в крупномасштабных приложениях, см. в статье [Высокая производительность](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) .

* [Пулы DbContext](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [Явно скомпилированные запросы](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

Мы рекомендуем оценить влияние предыдущих высокопроизводительных подходов перед фиксацией базы кода. Дополнительная сложность скомпилированных запросов может не отнять повышение производительности.

Проблемы запросов можно обнаружить, просмотрев время, затраченное на доступ к данным с помощью [Application Insights](/azure/application-insights/app-insights-overview) или с помощью средств профилирования. В большинстве баз данных также доступна статистика, касающаяся часто выполняемых запросов.

## <a name="pool-http-connections-with-httpclientfactory"></a>HTTP-соединения пула с Хттпклиентфактори

Хотя [HttpClient](/dotnet/api/system.net.http.httpclient) реализует интерфейс `IDisposable`, он предназначен для повторного использования. Закрытые экземпляры `HttpClient`. открывайте сокеты в состоянии `TIME_WAIT` в течение короткого периода времени. Если часто используется путь кода, который создает и уничтожает объекты `HttpClient`, приложение может вычерпать доступные сокеты. [Хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) был представлен в ASP.NET Core 2,1 в качестве решения этой проблемы. Он обрабатывает подключения по протоколу HTTP для оптимизации производительности и надежности.

Проектирован

* **Не** Создавайте и уничтожайте экземпляры `HttpClient` напрямую.
* **Используйте** [хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) для получения экземпляров `HttpClient`. Дополнительные сведения см. [в статье Использование хттпклиентфактори для реализации устойчивых HTTP-запросов](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).

## <a name="keep-common-code-paths-fast"></a>Быстрое отслеживание общих путей кода

Необходимо, чтобы весь код был быстрым, часто называемым путями кода, наиболее критичным для оптимизации:

* Компоненты по промежуточного слоя в конвейере обработки запросов приложения, особенно по промежуточного слоя выполняются на раннем этапе конвейера. Эти компоненты сильно влияют на производительность.
* Код, который выполняется для каждого запроса или несколько раз для каждого запроса. Например, пользовательское ведение журнала, обработчики авторизации или инициализацию временных служб.

Проектирован

* **Не** используйте пользовательские компоненты промежуточного слоя с долго выполняющимися задачами.
* **Используйте средства** профилирования производительности, такие как [Visual Studio средства диагностики](/visualstudio/profiling/profiling-feature-tour) или [PerfView](https://github.com/Microsoft/perfview)), для указания [путей использования горячих кодов](#understand-hot-code-paths).

## <a name="complete-long-running-tasks-outside-of-http-requests"></a>Выполнение длительных задач за пределами HTTP-запросов

Большинство запросов к ASP.NET Core приложению могут обрабатываться контроллером или моделью страницы, вызывающими необходимые службы и возвращающими ответ HTTP. Для некоторых запросов, в которых задействованы длительные задачи, лучше сделать весь процесс "запрос-ответ" асинхронным.

Проектирован

* **Не** дожидаться завершения длительных задач в рамках обычной обработки HTTP-запросов.
* **Рассмотрите возможность** обработки долго выполняющихся запросов с помощью [фоновых служб](xref:fundamentals/host/hosted-services) или вне процесса с помощью [функции Azure](/azure/azure-functions/). Завершение работы вне процесса особенно полезно для ресурсоемких задач.
* **Используйте параметры** связи в режиме реального времени, такие как [SignalR](xref:signalr/introduction), для асинхронной связи с клиентами.

## <a name="minify-client-assets"></a>Ресурсы клиента уменьшение

ASP.NET Core приложения с комплексными внешними интерфейсами часто обслуживают множество файлов JavaScript, CSS или изображений. Производительность запросов начальной загрузки можно улучшить следующим образом.

* Объединение, объединяющее несколько файлов в один.
* Минификация, что сокращает размер файлов, удаляя пробелы и комментарии.

Проектирован

* **Используйте** [встроенную поддержку](xref:client-side/bundling-and-minification) ASP.NET Core для объединения и Минификация клиентских ресурсов.
* **Ознакомьтесь с** другими сторонними инструментами, такими как веб- [пакет](https://webpack.js.org/), для комплексного управления клиентскими ресурсами.

## <a name="compress-responses"></a>Сжатие ответов

 Уменьшение размера ответа обычно значительно увеличивает скорость реагирования приложения. Одним из способов уменьшения размера полезных данных является сжатие ответов приложения. Дополнительные сведения см. в разделе [сжатие ответов](xref:performance/response-compression).

## <a name="use-the-latest-aspnet-core-release"></a>Использование последней версии ASP.NET Core

Каждый новый выпуск ASP.NET Core включает улучшения производительности. Оптимизация в .NET Core и ASP.NET Core означает, что более новые версии обычно более эффективны старые версии. Например, в .NET Core 2,1 добавлена поддержка скомпилированных регулярных выражений и выиграли из [`Span<T>`](https://msdn.microsoft.com/magazine/mt814808.aspx). В ASP.NET Core 2,2 добавлена поддержка HTTP/2. [ASP.NET Core 3,0 добавляет множество улучшений](xref:aspnetcore-3.0) , которые уменьшают использование памяти и увеличивают пропускную способность. Если производительность является приоритетной, рассмотрите возможность обновления до текущей версии ASP.NET Core.

## <a name="minimize-exceptions"></a>Уменьшение числа исключений

Исключения должны быть редкими. Создание и перехват исключений происходит очень долго относительно других шаблонов потока кода. Поэтому исключения не должны использоваться для управления нормальным выполнением программы.

Проектирован

* **Не** используйте генерацию или перехват исключений в качестве средства обычного потока программы, особенно в [путях горячего кода](#understand-hot-code-paths).
* **Включите в** приложение логику для обнаружения и обработки условий, вызывающих исключение.
* **Вызывайте или** перехватите исключения для необычных или непредвиденных условий.

Средства диагностики приложений, такие как Application Insights, могут помочь в определении распространенных исключений в приложении, которое может повлиять на производительность.

## <a name="performance-and-reliability"></a>Производительность и надежность

Следующие разделы содержат советы по повышению производительности и известным проблемам надежности и решениям.

## <a name="avoid-synchronous-read-or-write-on-httprequesthttpresponse-body"></a>Избегайте синхронного чтения или записи в тексте HttpRequest/HttpResponse

Все операции ввода-вывода в ASP.NET Core являются асинхронными. Серверы реализуют интерфейс `Stream`, который имеет как синхронные, так и асинхронные перегрузки. Асинхронные объекты должны быть предпочтительнее, чтобы избежать блокирования потоков пула потоков. Блокировка потоков может привести к нехватке пула потоков.

**Не Выменяйте это:** В следующем примере используется модель <xref:System.IO.StreamReader.ReadToEnd*>. Он блокирует текущий поток для ожидания результата. Это пример [sync over Async @ no__t-1.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet1)]

В приведенном выше коде `Get` синхронно считывает весь текст запроса HTTP в память. Если клиент медленно отправляется, приложение выполняет синхронизацию асинхронно. Приложение выполняет синхронизацию асинхронно, так как Kestrel **не поддерживает** синхронные операции чтения.

**Выполните следующие действия.** В следующем примере используется <xref:System.IO.StreamReader.ReadToEndAsync*> и не блокируется поток при чтении.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet2)]

Приведенный выше код асинхронно считывает весь текст HTTP-запроса в память.

> [!WARNING]
> Если запрос имеет большой размер, чтение всего текста HTTP-запроса в память может привести к нехватке памяти. Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

**Выполните следующие действия.** Следующий пример полностью асинхронно использует текст запроса без буферизации:

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet3)]

Приведенный выше код асинхронно считывает весь текст HTTP-запроса в память.

> [!WARNING]
> Если запрос имеет большой размер, чтение всего текста HTTP-запроса в память может привести к нехватке памяти. Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

## <a name="prefer-readformasync-over-requestform"></a>Предпочитать Реадформасинк по запросу. Form

Используйте `HttpContext.Request.ReadFormAsync` вместо `HttpContext.Request.Form`.
`HttpContext.Request.Form` может быть безопасно прочитан только со следующими условиями:

* Форма была считана вызовом `ReadFormAsync` и
* Считывается значение кэшированной формы с помощью `HttpContext.Request.Form`

**Не Выменяйте это:** В следующем примере используется `HttpContext.Request.Form`.  `HttpContext.Request.Form` использует [sync через Async @ no__t-2 и может привести к нехватке пула потоков.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере `HttpContext.Request.ReadFormAsync` используется для асинхронного чтения текста формы.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet2)]

<a name="arlb"></a>

## <a name="avoid-reading-large-request-bodies-or-response-bodies-into-memory"></a>Избегайте считывания текста крупного запроса или тела ответа в память

В .NET каждое выделение объектов, превышающее 85 КБ, заканчивается в куче больших объектов ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)). Большие объекты являются ресурсоемкими двумя способами:

* Стоимость выделения высока, так как память для вновь выделенного большого объекта должна быть сброшена. Среда CLR гарантирует, что память для всех вновь выделяемых объектов будет сброшена.
* LOH собирается вместе с остальной частью кучи. Для LOH требуется полная сборка [мусора](/dotnet/standard/garbage-collection/fundamentals) или [коллекция Gen2](/dotnet/standard/garbage-collection/fundamentals#generations).

Эта [запись блога](https://adamsitnik.com/Array-Pool/#the-problem) кратко описывает проблему:

> При выделении большого объекта он помечается как объект Gen 2. Не Gen 0 как для небольших объектов. Последствия в том, что если в LOH исчерпана память, сборщик мусора очищает всю управляемую кучу, а не только LOH. Он очищает Gen 0, Gen 1 и Gen 2, включая LOH. Это называется полной сборкой мусора и является наиболее длительным сбором мусора. Для многих приложений это может быть приемлемым. Но определенно не для высокопроизводительных веб-серверов, где несколько больших буферов памяти требуются для обработки среднего веб-запроса (чтение из сокета, распаковка, декодирование JSON & больше).

Простое хранение большого запроса или текста ответа в одном `byte[]` или `string`:

* Может привести к быстрому запуску пространства в LOH.
* Может вызвать проблемы с производительностью приложения из-за выполнения полных GC.

## <a name="working-with-a-synchronous-data-processing-api"></a>Работа с синхронным интерфейсом API обработки данных

При использовании сериализатора или отмены сериализатора, поддерживающего только синхронные операции чтения и записи (например, [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):

* Асинхронная буферизация данных в память перед их передачей в сериализатор/de-сериализатор.

> [!WARNING]
> Если запрос большой, это может привести к нехватке памяти («нехватки»). Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

ASP.NET Core 3,0 по умолчанию использует <xref:System.Text.Json> для сериализации JSON. <xref:System.Text.Json>.

* асинхронно считывает и записывает JSON;
* оптимизирован для текста UTF-8;
* предоставляет более высокую производительность, чем `Newtonsoft.Json`.

## <a name="do-not-store-ihttpcontextaccessorhttpcontext-in-a-field"></a>Не хранить Ихттпконтекстакцессор. HttpContext в поле

[Ихттпконтекстакцессор. HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) возвращает `HttpContext` активного запроса при доступе из потока запроса. @No__t-0 **не** следует хранить в поле или переменной.

**Не Выменяйте это:** В следующем примере значение `HttpContext` сохраняется в поле, а затем выполняется попытка его использования позже.

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet1)]

Приведенный выше код часто захватывает значение null или неверно `HttpContext` в конструкторе.

**Выполните следующие действия.** В следующем примере происходит следующее:

* Сохраняет <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> в поле.
* Использует поле `HttpContext` в нужное время и проверяет `null`.

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet2)]

## <a name="do-not-access-httpcontext-from-multiple-threads"></a>Не обращаться к HttpContext из нескольких потоков

`HttpContext` *не* является потокобезопасным. Доступ к `HttpContext` из нескольких потоков в параллельном режиме может привести к неопределенному поведению, такому как зависание, сбои и повреждение данных.

**Не Выменяйте это:** В следующем примере выполняется три параллельных запроса и записывается путь к входящему запросу до и после исходящего HTTP-запроса. Доступ к пути запроса осуществляется из нескольких потоков, которые могут быть параллельными.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet1&highlight=25,28)]

**Выполните следующие действия.** В следующем примере все данные из входящего запроса копируются перед выполнением трех параллельных запросов.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet2&highlight=6,8,22,28)]

## <a name="do-not-use-the-httpcontext-after-the-request-is-complete"></a>Не используйте HttpContext после завершения запроса

`HttpContext` допустимо только при условии, что в конвейере ASP.NET Core есть активный HTTP-запрос. Весь конвейер ASP.NET Core является асинхронной цепочкой делегатов, выполняющих каждый запрос. При завершении `Task`, возвращенном из этой цепочки, `HttpContext` перезапускается.

**Не Выменяйте это:** В следующем примере используется `async void`:

* Это **всегда** является неправильной практикой в ASP.NET Core приложениях.
* Обращается к `HttpResponse` после завершения запроса HTTP.
* Завершается сбоем процесса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncBadVoidController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере возвращается `Task` к платформе, поэтому HTTP-запрос не завершается до завершения действия.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncSecondController.cs?name=snippet1)]

## <a name="do-not-capture-the-httpcontext-in-background-threads"></a>Не захватывать HttpContext в фоновых потоках

**Не Выменяйте это:** В следующем примере показано замыкание на себя, записывая `HttpContext` из свойства `Controller`. Это неплохая практика, поскольку рабочий элемент может:

* Выполнение за пределами области запроса.
* Попытка чтения неверной `HttpContext`.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере происходит следующее:

* Копирует данные, необходимые в фоновой задаче, во время запроса.
* Не ссылается на что-либо из контроллера.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet2)]

## <a name="do-not-capture-services-injected-into-the-controllers-on-background-threads"></a>Не захватывать службы, внедренные в контроллеры в фоновых потоках

**Не Выменяйте это:** В следующем примере показано, как захватывается замыкание `DbContext` из параметра действия `Controller`. Это неплохой подход.  Рабочий элемент может выполняться вне области запроса. @No__t-0 ограничивается запросом, что приводит к `ObjectDisposedException`.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере происходит следующее:

* Внедряет <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory>, чтобы создать область в фоновом рабочем элементе. `IServiceScopeFactory` является одноэлементным.
* Создает новую область внедрения зависимостей в фоновом потоке.
* Не ссылается на что-либо из контроллера.
* Не захватывает `ContosoDbContext` из входящего запроса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2)]

Выделенный ниже код:

* Создает область в течение времени существования фоновой операции и разрешает службы из нее.
* Использует `ContosoDbContext` из правильной области действия.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2&highlight=9-16)]

## <a name="do-not-modify-the-status-code-or-headers-after-the-response-body-has-started"></a>Не изменяйте код состояния или заголовки после начала текста ответа

ASP.NET Core не замещает текст HTTP-ответа. При первом написании ответа:

* Заголовки отправляются клиенту вместе с этим фрагментом текста.
* Больше нельзя изменять заголовки ответа.

**Не Выменяйте это:** Следующий код пытается добавить заголовки ответа после того, как ответ уже запущен:

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet1)]

В приведенном выше коде `context.Response.Headers["test"] = "test value";` выдаст исключение, если `next()` записывается в ответ.

**Выполните следующие действия.** В следующем примере проверяется, начался ли HTTP-ответ перед изменением заголовков.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet2)]

**Выполните следующие действия.** В следующем примере `HttpResponse.OnStarting` используется для установки заголовков перед очисткой заголовков ответа клиенту.

Проверка того, что ответ не запущен, позволяет регистрировать обратный вызов, который будет вызываться непосредственно перед заголовком ответа. Проверяется, не начался ли ответ:

* Предоставляет возможность добавлять или переопределять заголовки по времени.
* Не требует знания следующего по промежуточного слоя в конвейере.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet3)]

## <a name="do-not-call-next-if-you-have-already-started-writing-to-the-response-body"></a>Не вызывайте Next (), если вы уже начали записывать в текст ответа.

Компоненты должны вызываться, только если они могут обрабатывать ответ и управлять им.
