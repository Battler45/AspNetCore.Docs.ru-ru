---
title: Использование концентраторов в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать концентраторы в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: bradyg
ms.custom: mvc
ms.date: 01/16/2020
no-loc:
- SignalR
uid: signalr/hubs
ms.openlocfilehash: e5bc12c5ccafe2b5273d72e6bde0f631ca043428
ms.sourcegitcommit: f259889044d1fc0f0c7e3882df0008157ced4915
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/21/2020
ms.locfileid: "76294625"
---
# <a name="use-hubs-in-opno-locsignalr-for-aspnet-core"></a>Использование концентраторов в SignalR для ASP.NET Core

[Рейчел Аппель (](https://twitter.com/rachelappel) и [Кевин Гриффин](https://twitter.com/1kevgriff)

[Просмотр или скачивание образца кода](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/signalr/hubs/sample/ ) [(Загрузка)](xref:index#how-to-download-a-sample)

## <a name="what-is-a-opno-locsignalr-hub"></a>Что такое центр SignalR

API концентраторов SignalR позволяет вызывать методы на подключенных клиентах с сервера. В серверном коде определяются методы, вызываемые клиентом. В клиентском коде определяются методы, которые вызываются с сервера. SignalR позаботится обо всем, за кулисами, что делает возможными обмен данными между клиентом и сервером в реальном времени.

## <a name="configure-opno-locsignalr-hubs"></a>Настройка концентраторов SignalR

По промежуточного слоя SignalR требуются некоторые службы, которые настраиваются путем вызова `services.AddSignalR`.

[!code-csharp[Configure service](hubs/sample/startup.cs?range=38)]

::: moniker range=">= aspnetcore-3.0"

При добавлении SignalR функциональных возможностей в ASP.NET Core приложение программа установки SignalR направляет маршруты путем вызова `endpoint.MapHub` в обратном вызове `Startup.Configure` метода `app.UseEndpoints`.

```csharp
app.UseRouting();
app.UseEndpoints(endpoints =>
{
    endpoints.MapHub<ChatHub>("/chathub");
});
```

::: moniker-end

::: moniker range="<= aspnetcore-2.2"

При добавлении SignalR функциональных возможностей в ASP.NET Core приложение программа установки SignalR направляет маршруты путем вызова `app.UseSignalR` в методе `Startup.Configure`.

[!code-csharp[Configure routes to hubs](hubs/sample/startup.cs?range=57-60)]

::: moniker-end

## <a name="create-and-use-hubs"></a>Создание и использование концентраторов

Создайте центр, объявив класс, наследующий от `Hub`, и добавьте в него открытые методы. Клиенты могут вызывать методы, определенные как `public`.

```csharp
public class ChatHub : Hub
{
    public Task SendMessage(string user, string message)
    {
        return Clients.All.SendAsync("ReceiveMessage", user, message);
    }
}
```

Можно указать тип возвращаемого значения и параметры, включая сложные типы и массивы, как в любом C# методе. SignalR обрабатывает сериализацию и десериализацию сложных объектов и массивов в параметрах и возвращаемых значениях.

> [!NOTE]
> Концентраторы являются временными:
>
> * Не сохраняйте состояние в свойстве класса Hub. Каждый вызов метода концентратора выполняется в новом экземпляре концентратора.
> * Используйте `await` при вызове асинхронных методов, которые зависят от концентратора на активность. Например, метод, например `Clients.All.SendAsync(...)`, может завершиться ошибкой, если он вызывается без `await` и метод концентратора завершается до завершения `SendAsync`.

## <a name="the-context-object"></a>Контекстный объект

Класс `Hub` имеет свойство `Context`, которое содержит следующие свойства со сведениями о соединении:

| Идентификаторы | Описание |
| ------ | ----------- |
| `ConnectionId` | Возвращает уникальный идентификатор соединения, назначенный SignalR. Для каждого соединения существует один идентификатор подключения.|
| `UserIdentifier` | Возвращает [идентификатор пользователя](xref:signalr/groups). По умолчанию SignalR использует `ClaimTypes.NameIdentifier` из `ClaimsPrincipal`, связанного с подключением, в качестве идентификатора пользователя. |
| `User` | Возвращает `ClaimsPrincipal`, связанный с текущим пользователем. |
| `Items` | Возвращает коллекцию "ключ-значение", которую можно использовать для совместного использования данных в области этого соединения. Данные могут храниться в этой коллекции, и они будут сохранены для подключения через разные вызовы метода концентратора. |
| `Features` | Возвращает коллекцию функций, доступных в соединении. Сейчас эта коллекция не требуется в большинстве сценариев, поэтому она еще не документирована. |
| `ConnectionAborted` | Возвращает `CancellationToken`, уведомляющая о прерывании соединения. |

`Hub.Context` также содержит следующие методы.

| Метод | Описание |
| ------ | ----------- |
| `GetHttpContext` | Возвращает `HttpContext` для соединения или `null`, если соединение не связано с HTTP-запросом. Для HTTP-соединений этот метод можно использовать для получения таких сведений, как заголовки HTTP и строки запросов. |
| `Abort` | Прерывает подключение. |

## <a name="the-clients-object"></a>Объект «клиенты»

Класс `Hub` имеет свойство `Clients`, которое содержит следующие свойства для обмена данными между сервером и клиентом.

| Идентификаторы | Описание |
| ------ | ----------- |
| `All` | Вызывает метод для всех подключенных клиентов |
| `Caller` | Вызывает метод для клиента, который вызвал метод концентратора |
| `Others` | Вызывает метод для всех подключенных клиентов, за исключением клиента, который вызвал метод |

`Hub.Clients` также содержит следующие методы.

| Метод | Описание |
| ------ | ----------- |
| `AllExcept` | Вызывает метод для всех подключенных клиентов, за исключением указанных соединений |
| `Client` | Вызывает метод для указанного подключенного клиента |
| `Clients` | Вызывает метод для конкретных подключенных клиентов |
| `Group` | Вызывает метод для всех соединений в указанной группе  |
| `GroupExcept` | Вызывает метод для всех соединений в указанной группе, за исключением указанных соединений |
| `Groups` | Вызывает метод для нескольких групп соединений  |
| `OthersInGroup` | Вызывает метод для группы соединений, исключая клиента, вызвавшего метод концентратора.  |
| `User` | Вызывает метод для всех соединений, связанных с конкретным пользователем |
| `Users` | Вызывает метод для всех подключений, связанных с указанными пользователями |

Каждое свойство или метод в приведенных выше таблицах возвращает объект с методом `SendAsync`. Метод `SendAsync` позволяет указать имя и параметры вызываемого клиентского метода.

## <a name="send-messages-to-clients"></a>Отправка сообщений клиентам

Чтобы вызвать определенные клиенты, используйте свойства объекта `Clients`. В следующем примере есть три метода концентратора:

* `SendMessage` отправляет сообщение всем подключенным клиентам с помощью `Clients.All`.
* `SendMessageToCaller` отправляет сообщение обратно вызывающему, используя `Clients.Caller`.
* `SendMessageToGroups` отправляет сообщение всем клиентам в группе `SignalR Users`.

[!code-csharp[Send messages](hubs/sample/hubs/chathub.cs?name=HubMethods)]

## <a name="strongly-typed-hubs"></a>Строго типизированные концентраторы

Недостаток использования `SendAsync` заключается в том, что он использует волшебную строку для указания вызываемого клиентского метода. Это оставляет код открытым для ошибок времени выполнения, если имя метода написано неправильно или отсутствует в клиенте.

Альтернативой использованию `SendAsync` является строгое `Hub` с <xref:Microsoft.AspNetCore.SignalR.Hub%601>. В следующем примере `ChatHub` клиентские методы были извлечены в интерфейс с именем `IChatClient`.

[!code-csharp[Interface for IChatClient](hubs/sample/hubs/ichatclient.cs?name=snippet_IChatClient)]

Этот интерфейс можно использовать для рефакторинга предыдущего `ChatHub` примера.

[!code-csharp[Strongly typed ChatHub](hubs/sample/hubs/StronglyTypedChatHub.cs?range=8-18,36)]

Использование `Hub<IChatClient>` включает проверку клиентских методов во время компиляции. Это предотвращает проблемы, вызванные использованием волшебных строк, поскольку `Hub<T>` может предоставлять доступ только к методам, определенным в интерфейсе.

Использование строго типизированных `Hub<T>` отключает возможность использования `SendAsync`. Все методы, определенные в интерфейсе, по-прежнему могут быть определены как асинхронные. Фактически каждый из этих методов должен возвращать `Task`. Поскольку это интерфейс, не используйте ключевое слово `async`. Например:

```csharp
public interface IClient
{
    Task ClientMethod();
}
```

> [!NOTE]
> Суффикс `Async` не удаляется из имени метода. Если метод клиента не определен с помощью `.on('MyMethodAsync')`, в качестве имени не следует использовать `MyMethodAsync`.

## <a name="change-the-name-of-a-hub-method"></a>Изменение имени метода концентратора

По умолчанию имя метода концентратора сервера — это имя метода .NET. Однако можно использовать атрибут [хубмесоднаме](xref:Microsoft.AspNetCore.SignalR.HubMethodNameAttribute) , чтобы изменить это значение по умолчанию и вручную указать имя метода. Клиент должен использовать это имя вместо имени метода .NET при вызове метода.

[!code-csharp[HubMethodName attribute](hubs/sample/hubs/chathub.cs?name=HubMethodName&highlight=1)]

## <a name="handle-events-for-a-connection"></a>Обработку событий для подключения

API концентраторов SignalR предоставляет виртуальные методы `OnConnectedAsync` и `OnDisconnectedAsync` для управления подключениями и их мониторинга. Переопределите `OnConnectedAsync` виртуальный метод, чтобы выполнять действия при подключении клиента к концентратору, например к его добавлению в группу.

[!code-csharp[Handle connection](hubs/sample/hubs/chathub.cs?name=OnConnectedAsync)]

Переопределите `OnDisconnectedAsync` виртуальный метод, чтобы выполнять действия при отключении клиента. При намеренном отключении клиента (например, путем вызова `connection.stop()`) параметр `exception` будет `null`. Однако если Клиент отключен из-за ошибки (например, ошибки сети), то параметр `exception` будет содержать исключение, описывающее ошибку.

[!code-csharp[Handle disconnection](hubs/sample/hubs/chathub.cs?name=OnDisconnectedAsync)]

[!INCLUDE[](~/includes/connectionid-signalr.md)]

## <a name="handle-errors"></a>Обработка ошибок

Исключения, вызываемые в методах концентратора, отправляются клиенту, вызвавшему метод. На клиенте JavaScript метод `invoke` возвращает [обещание JavaScript](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Using_promises). Когда клиент получает сообщение об ошибке с обработчиком, присоединенным к обещанию с помощью `catch`, он вызывается и передается как объект `Error` JavaScript.

[!code-javascript[Error](hubs/sample/wwwroot/js/chat.js?range=23)]

Если концентратор создает исключение, соединения не закрываются. По умолчанию SignalR возвращает клиенту общее сообщение об ошибке. Например:

```
Microsoft.AspNetCore.SignalR.HubException: An unexpected error occurred invoking 'MethodName' on the server.
```

Непредвиденные исключения часто содержат конфиденциальные сведения, такие как имя сервера базы данных в исключении, которое запускается при сбое подключения к базе данных. SignalR не предоставляет эти подробные сообщения об ошибках по умолчанию в качестве меры безопасности. Дополнительные сведения о том, почему сведения об исключении подавляются, см. в [статье вопросы безопасности](xref:signalr/security#exceptions) .

При наличии исключительных условий *, которые нужно* распространить на клиент, можно использовать класс `HubException`. Если вы выдаете `HubException` из метода концентратора, **SignalR отправляет** клиенту все сообщение без изменений.

[!code-csharp[ThrowHubException](hubs/sample/hubs/chathub.cs?name=ThrowHubException&highlight=3)]

> [!NOTE]
> SignalR отправляет клиенту только свойство `Message` исключения. Трассировка стека и другие свойства исключения недоступны клиенту.

## <a name="related-resources"></a>Связанные ресурсы

* [Введение в ASP.NET Core SignalR](xref:signalr/introduction)
* [Клиент JavaScript](xref:signalr/javascript-client)
* [Публикация в Azure](xref:signalr/publish-to-azure-web-app)
