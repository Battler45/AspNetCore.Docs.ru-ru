---
title: Вопросы безопасности в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать проверку подлинности и авторизацию в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 12/05/2019
no-loc:
- SignalR
uid: signalr/security
ms.openlocfilehash: 1bdb8b10a24c65735f49f04285e4129cb77eb3fb
ms.sourcegitcommit: 7dfe6cc8408ac6a4549c29ca57b0c67ec4baa8de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/09/2020
ms.locfileid: "75828949"
---
# <a name="security-considerations-in-aspnet-core-opno-locsignalr"></a>Вопросы безопасности в ASP.NET Core SignalR

[Эндрю Стантон-медперсонала](https://twitter.com/anurse)

В этой статье содержатся сведения о защите SignalR.

## <a name="cross-origin-resource-sharing"></a>Предоставление общего доступа к ресурсам независимо от источника

[Общий доступ к ресурсам между источниками (CORS)](https://www.w3.org/TR/cors/) можно использовать, чтобы разрешить SignalR соединений между источниками в браузере. Если код JavaScript размещен в другом домене из SignalR приложения, необходимо включить по [промежуточного слоя CORS](xref:security/cors) , чтобы разрешить JavaScript подключаться к приложению SignalR. Разрешать запросы между источниками только из доменов, которым вы доверяете или контролируете. Например:

* Сайт размещается на `http://www.example.com`
* Приложение SignalR размещено на `http://signalr.example.com`

CORS следует настроить в приложении SignalR, чтобы разрешить только `www.example.com`источника.

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов между источниками (CORS)](xref:security/cors). для SignalR **требуются** следующие политики CORS:

* Разрешить конкретные ожидаемые источники. Разрешение любого источника возможно, но **не** является безопасным или рекомендуемым.
* Методы HTTP `GET` и `POST` должны быть разрешены.
* Учетные данные должны быть разрешены для правильной работы прикрепленных сеансов на основе файлов cookie. Они должны быть включены, даже если проверка подлинности не используется.

<!--
::: moniker range=">= aspnetcore-5.0"  // Moniker here just to make sure this doesn't get missed in the 5.0 version update.
However, in 5.0 we have provided an option in the TypeScript client to not use credentials.
The not to use credentials option should only be used when you know 100% that credentials like Cookies are not needed in your app (cookies are used by azure app service when using multiple servers)

For more info, see https://github.com/aspnet/AspNetCore.Docs/issues/16003
.-->

Например, следующая политика CORS позволяет клиенту SignalR браузера, размещенному на `https://example.com`, получать доступ к приложению SignalR, размещенному на `https://signalr.example.com`:

::: moniker range=">= aspnetcore-3.0"

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // ... other middleware ...

    // Make sure the CORS middleware is ahead of SignalR.
    app.UseCors(builder =>
    {
        builder.WithOrigins("https://example.com")
            .AllowAnyHeader()
            .WithMethods("GET", "POST")
            .AllowCredentials();
    });

    // ... other middleware ...
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chatHub");
    });

    // ... other middleware ...
}
```

::: moniker-end

::: moniker range="<= aspnetcore-2.2"

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

::: moniker-end

> [!NOTE]
> SignalR несовместим с встроенной функцией CORS в службе приложений Azure.

## <a name="websocket-origin-restriction"></a>Ограничение источника WebSocket

::: moniker range=">= aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Ограничение [по источнику](xref:fundamentals/websockets#websocket-origin-restriction)для соединений WebSocket.

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Браузеры **не** поддерживают следующие задачи:

* выполнение предварительных запросов CORS;
* использование ограничений, указанных в заголовках `Access-Control`, при выполнении запросов WebSocket.

Однако браузеры отправляют заголовок `Origin` при выпуске запросов WebSocket. Приложения должны быть настроены для проверки этих заголовков, чтобы использовались только WebSocket из ожидаемых источников.

В ASP.NET Core 2,1 и более поздних версиях проверка заголовка может быть достигнута с помощью пользовательского по промежуточного слоя, расположенного **перед `UseSignalR`, и `Configure`по промежуточного слоя для проверки подлинности**

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> Заголовок `Origin` контролируется клиентом и, как и заголовок `Referer`, может быть подделан. Эти заголовки **не** следует использовать в качестве механизма проверки подлинности.

::: moniker-end

## <a name="access-token-logging"></a>Ведение журнала маркеров доступа

При использовании веб-сокетов или событий, отправленных сервером, клиент браузера отправляет маркер доступа в строку запроса. Получение маркера доступа с помощью строки запроса, как правило, безопасно с использованием стандартного заголовка `Authorization`. Для обеспечения безопасного сквозного подключения между клиентом и сервером всегда следует использовать протокол HTTPS. Многие веб-серверы заключают в журнал URL-адрес каждого запроса, включая строку запроса. Ведение журнала URL-адресов может регистрировать маркер доступа. ASP.NET Core записывает URL-адрес для каждого запроса по умолчанию, который будет включать строку запроса. Например:

```
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/myhub?access_token=1234
```

Если у вас есть проблемы с регистрацией этих данных в журналах сервера, можно полностью отключить ведение журнала, настроив `Microsoft.AspNetCore.Hosting` Logger на уровень `Warning` или выше (эти сообщения записываются на уровне `Info`). Дополнительные сведения см. в документации по [фильтрации журналов](xref:fundamentals/logging/index#log-filtering) . Если вы по-прежнему хотите заносить в журнал определенные сведения о запросе, можно [написать по промежуточного слоя](xref:fundamentals/middleware/write) для записи нужных данных и отфильтровать `access_token` значение строки запроса (если оно есть).

## <a name="exceptions"></a>Исключения

Сообщения об исключениях обычно считаются конфиденциальными данными, которые не должны быть раскрыты для клиента. По умолчанию SignalR не отправляет клиенту сведения об исключении, вызываемом методом концентратора. Вместо этого клиент получает универсальное сообщение, указывающее на возникновение ошибки. Доставка сообщений об исключениях клиенту может быть переопределена (например, в разработке или тестировании) с помощью [енабледетаиледеррорс](xref:signalr/configuration#configure-server-options). Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalR использует буферы каждого подключения для управления входящими и исходящими сообщениями. По умолчанию SignalR ограничивает размер этих буферов 32 КБ. Максимальное сообщение, которое клиент или сервер может отправить, — 32 КБ. Максимальный объем памяти, потребляемый соединением для сообщений, составляет 32 КБ. Если размер сообщений всегда меньше 32 КБ, можно уменьшить ограничение, которое:

* Запрещает клиенту отправить сообщение большего размера.
* Серверу не придется распределять большие буферы для приема сообщений.

Если размер сообщений превышает 32 КБ, можно увеличить это ограничение. Увеличение этого предела означает:

* Клиент может привести к выделению сервером больших буферов памяти.
* Выделение сервером больших буферов может сократить число одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений. их можно настроить для объекта [хттпконнектиондиспатчероптионс](xref:signalr/configuration#configure-server-options) , настроенного в `MapHub`:

* `ApplicationMaxBufferSize` представляет максимальное число байтов от клиента, на котором находятся буферы сервера. Если клиент пытается отправить сообщение, размер которого превышает это ограничение, соединение может быть закрыто.
* `TransportMaxBufferSize` представляет максимальное число байтов, которое может быть отправлено сервером. Если сервер пытается отправить сообщение (включая возвращаемые значения из методов концентратора), превышающие это ограничение, будет создано исключение.

Установка предельного значения `0` отключает ограничение. Удаление ограничения позволяет клиенту отправить сообщение любого размера. Вредоносные клиенты, отправляющие большие сообщения, могут вызвать чрезмерное выделение памяти. Чрезмерное использование памяти может значительно сократить количество одновременных подключений.
