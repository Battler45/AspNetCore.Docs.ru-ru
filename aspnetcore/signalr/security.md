---
title: Вопросы безопасности в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать проверку подлинности и авторизацию в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 11/06/2018
uid: signalr/security
ms.openlocfilehash: a52db2ff51c55f7299d63aa3c7398f99727e0694
ms.sourcegitcommit: 387cf29f5d5addef2cbc70670a11d612806b36b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70746559"
---
# <a name="security-considerations-in-aspnet-core-signalr"></a>Вопросы безопасности в ASP.NET Core SignalR

[Эндрю Стантон-медперсонала](https://twitter.com/anurse)

Эта статья содержит сведения о защите SignalR.

## <a name="cross-origin-resource-sharing"></a>Общий доступ к ресурсам между источниками

[Общий доступ к ресурсам в разных источниках (CORS)](https://www.w3.org/TR/cors/) можно использовать, чтобы разрешить подключения SignalR в браузере. Если код JavaScript размещен в другом домене из приложения SignalR, необходимо включить по [промежуточного слоя CORS](xref:security/cors) , чтобы разрешить JavaScript подключаться к приложению SignalR. Разрешать запросы между источниками только из доменов, которым вы доверяете или контролируете. Например:

* Ваш сайт размещен на`http://www.example.com`
* Ваше приложение SignalR размещено на`http://signalr.example.com`

CORS следует настроить в приложении SignalR, чтобы разрешить только источник `www.example.com`.

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов между источниками (CORS)](xref:security/cors). Для SignalR **требуются** следующие политики CORS:

* Разрешить конкретные ожидаемые источники. Разрешение любого источника возможно, но **не** является безопасным или рекомендуемым.
* Методы `GET` HTTP и `POST` должны быть разрешены.
* Учетные данные должны быть включены, даже если проверка подлинности не используется.

Например, следующая политика CORS позволяет клиенту обозревателя SignalR, размещенному `https://example.com` в, получать доступ к приложению SignalR, размещенному на: `https://signalr.example.com`

::: moniker range=">= aspnetcore-3.0"

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // ... other middleware ...

    // Make sure the CORS middleware is ahead of SignalR.
    app.UseCors(builder =>
    {
        builder.WithOrigins("https://example.com")
            .AllowAnyHeader()
            .WithMethods("GET", "POST")
            .AllowCredentials();
    });

    // ... other middleware ...
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chatHub");
    });

    // ... other middleware ...
}
```

::: moniker-end

::: moniker range="<= aspnetcore-2.2"

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

::: moniker-end

> [!NOTE]
> SignalR несовместим со встроенным компонентом CORS в службе приложений Azure.

## <a name="websocket-origin-restriction"></a>Ограничение источника WebSocket

::: moniker range=">= aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Ограничение [по источнику](xref:fundamentals/websockets#websocket-origin-restriction)для соединений WebSocket.

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Браузеры **не** поддерживают следующие задачи:

* выполнение предварительных запросов CORS;
* использование ограничений, указанных в заголовках `Access-Control`, при выполнении запросов WebSocket.

Однако браузеры отправляют заголовок `Origin` при выпуске запросов WebSocket. Приложения должны быть настроены для проверки этих заголовков, чтобы использовались только WebSocket из ожидаемых источников.

В ASP.NET Core 2,1 и более поздних версиях проверка заголовков может быть достигнута с помощью пользовательского промежуточного слоя `Configure`, размещенного **до `UseSignalR`, и по промежуточного слоя** в:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> Заголовок `Origin` контролируется клиентом и, как и заголовок `Referer`, может быть подделан. Эти заголовки **не** следует использовать в качестве механизма проверки подлинности.

::: moniker-end

## <a name="access-token-logging"></a>Ведение журнала маркеров доступа

При использовании веб-сокетов или событий, отправленных сервером, клиент браузера отправляет маркер доступа в строку запроса. Получение маркера доступа через строку запроса, как правило, защищено с помощью `Authorization` стандартного заголовка. Для обеспечения безопасного сквозного подключения между клиентом и сервером всегда следует использовать протокол HTTPS. Многие веб-серверы заключают в журнал URL-адрес каждого запроса, включая строку запроса. Ведение журнала URL-адресов может регистрировать маркер доступа. ASP.NET Core записывает URL-адрес для каждого запроса по умолчанию, который будет включать строку запроса. Например:

```
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/myhub?access_token=1234
```

Если у вас есть вопросы о записи этих данных в журналы сервера, можно полностью отключить это ведение журнала, настроив `Microsoft.AspNetCore.Hosting` средство ведения журнала `Warning` на уровень или выше (эти сообщения записываются на `Info` уровне). Дополнительные сведения см. в документации по [фильтрации журналов](xref:fundamentals/logging/index#log-filtering) . Если вы по-прежнему хотите заносить в журнал определенные сведения о запросе, можно [написать по промежуточного слоя](xref:fundamentals/middleware/write) для записи нужных `access_token` данных и отфильтровать значение строки запроса (при наличии).

## <a name="exceptions"></a>Исключения

Сообщения об исключениях обычно считаются конфиденциальными данными, которые не должны быть раскрыты для клиента. По умолчанию SignalR не отправляет клиенту сведения об исключении, вызываемом методом концентратора. Вместо этого клиент получает универсальное сообщение, указывающее на возникновение ошибки. Доставка сообщений об исключениях клиенту может быть переопределена (например, в разработке или тестировании [`EnableDetailedErrors`](xref:signalr/configuration#configure-server-options)) с помощью. Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalR использует буферы каждого подключения для управления входящими и исходящими сообщениями. По умолчанию SignalR ограничивает эти буферы до 32 КБ. Максимальное сообщение, которое клиент или сервер может отправить, — 32 КБ. Максимальный объем памяти, потребляемый соединением для сообщений, составляет 32 КБ. Если размер сообщений всегда меньше 32 КБ, можно уменьшить ограничение, которое:

* Запрещает клиенту отправить сообщение большего размера.
* Серверу не придется распределять большие буферы для приема сообщений.

Если размер сообщений превышает 32 КБ, можно увеличить это ограничение. Увеличение этого предела означает:

* Клиент может привести к выделению сервером больших буферов памяти.
* Выделение сервером больших буферов может сократить число одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений. они могут быть настроены [`HttpConnectionDispatcherOptions`](xref:signalr/configuration#configure-server-options) для объекта, настроенного в: `MapHub`

* `ApplicationMaxBufferSize`представляет максимальное число байтов от клиента, на котором находятся буферы сервера. Если клиент пытается отправить сообщение, размер которого превышает это ограничение, соединение может быть закрыто.
* `TransportMaxBufferSize`представляет максимальное число байтов, которое может быть отправлено сервером. Если сервер пытается отправить сообщение (включая возвращаемые значения из методов концентратора), превышающие это ограничение, будет создано исключение.

Установка ограничения `0` отключает ограничение. Удаление ограничения позволяет клиенту отправить сообщение любого размера. Вредоносные клиенты, отправляющие большие сообщения, могут вызвать чрезмерное выделение памяти. Чрезмерное использование памяти может значительно сократить количество одновременных подключений.
