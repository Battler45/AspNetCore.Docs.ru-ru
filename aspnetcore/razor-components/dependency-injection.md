---
title: Внедрение зависимостей компонентов Razor
author: guardrex
description: См. в разделе, как Blazor и Razor компоненты приложения могут использовать службы, вставляя их в компоненты.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 03/27/2019
uid: razor-components/dependency-injection
ms.openlocfilehash: 40aec2e3a5032039c7d921f67d7d333b03c07fb1
ms.sourcegitcommit: 3e9e1f6d572947e15347e818f769e27dea56b648
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2019
ms.locfileid: "59515611"
---
# <a name="razor-components-dependency-injection"></a>Внедрение зависимостей компонентов Razor

По [Rainer Stropek](https://www.timecockpit.com)

Компоненты Razor поддерживает [внедрения зависимостей (DI)](xref:fundamentals/dependency-injection). Приложения могут использовать встроенные службы, вставляя их в компоненты. Приложения можно определить и зарегистрировать пользовательские службы и сделать их доступными на протяжении всего приложения посредством внедрения Зависимостей.

## <a name="dependency-injection"></a>Внедрение зависимостей

Внедрение Зависимостей — это способ для доступа к службам, настроенным в центральном расположении. Это может быть полезно в приложениях Razor компоненты:

* Используют общий экземпляр класса службы через множества компонентов, известный как *одноэлементный* службы.
* Отделять компоненты от классов конкретные службы с помощью ссылки абстракции. Например, рассмотрим интерфейс `IDataAccess` для доступа к данным в приложении. Интерфейс реализуется устойчивый `DataAccess` класса и зарегистрирован как служба в контейнере служб приложения. Когда компонент использует внедрения Зависимостей для получения `IDataAccess` реализации, компонент не связан с конкретным типом. Реализацию можно переключать, возможно для реализации макетов в модульных тестах.

Дополнительные сведения см. в разделе <xref:fundamentals/dependency-injection>.

## <a name="add-services-to-di"></a>Добавление служб для внедрения Зависимостей

После создания нового приложения, изучите `Startup.ConfigureServices` метод:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add custom services here
}
```

`ConfigureServices` Методу передается <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>, являющимся списком объектов дескриптора службы (<xref:Microsoft.Extensions.DependencyInjection.ServiceDescriptor>). Службы добавляются, предоставляя дескрипторов службы для службы коллекции. В следующем примере демонстрируется концепция с `IDataAccess` интерфейс и его конкретную реализацию `DataAccess`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IDataAccess, DataAccess>();
}
```

Службы могут быть настроены с временем существования, показано в следующей таблице.

| Время существования | Описание |
| -------- | ----------- |
| <xref:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton*> | Создает DI *единственных* службы. Все компоненты, требующие `Singleton` служба получает экземпляр той же службе. |
| <xref:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Transient*> | Каждый раз, когда компонент получает экземпляр `Transient` службы из контейнера служб, он получает *новый экземпляр* службы. |
| <xref:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Scoped*> | В настоящее время понятие областей внедрения Зависимостей не имеет Blazor на стороне клиента. `Scoped` ведет себя как `Singleton`. Тем не менее, ASP.NET Core Razor компоненты поддерживают `Scoped` времени существования. В компоненте Razor регистрация службы с заданной областью, ограничиваются соединения. По этой причине использование ограниченных служб является предпочтительным для служб, которые должны быть привязаны к текущему пользователю, даже если текущий предполагается выполняемых на стороне клиента в браузере. |

DI система основана на системе внедрения Зависимостей в ASP.NET Core. Дополнительные сведения см. в разделе <xref:fundamentals/dependency-injection>.

## <a name="default-services"></a>Службы по умолчанию

Службы по умолчанию автоматически добавляются к коллекции службы приложений.

| Служба | Описание |
| ------- | ----------- |
| <xref:System.Net.Http.HttpClient> | Предоставляет методы для отправки HTTP-запросов и получения HTTP-ответов от ресурса с заданным URI (единственного экземпляра). Обратите внимание, что этот экземпляр `HttpClient` использует браузер для обработки трафика HTTP в фоновом режиме. [HttpClient.BaseAddress](xref:System.Net.Http.HttpClient.BaseAddress) автоматически присваивается базовый префикс URI приложения. `HttpClient` предоставляется только для приложений Blazor на стороне клиента. |
| `IJSRuntime` | Представляет экземпляр среды выполнения JavaScript, на который может быть отправлен вызовов. Дополнительные сведения см. в разделе <xref:razor-components/javascript-interop>. |
| `IUriHelper` | Содержит вспомогательные методы для работы с состоянием URI и навигации (единственного экземпляра). `IUriHelper` предоставляется Blazor и Razor компоненты приложения. |

Это можно использовать пользовательскую службу поставщика вместо поставщика службы по умолчанию, которые добавлены с помощью шаблона по умолчанию. Поставщик пользовательская служба не предоставляет автоматически службы по умолчанию, перечисленных в таблице. Если вы используете поставщик пользовательских служб и требовать каких-либо служб, приведенных в таблице, добавьте необходимые службы нового поставщика служб.

## <a name="request-a-service-in-a-component"></a>Запрос службы в компоненте

После добавления в коллекцию службы служб внедрить службы в шаблоны Razor компонентов с помощью [ @inject ](xref:mvc/views/razor#section-4) директивы Razor. `@inject` имеет два параметра:

* Имя типа: Тип службы для вставки.
* Имя свойства: Имя свойства, получение внедренного приложения службы. Обратите внимание на то, что свойство не требует создания вручную. Компилятор создает свойства.

Дополнительные сведения см. в разделе <xref:mvc/views/dependency-injection>.

Используйте несколько `@inject` инструкции для добавления различных служб.

В следующем примере показано, как использовать `@inject`. Реализация службы `Services.IDataAccess` вставляется в свойство компонента `DataRepository`. Обратите внимание на то, как код использует только `IDataAccess` абстракции:

[!code-cshtml[](dependency-injection/samples_snapshot/3.x/CustomerList.cshtml?highlight=2-3,23)]

На внутреннем уровне созданное свойство (`DataRepository`) снабжен `InjectAttribute` атрибута. Как правило этот атрибут не используется напрямую. Если базовый класс является обязательным для компонентов и внедренного свойства также требуются для базового класса, `InjectAttribute` можно добавлять вручную:

```csharp
public class ComponentBase : IComponent
{
    // Dependency injection works even if using the
    // InjectAttribute in a component's base class.
    [Inject]
    protected IDataAccess DataRepository { get; set; }
    ...
}
```

В компонентах, производный от базового класса `@inject` директива не является обязательным. `InjectAttribute` Базового класса достаточно:

```cshtml
@page "/demo"
@inherits ComponentBase

<h1>Demo Component</h1>
```

## <a name="dependency-injection-in-services"></a>Внедрение зависимостей в службах

Сложные служб требуются дополнительные службы. В предыдущем примере `DataAccess` может потребоваться `HttpClient` службу по умолчанию. `@inject` (или `InjectAttribute`) недоступен для использования в службах. *Внедрение через конструктор* следует использовать. Путем добавления параметров в конструкторе службы добавляются необходимые службы. Когда внедрение зависимостей создает службу, он распознает служб ему необходим в конструкторе и предоставляет их соответствующим образом.

```csharp
public class DataAccess : IDataAccess
{
    // The constructor receives an HttpClient via dependency
    // injection. HttpClient is a default service.
    public DataAccess(HttpClient client)
    {
        ...
    }
}
```

Предварительные требования для внедрения через конструктор:

* Должен быть хотя бы один конструктор, аргументы которых все выполнения может использоваться внедрения зависимостей. Обратите внимание, что дополнительные параметры, не охваченных DI разрешены в том случае, если они задают значения по умолчанию.
* Соответствующий конструктор должен быть *открытый*.
* Должно существовать только один соответствующий конструктор. В случае неоднозначности DI вызывает исключение.

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:fundamentals/dependency-injection>
* <xref:mvc/views/dependency-injection>
