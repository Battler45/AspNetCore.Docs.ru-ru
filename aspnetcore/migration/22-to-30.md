---
title: Миграция с ASP.NET Core 2,2 на 3,0
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/25/2019
uid: migration/22-to-30
ms.openlocfilehash: 1babb0920e5b44de16003e895755f680eae02807
ms.sourcegitcommit: fe3e556bf438fc4136fcf0bac61cf96e3e91caf5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71341447"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0.

## <a name="prerequisites"></a>Предварительные требования

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Обновление файла проекта

### <a name="update-the-target-framework"></a>Обновление целевой платформы

ASP.NET Core 3,0 и более поздних версий работают только в .NET Core. Задайте `netcoreapp3.0`для [моникера целевой платформы (TFM)](/dotnet/standard/frameworks) значение:

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Удалить устаревшие ссылки на пакеты

ASP.NET Core больше не создает большого количества функций пакетов NuGet. Эти ссылки на пакеты должны быть удалены из файла проекта. Полный список пакетов, которые больше не создаются, см. ниже.

<details>
    <summary>Щелкните здесь, чтобы развернуть список пакетов, которые больше не создаются</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="framework-reference"></a>Справочник по платформе

Функции ASP.NET Core, которые были доступны в одном из перечисленных выше пакетов, доступны в составе `Microsoft.AspNetCore.App` общей платформы. *Общая платформа* — это набор сборок (*DLL* -файлов), установленных на компьютере и включающий компонент среды выполнения и пакет нацеливания. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Проекты, предназначенные `Microsoft.NET.Sdk.Web` для пакета SDK, неявно `Microsoft.AspNetCore.App` ссылаются на платформу.

Для этих проектов дополнительные ссылки не требуются:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Для проектов, `Microsoft.NET.Sdk` предназначенных для или `Microsoft.NET.Sdk.Razor` для пакета SDK `FrameworkReference` , `Microsoft.AspNetCore.App`следует добавить явный к:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Сборки, зависящие от платформы, с помощью DOCKER

Зависящие от платформы сборки консольных приложений, использующих пакет, который зависит от ASP.NET Core [общей платформы](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , может предоставить следующую ошибку времени выполнения:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`— Это общая платформа, содержащая среду выполнения ASP.NET Core и которая имеется только в образе DOCKER, который является [DotNet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  Пакет SDK 3,0 сокращает размер сборок, зависимых от платформы, с помощью asp.net Core, не включая дублированные копии библиотек, доступных в общей платформе.  Это может привести к экономии от до ~ 18MB, но для запуска приложения необходимо, чтобы среда выполнения ASP.NET Core присутствовала или была установлена.

Чтобы определить, имеет ли приложение зависимость (прямую или косвенную) на ASP.NET Core общей платформе, изучите файл *runtimeconfig. JSON* , созданный во время сборки или публикации приложения. В следующем JSON-файле показана зависимость от ASP.NET Core общей платформы:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Если приложение использует DOCKER, используйте базовый образ, включающий ASP.NET Core 3,0. Например, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Добавление ссылок на пакеты для удаленных сборок

ASP.NET Core 3,0 удаляет некоторые сборки, которые ранее были частью `Microsoft.AspNetCore.App` ссылки на пакет. Чтобы продолжить использование функций, предоставляемых этими сборками, сослаться на версии 3,0 соответствующих пакетов.

* Entity Framework Core &ndash; дополнительные сведения об обращении к пакету, зависящему от поставщика базы данных, см. в разделе [поставщики баз данных](/ef/core/providers/index).

* Пользовательский интерфейс удостоверений

  Поддержку [пользовательского интерфейса идентификации](xref:security/authentication/identity) можно добавить, обратившись к пакету [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Службы SPA
  * [Microsoft. AspNetCore. Спасервицес](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. Спасервицес. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Поддержка &ndash; проверки подлинности для сторонних потоков аутентификации доступна в виде пакетов NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Токен носителя OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Проверка подлинности учетной записи Майкрософт ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Проверка подлинности OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Проверка подлинности WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Поддержка форматирования и согласования содержимого `System.Net.HttpClient` для &ndash; пакета NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) обеспечивает удобную расширяемость для `System.Net.HttpClient` таких API-интерфейсов, как `ReadAsAsync`и `PostJsonAsync` т. д.

* Поддержка компиляции &ndash; в среде выполнения Razor для компиляции представлений и страниц Razor в среде выполнения теперь является частью [Microsoft. AspNetCore. MVC. Razor. рунтимекомпилатион](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Поддержка MVC `Newtonsoft.Json` для использования MVC в `Newtonsoft.Json` теперь является частью [Microsoft. AspNetCore. MVC. невтонсофтжсон.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) &ndash;

### <a name="analyzer-support"></a>Поддержка анализатора

Проекты, предназначенные `Microsoft.NET.Sdk.Web` для неявной ссылки на анализаторы, ранее поставляемые в составе пакета [Microsoft. AspNetCore. MVC. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Для включения этих дополнительных ссылок не требуется.

Если приложение использует [анализаторы API](xref:web-api/advanced/analyzers) , которые ранее поставлялись с пакетом [Microsoft. AspNetCore. MVC. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , измените файл проекта, чтобы он ссылался на анализаторы, поставляемые в составе веб-пакета SDK .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Библиотека классов Razor

Проекты библиотеки классов Razor, предоставляющие компоненты пользовательского интерфейса для MVC, должны `AddRazorSupportForMvc` задавать свойство в файле проекта:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Модель внутрипроцессного размещения

По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить `<AspNetCoreHostingModel>` свойство в файле проекта, если его значение равно. `InProcess`

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Конфигурация

Миграция конфигурации Kestrel в построитель веб-узлов `ConfigureWebHostDefaults` , предоставляемый (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Если приложение создает узел вручную с помощью `HostBuilder`, вызовите `UseKestrel` в построителе веб-узлов в: `ConfigureWebHostDefaults`

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>По промежуточного слоя соединения заменяет Адаптеры подключений

Адаптеры подключений (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) удалены из Kestrel. Замените адаптеры подключений по промежуточного слоя соединения. По промежуточного слоя соединения аналогично по промежуточного слоя HTTP в ASP.NET Core конвейере, но для соединений более низкого уровня. Протокол HTTPS и регистрация подключения:

* Были перемещены из адаптеров соединений в по промежуточного слоя соединения.
* Эти методы расширения работают как в предыдущих версиях ASP.NET Core. 

Дополнительные сведения см. в [примере тлсфилтерконнектионхандлер в разделе листеноптионс. Protocols статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Абстракции транспорта перемещены и сделаны открытыми

Транспортный уровень Kestrel предоставляется в виде общедоступного интерфейса `Connections.Abstractions`в. В состав этих обновлений:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`и связанные типы были удалены.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>был перемещен из <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> в параметры транспорта.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>был удален из <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Дополнительные сведения см. в следующих ресурсах GitHub:

* [Абстракции сети "клиент-сервер" (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Реализуйте новую абстракцию прослушивателя основой и повторно Plat Kestrel на вершине (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Заголовков анонса запроса Kestrel

Для приложений, предназначенных для более ранних версий ASP.NET Core:

* Kestrel добавляет заголовки поблочного трейлера HTTP/1.1 в коллекцию заголовков запросов.
* Трейлеры доступны после считывания текста запроса в конец.

Это вызывает некоторые проблемы, связанные с неоднозначностью заголовков и трейлеров, поэтому эти трейлеры были перемещены в новую коллекцию (`RequestTrailerExtensions`) в 3,0.

Запросы HTTP/2:

* Недоступно в ASP.NET Core 2,2.
* Доступно в 3,0 как `RequestTrailerExtensions`.

Для доступа к этим трейлерам имеются новые методы расширения запроса. Как и в случае с HTTP/1.1, трейлеры доступны после считывания текста запроса в конец.

Для выпуска 3,0 доступны следующие `RequestTrailerExtensions` методы.

* `GetDeclaredTrailers`Возвращает заголовок запроса `Trailer` , в котором указывается, какие трейлеры должны рассчитываться после текста. &ndash;
* `SupportsTrailers`&ndash; Указывает, поддерживает ли запрос получение заголовков трейлеров.
* `CheckTrailersAvailable`&ndash; Проверяет, поддерживает ли запрос трейлеры и доступны ли они для чтения. Эта проверка не предполагает наличие трейлеров для чтения. Возможно, не существует трейлеров для чтения, `true` даже если он возвращается этим методом.
* `GetTrailer`&ndash; Возвращает запрошенный конечный заголовок из ответа. Проверка `SupportsTrailers` перед вызовом `GetTrailer`или <xref:System.NotSupportedException> может произойти, если запрос не поддерживает конечные заголовки.

Дополнительные сведения см. [в разделе помещение запроса на постановку в отдельную коллекцию (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Алловсинчронаусио отключена

`AllowSynchronousIO`включает или отключает синхронные API-интерфейсы ввода `HttpRequest.Body.Read`- `HttpResponse.Body.Write`вывода, `Stream.Flush`такие как, и. Эти API-интерфейсы являются источником нехватка потоков, ведущих к сбоям приложений. В 3,0 `AllowSynchronousIO` по умолчанию отключен. Дополнительные сведения см. в [разделе синхронный ввод-вывод статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Помимо `AllowSynchronousIO` параметров с `ConfigureKestrel`параметрами, синхронные операции ввода-вывода можно также переопределить для каждого запроса в качестве временного решения проблемы.

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

При возникновении проблем с <xref:System.IO.TextWriter> реализациями или другими потоками, вызывающими синхронные API-интерфейсы в [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), вызывайте новый <xref:System.IO.Stream.DisposeAsync*> API.

Дополнительные сведения см. [в разделе [объявление] алловсинчронаусио Disabled On All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Удалена сборка Microsoft. AspNetCore. Server. Kestrel. HTTPS

В ASP.NET Core 2,1 содержимое *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* было перемещено в файл *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Это обновление было не критическое с помощью `TypeForwardedTo` атрибутов. Для 3,0 пустая сборка *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* (и пакет NuGet) была удалена.

Библиотеки, ссылающиеся на [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) , должны обновлять зависимости ASP.NET Core до 2,1 или более поздней версии.

Приложения и библиотеки, предназначенные для ASP.NET Core 2,1 или более поздней версии, должны удалять все прямые ссылки на пакет [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Поддержка Json.NET

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

По умолчанию для ASP.NET Core теперь используется [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), который является новым в .net Core 3,0. Рассмотрите `System.Text.Json` возможность использования, когда это возможно. Это высокопроизводительное и не требует дополнительной зависимости библиотеки. Однако поскольку `System.Text.Json` это новая возможность, в настоящее время в ней могут отсутствовать функции, необходимые вашему приложению.

Приложению `Newtonsoft.Json` может потребоваться интеграция, если в нем `Newtonsoft.Json`используются специальные функции, такие как жсонпатч или преобразователи, или типы, зависящие от [формата](xref:web-api/advanced/formatting) `Newtonsoft.Json`.

Сведения об использовании Json.NET в проекте SignalR ASP.NET Core 3,0 см. в разделе [Переключение на Newtonsoft. JSON](#switch-to-newtonsoftjson) в этом документе.

Чтобы использовать Json.NET в проекте ASP.NET Core 3,0, выполните следующие действия.

* Добавьте ссылку на пакет в [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Обновление `Startup.ConfigureServices` для вызова `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`совместима с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Параметры Json.NET можно задать в вызове `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices`.

Доступны три новых метода расширения верхнего уровня `IServiceCollection` , относящихся к сценариям MVC. Шаблоны используют эти новые методы вместо `UseMvc`. Тем не `AddMvc` менее, будет работать так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor Pages и минимальной поддержки контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR`, перенесите приложение в [маршрутизацию конечной точки](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует из `Route`, используйте [динамикраутевалуестрансформер](https://github.com/aspnet/AspNetCore.Docs/issues/12997) в качестве замены.

* Если приложение напрямую обращается `RouteData.Routers` в MVC для анализа URL-адресов, его можно заменить на с `LinkParser.ParsePathByEndpointName`помощью. 
 * Определите маршрут с именем маршрута.
 * Используйте `LinkParser.ParsePathByEndpointName` и передайте нужное имя маршрута.

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания `IRouter`шаблона маршрута, что и. Маршрутизация конечных точек поддерживает `IRouteConstraint`. Маршрутизация конечных `[HttpGet]`точек поддерживает `[Route]`, и другие атрибуты маршрутизации MVC.

Для большинства приложений требуются только `Startup` изменения.

### <a name="migrate-startupconfigure"></a>Миграция запуска. Настройка

Общие рекомендации:

* Добавить `UseRouting`.
* `UseStaticFiles`Если приложение вызывает, `UseStaticFiles` поместите **перед** `UseRouting`ним.
* Если приложение использует функции проверки подлинности и авторизации `AuthorizePage` `UseAuthentication` , `[Authorize]`такие как или, поместите вызов `UseAuthorization`и: after `UseRouting` , `UseCors`и, но `UseEndpoints`до:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    }
  ```

* Замените `UseMvc` или `UseSignalR` на .`UseEndpoints`
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]`, `UseAuthentication` `UseCors` поместите вызов до любого другого по промежуточного слоя, использующего CORS (например, поместите `UseCors` перед, `UseAuthorization`и `UseEndpoints`).
* Замените `IHostingEnvironment` на `IWebHostEnvironment` и добавьте`using`оператор для пространстваимен.<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>
* Замените `IApplicationLifetime` на <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).
* Замените `EnvironmentName` на <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).

Ниже приведен пример `Startup.Configure` кода в типичном приложении ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего `Startup.Configure` кода выполните следующие действия.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Для большинства приложений вызовы `UseAuthentication`, `UseAuthorization`и `UseCors` должны находиться между вызовами функций `UseRouting` и `UseEndpoints` , чтобы быть эффективными.

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности используют маршрутизацию конечных точек с универсальным узлом. В `Startup.Configure` вызовите `MapHealthChecks` для построителя конечной точки с URL-адресом конечной точки или относительным путем:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Конечные точки проверки работоспособности могут:

* Укажите один или несколько разрешенных узлов и портов.
* Требовать авторизацию.
* Требовать CORS.

Дополнительные сведения см. в разделе <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors`можно указать с политикой по умолчанию, а `[EnableCors]` атрибуты `[DisableCors]` и можно использовать для переопределения политики по умолчанию, если это необходимо.

В следующем примере:

* CORS включена для всех конечных точек с `default` именованной политикой.
* Класс отключает CORS `[DisableCors]` с помощью атрибута. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с `[Authorize]` помощью атрибута. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется поместить ASP.NET Core по промежуточного слоя авторизации`UseAuthorization`() сразу `UseAuthentication`после. По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure`, а `HomeController` для следующего требуется пользователь, выполнивший вход:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Если приложение использует `AuthorizeFilter` в качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику в `AddAuthorization`вызове.

`DefaultPolicy` Изначально настраивается для обязательной проверки подлинности, поэтому дополнительная настройка не требуется. В следующем примере конечные точки MVC помечаются `RequireAuthorization` как, так что все запросы должны быть разрешены `DefaultPolicy`на основе. Однако разрешает доступ без входа пользователя в приложение `[AllowAnonymous]`из-за: `HomeController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Политики также можно настроить. Основываясь на предыдущем примере, `DefaultPolicy` настройка требует проверки подлинности и определенной области:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Кроме того, для всех конечных точек можно настроить требование `[Authorize]` авторизации `RequireAuthorization` без использования или `FallbackPolicy`настройки. Объект `FallbackPolicy` отличается`DefaultPolicy`от. Триггер активируется `RequireAuthorization`или, а`FallbackPolicy` триггер активируется, когда не задана другая политика. `[Authorize]` `DefaultPolicy` `FallbackPolicy`изначально настроен на разрешение запросов без авторизации.

Следующий пример аналогичен предыдущему `DefaultPolicy` примеру, но использует, `FallbackPolicy` чтобы всегда требовать проверку подлинности для всех конечных `[AllowAnonymous]` точек, за исключением случаев, когда указан параметр.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

Кроме того, каждая конечная точка может настраивать свои требования к авторизации. В следующем примере `UseAuthorization` обрабатывается авторизация `DefaultPolicy`с помощью, но для `/healthz` конечной точки проверки работоспособности `admin` требуется пользователь:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. `UseEndpoint`по промежуточного слоя создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

### <a name="signalr"></a>SignalR

Сопоставление концентраторов SignalR теперь выполняется внутри `UseEndpoints`.

Сопоставьте каждый концентратор с `MapHub`. Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере добавляется поддержка `ChatHub` концентратора SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Существует новый параметр управления ограничениями на размер сообщений от клиентов. Например, в `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

В ASP.NET Core 2,2 можно задать `TransportMaxBufferSize` и, который эффективно управляет максимальным размером сообщения. В ASP.NET Core 3,0 этот параметр теперь позволяет управлять только максимальным размером до подавления нехватки.

### <a name="mvc-controllers"></a>Контроллеры MVC

Теперь сопоставление контроллеров выполняется внутри `UseEndpoints`.

Добавить `MapControllers` , если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием.

Замените следующее:

* `MapRoute`учет`MapControllerRoute`
* `MapAreaRoute`учет`MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие `MapControllerRoute` как / `MapAreaControllerRoute` ,применяютсявпорядкеихдобавления/. `MapDefaultControllerRoute` Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers`добавляет поддержку контроллеров с маршрутизацией на основе атрибутов.
* `MapAreaControllerRoute`добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute`добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Удаление асинхронного суффикса из имен действий контроллера

В ASP.NET Core 3,0 ASP.NET Core MVC удаляет суффикс `Async` из имен действий контроллера. Это новое значение по умолчанию затрагивает маршрутизацию и создание ссылок. Пример:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

До ASP.NET Core 3,0:

* Предыдущее действие можно было получить в маршруте *Products/ListAsync* .
* Требуется создание ссылки с указанием суффикса `Async`. Пример:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

В ASP.NET Core 3,0:

* Предыдущее действие можно получить с помощью маршрута *Products/List* .
* Для создания канала не требуется указывать суффикс `Async`. Пример:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Это изменение не влияет на имена, указанные с помощью атрибута [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Поведение по умолчанию можно отключить с помощью следующего кода в `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Сопоставление Razor Pages теперь выполняется внутри `UseEndpoints`.

Добавьте `MapRazorPages` , если приложение использует Razor Pages. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor Pages теперь является явной.

В следующем `Startup.Configure` `MapRazorPages` методе добавляется поддержка для Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC `UseMvc` с помощью `UseMvcWithDefaultRoute` или в ASP.NET Core 3,0 требует явного согласия внутри. `Startup.ConfigureServices` Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если приложению требуется поддержка прежних версий `IRouter` , отключите `EnableEndpointRouting` их с помощью любого из следующих `Startup.ConfigureServices`подходов в:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks` , чтобы использовать проверки работоспособности с маршрутизацией конечных точек. Метод принимает аргументы, `UseHealthChecks`аналогичные. `MapHealthChecks` Преимущество использования функции `MapHealthChecks` over `UseHealthChecks` заключается в возможности применения авторизации и более точного контроля над политикой сопоставления.

В следующем примере `MapHealthChecks` метод вызывается для `/healthz`конечной точки проверки работоспособности:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан класс ASP.NET Core 3,0, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>остается в 3,0 и является типом, `webBuilder` отображаемым в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>будет считаться устаревшим в будущих выпусках и `HostBuilder`заменено на.

Наиболее существенным изменением `WebHostBuilder` `HostBuilder` в является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder`можно внедрять <xref:Microsoft.Extensions.Configuration.IConfiguration> только конструкторы и <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> в `Startup`. Ограничения `HostBuilder` Di:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Аддаусоризатион перемещен в другую сборку

Методы ASP.NET Core 2,2 и Lower `AddAuthorization` в *Microsoft. AspNetCore. Authorization. dll*:

* Были переименованы `AddAuthorizationCore`.
* Были перемещены в *Microsoft. AspNetCore. Authorization. Policy. dll*.

Приложения, использующие *Microsoft. AspNetCore. Authorization. dll* и *Microsoft. AspNetCore. Authorization. Policy. dll* , не затрагиваются.

Приложения, которые не используют *Microsoft. AspNetCore. Authorization. Policy. dll* , должны выполнять одно из следующих действий:

* Переключиться на использование`AddAuthorizationCore`
* Добавьте ссылку на *Microsoft. AspNetCore. Authorization. Policy. dll*.

Дополнительные сведения см. [в разделе Перегрузка с `AddAuthorization(o =>`критическим изменением) находится в другой #386 сборки](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Клиент SignalR JavaScript изменился с `@aspnet/signalr` на. `@microsoft/signalr` Чтобы реагировать на это изменение, измените ссылки в файлах *Package. JSON* , `require` инструкциях и инструкциях `import` ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON является протоколом по умолчанию

`System.Text.Json`теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices`вызовите `AddJsonProtocol` , чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Клиент:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft. JSON

Если вы используете функции `Newtonsoft.Json` , которые не поддерживаются в `System.Text.Json`, можно переключиться обратно на: `Newtonsoft.Json`

1. Установите пакет NuGet [Microsoft. AspNetCore. SignalR. Protocols. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. На клиенте привязать `AddNewtonsoftJsonProtocol` вызов метода `HubConnectionBuilder` к экземпляру:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. На сервере привязать `AddNewtonsoftJsonProtocol` вызов метода `AddSignalR` к вызову метода в `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

В 3,0 компиляция среды выполнения является сценарием согласия. Сведения о включении компиляции среды <xref:mvc/views/view-compilation#runtime-compilation>выполнения см. в разделе.

## <a name="migrate-libraries-via-multi-targeting"></a>Миграция библиотек через многоплатформенную нацеливание

Библиотекам часто требуется поддержка нескольких версий ASP.NET Core. Большинство библиотек, которые были скомпилированы в предыдущих версиях ASP.NET Core, должны продолжать работать без проблем. Для следующих условий требуется перекрестная компиляция приложения:

* Библиотека использует функцию с двоичным [критическим изменением](#breaking-api-changes).
* Библиотека хочет воспользоваться преимуществами новых функций в ASP.NET Core 3,0. 

Пример:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Используйте `#ifdefs` , чтобы включить API-интерфейсы ASP.NET Core 3,0.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Прерывание изменений API

* [Полный список критических изменений в выпуске ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Прерывание изменений API в подделке, CORS, диагностике, MVC и маршрутизации](https://github.com/aspnet/Announcements/issues/387). Этот список включает критические изменения для переключателей совместимости.
* Сводные сведения о критических изменениях 2,2-3,0 в .NET Core, ASP.NET Core и Entity Framework Core см. в разделе [критические изменения для миграции с версии 2,2 на 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 в настоящее время недоступна для службы приложений Azure

Мы надеемся, что эта возможность скоро станет доступна. Пока ASP.NET Core 3,0 не будет доступен в службе приложений Azure, следуйте инструкциям в статье [развертывание ASP.NET Core предварительной версии в службе приложений Azure](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. Data. EntityFrameworkCore в настоящее время не поддерживается в ASP.NET Core 3,0

Дополнительные сведения см. в разделе [проблема GitHub](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
