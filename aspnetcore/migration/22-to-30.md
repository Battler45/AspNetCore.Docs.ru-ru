---
title: Миграция с ASP.NET Core 2,2 на 3,0
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 10/08/2019
uid: migration/22-to-30
ms.openlocfilehash: 55eec5a6428d8f5de8847dc2cd92b33c86b0feb6
ms.sourcegitcommit: c452e6af92e130413106c4863193f377cde4cd9c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/10/2019
ms.locfileid: "72246467"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0.

## <a name="prerequisites"></a>Предварительные требования

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Обновление версии пакета SDK для .NET Core в файле global.json

Если решение использует файл [Global. JSON](/dotnet/core/tools/global-json) , предназначенный для конкретной версии пакет SDK для .NET Core, обновите свойство `version` до версии 3,0, установленной на компьютере.

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Обновление файла проекта

### <a name="update-the-target-framework"></a>Обновление целевой платформы

ASP.NET Core 3,0 и более поздних версий работают только в .NET Core. Задайте для [моникера целевой платформы (TFM)](/dotnet/standard/frameworks) значение `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Удалить устаревшие ссылки на пакеты

ASP.NET Core больше не создает большого количества функций пакетов NuGet. Эти ссылки на пакеты должны быть удалены из файла проекта. Например, созданный шаблоном файл проекта для веб-приложения ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Обновленный файл проекта ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Обновленный файл проекта ASP.NET Core 3,0:

* В `<PropertyGroup>`:

  * Обновляет TFM до `netcoreapp3.0`
  * Удаляет элемент `<AspNetCoreHostingModel>`. Дополнительные сведения см. [в разделе внутрипроцессного размещения модели](#in-process-hosting-model) в этом документе.

* В `<ItemGroup>`:

  * `Microsoft.AspNetCore.App` удалено. Дополнительные сведения см. в [справочнике по платформе](#framework-reference) в этом документе.
  * `Microsoft.AspNetCore.Razor.Design` удалена, и в следующем списке пакетов больше не создается.

Чтобы просмотреть полный список пакетов, которые больше не создаются, выберите следующий список развертывания:

<details>
    <summary>Щелкните здесь, чтобы развернуть список пакетов, которые больше не создаются</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Проверка критических изменений

[Проверка критических изменений](#break)

### <a name="framework-reference"></a>Справочник по платформе

Функции ASP.NET Core, которые были доступны в одном из перечисленных выше пакетов, доступны в составе общей платформы `Microsoft.AspNetCore.App`. *Общая платформа* — это набор сборок (*DLL* -файлов), установленных на компьютере и включающий компонент среды выполнения и пакет нацеливания. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Проекты, предназначенные для пакета SDK `Microsoft.NET.Sdk.Web`, неявно ссылаются на платформу `Microsoft.AspNetCore.App`.

Для этих проектов не требуются дополнительные ссылки:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Проекты, предназначенные для `Microsoft.NET.Sdk` или `Microsoft.NET.Sdk.Razor` пакета SDK, должны добавить явное `FrameworkReference` в `Microsoft.AspNetCore.App`:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Сборки, зависящие от платформы, с помощью DOCKER

Зависящие от платформы сборки консольных приложений, использующих пакет, который зависит от ASP.NET Core [общей платформы](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , может предоставить следующую ошибку времени выполнения:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` — это общая платформа, содержащая среду выполнения ASP.NET Core, и она имеется только в образе DOCKER [/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  Пакет SDK 3,0 сокращает размер сборок, зависимых от платформы, с помощью asp.net Core, не включая дублированные копии библиотек, доступных в общей платформе.  Это может привести к экономии до 18 МБ, но для запуска приложения необходимо, чтобы среда выполнения ASP.NET Core присутствовала или была установлена.

Чтобы определить, имеет ли приложение зависимость (прямую или косвенную) на ASP.NET Core общей платформе, изучите файл *runtimeconfig. JSON* , созданный во время сборки или публикации приложения. В следующем JSON-файле показана зависимость от ASP.NET Core общей платформы:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Если приложение использует DOCKER, используйте базовый образ, включающий ASP.NET Core 3,0. Например, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Добавление ссылок на пакеты для удаленных сборок

ASP.NET Core 3,0 удаляет некоторые сборки, которые ранее были частью ссылки на пакет `Microsoft.AspNetCore.App`. Чтобы продолжить использование функций, предоставляемых этими сборками, сослаться на версии 3,0 соответствующих пакетов.

* Веб-приложение, созданное шаблоном с **отдельными учетными записями пользователей** , требует добавления следующих пакетов:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Дополнительные сведения об обращении к пакету для конкретного поставщика базы данных см. в разделе [поставщики баз данных](/ef/core/providers/index).

* Пользовательский интерфейс удостоверений

  Поддержку [пользовательского интерфейса идентификации](xref:security/authentication/identity) можно добавить, обратившись к пакету [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Службы SPA

  * [Microsoft. AspNetCore. Спасервицес](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. Спасервицес. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Проверка подлинности &ndash;. Поддержка сторонних потоков аутентификации доступна в виде пакетов NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Токен носителя OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Проверка подлинности учетной записи Майкрософт ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Проверка подлинности OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Проверка подлинности WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Поддержка форматирования и согласования содержимого для `System.Net.HttpClient` &ndash; пакет NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) предоставляет полезную расширяемость для `System.Net.HttpClient` с помощью таких интерфейсов API, как `ReadAsAsync`, `PostJsonAsync` и т. д.

* Компиляция среды выполнения Razor &ndash; поддержка компиляции представлений и страниц Razor в среде выполнения теперь является частью [Microsoft. AspNetCore. MVC. Razor. рунтимекомпилатион](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Платформа MVC `Newtonsoft.Json` поддерживает &ndash; поддержку использования MVC с `Newtonsoft.Json` теперь является частью [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Изменения при запуске

На следующем рисунке показаны удаленные и измененные строки в веб-приложении ASP.NET Core 2,2 Razor Pages.

![Удаленные и измененные строки в веб-приложении ASP.NET Core 2,2 Razor](22-to-30/_static/startup2.2.png)

На предыдущем рисунке удаленный код показан красным цветом. Удаленный код не отображает код параметров файла cookie, который был удален до сравнения файлов.

На следующем рисунке показаны добавленные и измененные строки в веб-приложении ASP.NET Core 3,0 Razor Pages.

![добавленные и измененные строки в веб-приложении ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

На предыдущем рисунке добавлен код, показанный зеленым цветом. Сведения о следующих изменениях:

* `services.AddMvc` в `services.AddRazorPages` см. в статье [Регистрация службы MVC](#mvc-service-registration) в этом документе.
* `CompatibilityVersion` см. в разделе <xref:mvc/compatibility-version>.
* `IHostingEnvironment` в `IWebHostEnvironment` см. в [этом объявлении GitHub](https://github.com/aspnet/AspNetCore/issues/7749).
* `app.UseAuthorization` был добавлен в шаблоны для отображения промежуточного слоя авторизации заказа. Если приложение не использует авторизацию, можно безопасно удалить вызов `app.UseAuthorization`.
* `app.UseEndpoints` см. в разделе [Razor Pages](#razor-pages) или [Миграция запуска. Настройка](#migrate-startupconfigure) в этом документе.

### <a name="analyzer-support"></a>Поддержка анализатора

Проекты, предназначенные для `Microsoft.NET.Sdk.Web`, неявно ссылаются на анализаторы, ранее поставляемые в составе пакета [Microsoft. AspNetCore. MVC. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Для включения этих дополнительных ссылок не требуется.

Если приложение использует [анализаторы API](xref:web-api/advanced/analyzers) , которые ранее поставлялись с пакетом [Microsoft. AspNetCore. MVC. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , измените файл проекта, чтобы он ссылался на анализаторы, поставляемые в составе веб-пакета SDK .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Библиотека классов Razor

Проекты библиотеки классов Razor, предоставляющие компоненты пользовательского интерфейса для MVC, должны устанавливать свойство `AddRazorSupportForMvc` в файле проекта:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Модель внутрипроцессного размещения

По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить свойство `<AspNetCoreHostingModel>` в файле проекта, если его значение равно `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Конфигурация

Перенесите конфигурацию Kestrel в построитель веб-узлов, предоставленный `ConfigureWebHostDefaults` (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Если приложение создает узел вручную с `HostBuilder`, вызовите `UseKestrel` в построителе веб-узлов в `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>По промежуточного слоя соединения заменяет Адаптеры подключений

Адаптеры подключений (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) были удалены из Kestrel. Замените адаптеры подключений по промежуточного слоя соединения. По промежуточного слоя соединения аналогично по промежуточного слоя HTTP в ASP.NET Core конвейере, но для соединений более низкого уровня. Протокол HTTPS и регистрация подключения:

* Были перемещены из адаптеров соединений в по промежуточного слоя соединения.
* Эти методы расширения работают как в предыдущих версиях ASP.NET Core. 

Дополнительные сведения см. в [примере тлсфилтерконнектионхандлер в разделе листеноптионс. Protocols статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Абстракции транспорта перемещены и сделаны открытыми

Транспортный уровень Kestrel предоставляется как открытый интерфейс в `Connections.Abstractions`. В состав этих обновлений:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` и связанные типы были удалены.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> был перемещен из <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> в параметры транспорта.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode> был удален из <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Дополнительные сведения см. в следующих ресурсах GitHub:

* [Абстракции сети "клиент-сервер" (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Реализуйте новую абстракцию прослушивателя основой и повторно Plat Kestrel на вершине (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Заголовков анонса запроса Kestrel

Для приложений, предназначенных для более ранних версий ASP.NET Core:

* Kestrel добавляет заголовки поблочного трейлера HTTP/1.1 в коллекцию заголовков запросов.
* Трейлеры доступны после считывания текста запроса в конец.

Это вызывает некоторые проблемы, связанные с неоднозначностью заголовков и трейлеров, поэтому эти трейлеры были перемещены в новую коллекцию (`RequestTrailerExtensions`) в 3,0.

Запросы HTTP/2:

* Недоступно в ASP.NET Core 2,2.
* Доступно в 3,0 как `RequestTrailerExtensions`.

Для доступа к этим трейлерам имеются новые методы расширения запроса. Как и в случае с HTTP/1.1, трейлеры доступны после считывания текста запроса в конец.

Для выпуска 3,0 доступны следующие методы `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; получает заголовок Request `Trailer`, в котором указывается, какие трейлеры должны рассчитываться после текста.
* `SupportsTrailers` &ndash; указывает, поддерживает ли запрос получение заголовков трейлеров.
* `CheckTrailersAvailable` &ndash; проверяет, поддерживает ли запрос трейлеры и доступны ли они для чтения. Эта проверка не предполагает наличие трейлеров для чтения. Возможно, не существует трейлеров для чтения, даже если этот метод возвращает `true`.
* `GetTrailer` &ndash; получает запрошенный конечный заголовок из ответа. Проверьте `SupportsTrailers` перед вызовом `GetTrailer` или <xref:System.NotSupportedException> может произойти, если запрос не поддерживает конечные заголовки.

Дополнительные сведения см. [в разделе помещение запроса на постановку в отдельную коллекцию (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Алловсинчронаусио отключена

`AllowSynchronousIO` включает или отключает синхронные API ввода-вывода, такие как @no__t – 1, `HttpResponse.Body.Write` и `Stream.Flush`. Эти API-интерфейсы являются источником нехватка потоков, ведущих к сбоям приложений. В 3.0 `AllowSynchronousIO` отключен по умолчанию. Дополнительные сведения см. в [разделе синхронный ввод-вывод статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

В дополнение к включению `AllowSynchronousIO` с параметрами `ConfigureKestrel` синхронные операции ввода-вывода также можно переопределить для каждого запроса как временное снижение:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

При возникновении проблем с реализациями <xref:System.IO.TextWriter> или другими потоками, вызывающими синхронные API-интерфейсы в [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), вызывайте новый API @no__t – 2.

Дополнительные сведения см. [в разделе [объявление] алловсинчронаусио Disabled On All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Удалена сборка Microsoft. AspNetCore. Server. Kestrel. HTTPS

В ASP.NET Core 2,1 содержимое *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* было перемещено в файл *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Это не критическое обновление с использованием атрибутов `TypeForwardedTo`. Для 3,0 пустая сборка *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* и пакет NuGet удалены.

Библиотеки, ссылающиеся на [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) , должны обновлять зависимости ASP.NET Core до 2,1 или более поздней версии.

Приложения и библиотеки, предназначенные для ASP.NET Core 2,1 или более поздней версии, должны удалять все прямые ссылки на пакет [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Поддержка Json.NET

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

По умолчанию для ASP.NET Core теперь используется [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), который является новым в .net Core 3,0. По возможности рекомендуется использовать `System.Text.Json`. Это высокопроизводительное и не требует дополнительной зависимости библиотеки. Однако, поскольку `System.Text.Json` является новым, в настоящее время могут отсутствовать функции, необходимые для приложения.

Приложению может потребоваться интеграция `Newtonsoft.Json`, если в ней используется функция @no__t -1, например Жсонпатч или converters, или если она [форматирует](xref:web-api/advanced/formatting) @no__t типов, характерных для -3.

Сведения об использовании Json.NET в проекте SignalR ASP.NET Core 3,0 см. в разделе [Переключение на Newtonsoft. JSON](#switch-to-newtonsoftjson) в этом документе.

Чтобы использовать Json.NET в проекте ASP.NET Core 3,0, выполните следующие действия.

* Добавьте ссылку на пакет в [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Обновите `Startup.ConfigureServices`, чтобы вызвать `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` совместим с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Параметры Json.NET можно задать в вызове `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices`.

Доступны три новых метода расширения верхнего уровня, связанные с сценариями MVC на `IServiceCollection`. Шаблоны используют эти новые методы вместо `UseMvc`. Однако `AddMvc` продолжит вести себя так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor Pages и минимальной поддержки контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR`, перенесите приложение в [службу маршрутизации конечных точек](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует от `Route`, используйте [динамикраутевалуестрансформер](https://github.com/aspnet/AspNetCore.Docs/issues/12997) в качестве замены.

* Если приложение получает прямой доступ к `RouteData.Routers` в MVC для анализа URL-адресов, его можно заменить на использование `LinkParser.ParsePathByEndpointName`. 
 * Определите маршрут с именем маршрута.
 * Используйте `LinkParser.ParsePathByEndpointName` и передайте имя нужного маршрута.

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания шаблона маршрута, что и `IRouter`. Маршрутизация конечных точек поддерживает `IRouteConstraint`. Маршрутизация конечных точек поддерживает `[Route]`, `[HttpGet]`, а также другие атрибуты маршрутизации MVC.

Для большинства приложений только `Startup` требует внесения изменений.

### <a name="migrate-startupconfigure"></a>Миграция запуска. Настройка

Общие рекомендации:

* Добавьте `UseRouting`.
* Если приложение вызывает `UseStaticFiles`, поместите `UseStaticFiles` **перед** `UseRouting`.
* Если приложение использует функции проверки подлинности и авторизации, такие как `AuthorizePage` или `[Authorize]`, поместите вызов в `UseAuthentication` и `UseAuthorization`: **After**, `UseRouting` и `UseCors`, но до `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Замените `UseMvc` или `UseSignalR` на `UseEndpoints`.
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]`, поместите вызов `UseCors` до любого другого по промежуточного слоя, использующего CORS (например, поместите `UseCors` перед `UseAuthentication`, `UseAuthorization` и `UseEndpoints`).
* Замените `IHostingEnvironment` на `IWebHostEnvironment` и добавьте оператор `using` для пространства имен <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Замените `IApplicationLifetime` на <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (пространство имен <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Замените `EnvironmentName` на <xref:Microsoft.Extensions.Hosting.Environments> (пространство имен <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Ниже приведен пример кода `Startup.Configure` в типичном приложении ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего кода `Startup.Configure`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Для большинства приложений вызовы `UseAuthentication`, `UseAuthorization` и `UseCors` должны находиться между вызовами `UseRouting` и `UseEndpoints`, чтобы быть эффективным.

### <a name="health-checks"></a>Проверки работоспособности

Для проверок работоспособности используется маршрутизация конечных точек с универсальным узлом. В `Startup.Configure` вызовите `MapHealthChecks` для построителя конечной точки с URL-адресом конечной точки или относительным путем:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Конечные точки проверки работоспособности могут:

* указать один или несколько разрешенных узлов или портов;
* требовать авторизацию;
* требовать CORS.

Дополнительные сведения см. в разделе <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors` может быть предоставлена с политикой по умолчанию, а атрибуты `[EnableCors]` и `[DisableCors]` можно использовать для переопределения политики по умолчанию, если это необходимо.

В следующем примере:

* CORS включается для всех конечных точек с именованной политикой `default`.
* Класс `MyController` отключает CORS с атрибутом `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с помощью атрибута `[Authorize]`. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется размещать ASP.NET Core по промежуточного слоя авторизации (`UseAuthorization`) сразу после `UseAuthentication`. По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure`, а для следующего `HomeController` требуется пользователь, выполнивший вход:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Если приложение использует `AuthorizeFilter` в качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику в вызове `AddAuthorization`.

@No__t-0 изначально настроен для обязательной проверки подлинности, поэтому дополнительная настройка не требуется. В следующем примере конечные точки MVC помечаются как `RequireAuthorization`, поэтому все запросы должны быть разрешены на основе `DefaultPolicy`. Однако `HomeController` разрешает доступ без входа пользователя в приложение из-за `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Политики также можно настроить. Основываясь на предыдущем примере, `DefaultPolicy` настроена для требования проверки подлинности и определенной области:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Кроме того, для всех конечных точек можно настроить требование авторизации без `[Authorize]` или `RequireAuthorization`, настроив `FallbackPolicy`. @No__t-0 отличается от `DefaultPolicy`. @No__t-0 активируется `[Authorize]` или `RequireAuthorization`, а `FallbackPolicy` активируется, если не задана другая политика. `FallbackPolicy` изначально настроен на разрешение запросов без авторизации.

Следующий пример аналогичен предыдущему примеру `DefaultPolicy`, но использует `FallbackPolicy`, чтобы всегда требовать проверку подлинности для всех конечных точек, за исключением случаев, когда указано `[AllowAnonymous]`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

Кроме того, каждая конечная точка может настраивать свои требования к авторизации. В следующем примере `UseAuthorization` обрабатывает авторизацию с `DefaultPolicy`, но для конечной точки проверки работоспособности `/healthz` требуется пользователь `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. По промежуточного слоя конечных точек создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

### <a name="signalr"></a>SignalR

Сопоставление концентраторов SignalR теперь выполняется в `UseEndpoints`.

Сопоставьте каждый концентратор с `MapHub`. Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере добавляется поддержка концентратора SignalR `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Существует новый параметр управления ограничениями на размер сообщений от клиентов. Например, в `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

В ASP.NET Core 2,2 можно установить `TransportMaxBufferSize` и эффективно управлять максимальным размером сообщения. В ASP.NET Core 3,0 этот параметр теперь позволяет управлять только максимальным размером до подавления нехватки.

### <a name="mvc-controllers"></a>Контроллеры MVC

Теперь сопоставление контроллеров выполняется в `UseEndpoints`.

Добавьте `MapControllers`, если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием.

Замените следующее:

* `MapRoute` с `MapControllerRoute`
* `MapAreaRoute` с `MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие как `MapControllerRoute` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4, применяются в порядке их добавления. Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers` добавляет поддержку контроллеров с маршрутизацией на основе атрибутов.
* `MapAreaControllerRoute` добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute` добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Удаление асинхронного суффикса из имен действий контроллера

В ASP.NET Core 3,0 ASP.NET Core MVC удаляет суффикс `Async` из имен действий контроллера. Это новое значение по умолчанию затрагивает маршрутизацию и создание ссылок. Пример:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

До ASP.NET Core 3,0:

* Предыдущее действие можно было получить в маршруте *Products/ListAsync* .
* Требуется создание ссылки с указанием суффикса `Async`. Пример:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

В ASP.NET Core 3,0:

* Предыдущее действие можно получить с помощью маршрута *Products/List* .
* Для создания канала не требуется указывать суффикс `Async`. Пример:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Это изменение не влияет на имена, указанные с помощью атрибута [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Поведение по умолчанию можно отключить с помощью следующего кода в `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Сопоставление Razor Pages теперь выполняется в `UseEndpoints`.

Добавьте `MapRazorPages`, если приложение использует Razor Pages. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor Pages теперь является явной.

В следующем методе `Startup.Configure` `MapRazorPages` добавляет поддержку Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC с помощью `UseMvc` или `UseMvcWithDefaultRoute` в ASP.NET Core 3,0 требует явного согласия внутри `Startup.ConfigureServices`. Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если для приложения требуется устаревшая поддержка `IRouter`, отключите `EnableEndpointRouting`, используя любой из следующих подходов в `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks`, чтобы использовать проверки работоспособности с маршрутизацией конечных точек. Метод `MapHealthChecks` принимает аргументы, аналогичные `UseHealthChecks`. Преимуществом использования `MapHealthChecks` поверх `UseHealthChecks` является возможность применения авторизации и более точного контроля над политикой сопоставления.

В следующем примере для конечной точки проверки работоспособности в `/healthz` вызывается `MapHealthChecks`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан шаблон ASP.NET Core 3,0, созданный @no__t класса:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный шаблоном `Program`:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> остается в 3,0 и является типом `webBuilder`, показанным в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> будет считаться устаревшим в будущих выпусках и заменено на `HostBuilder`.

Наиболее существенным изменением с `WebHostBuilder` до `HostBuilder` является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder` можно ввести только <xref:Microsoft.Extensions.Configuration.IConfiguration> и <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> в конструктор `Startup`. Ограничения на DI `HostBuilder`:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Аддаусоризатион перемещен в другую сборку

Методы ASP.NET Core 2,2 и ниже `AddAuthorization` в *Microsoft. AspNetCore. Authorization. dll*:

* Были переименованы `AddAuthorizationCore`.
* Были перемещены в *Microsoft. AspNetCore. Authorization. Policy. dll*.

Приложения, использующие *Microsoft. AspNetCore. Authorization. dll* и *Microsoft. AspNetCore. Authorization. Policy. dll* , не затрагиваются.

Приложения, которые не используют *Microsoft. AspNetCore. Authorization. Policy. dll* , должны выполнять одно из следующих действий:

* Переключиться на использование `AddAuthorizationCore`
* Добавьте ссылку на *Microsoft. AspNetCore. Authorization. Policy. dll*.

Дополнительные сведения см. [в разделе критическое изменение перегрузки `AddAuthorization(o =>`) находится в другой сборке #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Клиент JavaScript SignalR изменен с `@aspnet/signalr` на `@microsoft/signalr`. Чтобы реагировать на это изменение, измените ссылки в файлах *Package. JSON* , `require`, а также в инструкциях ECMAScript `import`.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON является протоколом по умолчанию

`System.Text.Json` теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices` вызовите `AddJsonProtocol`, чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Клиент:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft. JSON

Если вы используете функции `Newtonsoft.Json`, которые не поддерживаются в `System.Text.Json`, можно переключиться обратно на `Newtonsoft.Json`:

1. Установите пакет NuGet [Microsoft. AspNetCore. SignalR. Protocols. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. На клиенте привязать вызов метода `AddNewtonsoftJsonProtocol` к экземпляру `HubConnectionBuilder`:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. На сервере привязать вызов метода `AddNewtonsoftJsonProtocol` к вызову метода `AddSignalR` в `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

До ASP.NET Core 3,0, компиляция представлений во время выполнения была неявной функцией платформы. Компиляция среды выполнения дополняет компиляцию представлений во время сборки. Она позволяет платформе компилировать представления Razor и страницы (*CSHTML* -файлы) при изменении файлов без необходимости перестроения всего приложения. Эта функция поддерживает сценарий выполнения быстрого редактирования в интегрированной среде разработки и обновления браузера для просмотра изменений.

В ASP.NET Core 3,0 компиляция среды выполнения является сценарием согласия. Компиляция во время сборки — единственный механизм для просмотра компиляции, включенный по умолчанию. Среда выполнения полагается на Visual Studio или [DotNet-Watch](xref:tutorials/dotnet-watch) в Visual Studio Code, чтобы перестроить проект, когда обнаруживает изменения в *CSHTML* -файлы. В Visual Studio изменения в файлах *CS*, *CSHTML*или *Razor* в выполняемом проекте (<kbd>CTRL + F5</kbd>), но не в режиме отладки (<kbd>F5</kbd>) активируют повторную компиляцию проекта.

Включение компиляции во время выполнения в проекте ASP.NET Core 3,0:

1. установить пакет NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Обновите `Startup.ConfigureServices`, чтобы вызвать `AddRazorRuntimeCompilation`:

    Для ASP.NET Core MVC используйте следующий код:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Для ASP.NET Core Razor Pages используйте следующий код:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Пример в https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation показывает пример включения условия компиляции среды выполнения в средах разработки.

Дополнительные сведения о компиляции файла Razor см. в разделе <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Миграция библиотек через многоплатформенную нацеливание

Библиотекам часто требуется поддержка нескольких версий ASP.NET Core. Большинство библиотек, которые были скомпилированы в предыдущих версиях ASP.NET Core, должны продолжать работать без проблем. Для следующих условий требуется перекрестная компиляция приложения:

* Библиотека использует функцию с двоичным [критическим изменением](#breaking-api-changes).
* Библиотека хочет воспользоваться преимуществами новых функций в ASP.NET Core 3,0. 

Пример:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Чтобы включить API-интерфейсы ASP.NET Core 3,0, используйте `#ifdefs`:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Публикация

Удалите папки *bin* и *obj* в каталоге проекта.

<a name="break"></a>

## <a name="breaking-api-changes"></a>Прерывание изменений API

Ознакомьтесь с критическими изменениями:

* [Полный список критических изменений в выпуске ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Прерывание изменений API в подделке, CORS, диагностике, MVC и маршрутизации](https://github.com/aspnet/Announcements/issues/387). Этот список содержит критические изменения для параметров совместимости.
* Сводные сведения о критических изменениях 2,2-3,0 в .NET Core, ASP.NET Core и Entity Framework Core см. в разделе [критические изменения для миграции с версии 2,2 на 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 в настоящее время недоступна для службы приложений Azure

Мы надеемся, что эта возможность скоро станет доступна. Пока ASP.NET Core 3,0 не будет доступен в службе приложений Azure, следуйте инструкциям в статье [развертывание ASP.NET Core предварительной версии в службе приложений Azure](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. Data. EntityFrameworkCore в настоящее время не поддерживается в ASP.NET Core 3,0

Дополнительные сведения см. в разделе [проблема GitHub](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
