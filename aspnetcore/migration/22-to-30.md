---
title: Миграция с ASP.NET Core 2,2 на 3,0 (Предварительная версия)
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: 1318d97fedb3f77ba0a1a153383207914448bb96
ms.sourcegitcommit: fa61d882be9d0c48bd681f2efcb97e05522051d0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/23/2019
ms.locfileid: "71205738"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0.

## <a name="prerequisites"></a>Предварительные требования

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Обновление файла проекта

### <a name="update-the-target-framework"></a>Обновление целевой платформы

ASP.NET Core версии 3.0 и более поздних будут выполняться только в .NET Core. Задайте `netcoreapp3.0`для [моникера целевой платформы (TFM)](/dotnet/standard/frameworks) значение:

```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Удалить устаревшие ссылки на пакеты

ASP.NET Core больше не создает большого количества функций пакетов NuGet. Эти ссылки на пакеты должны быть удалены из файла проекта. Полный список пакетов, которые больше не создаются, см. ниже.

<details>
    <summary>Щелкните здесь, чтобы развернуть список пакетов, которые больше не создаются</summary>

    * Microsoft.AspNetCore
    * Microsoft.AspNetCore.All
    * Microsoft.AspNetCore.App
    * Microsoft. AspNetCore. подделка
    * Microsoft. AspNetCore. Authentication
    * Microsoft. AspNetCore. Authentication. абстракции
    * Файлы cookie Microsoft. AspNetCore. Authentication.
    * Microsoft. AspNetCore. Authentication. Core
    * Microsoft. AspNetCore. Authentication. JwtBearer
    * Microsoft. AspNetCore. Authentication. OAuth
    * Microsoft. AspNetCore. Authentication. OpenIdConnect
    * Microsoft. AspNetCore. Authorization
    * Microsoft. AspNetCore. Authorization. Policy
    * Microsoft. AspNetCore. Кукиеполици
    * Microsoft. AspNetCore. CORS
    * Microsoft. AspNetCore. Cryptography. internal
    * Microsoft. AspNetCore. Cryptography. KeyDerivation
    * Microsoft.AspNetCore.DataProtection
    * Microsoft. AspNetCore. для защиты. абстракции
    * Microsoft. AspNetCore. в отношении защиты. Extensions
    * Microsoft. AspNetCore. Diagnostics
    * Microsoft. AspNetCore. Diagnostics. HealthChecks
    * Microsoft.AspNetCore.HostFiltering
    * Microsoft.AspNetCore.Hosting
    * Microsoft. AspNetCore. Hosting. абстракции
    * Microsoft. AspNetCore. Hosting. Server. Abstracts
    * Microsoft. AspNetCore. http
    * Microsoft. AspNetCore. http. абстракции
    * Microsoft. AspNetCore. http. Connections
    * Microsoft. AspNetCore. http. Extensions
    * Microsoft. AspNetCore. http. Features
    * Microsoft. AspNetCore. Хттповерридес
    * Microsoft. AspNetCore. Хттпсполици
    * Microsoft. AspNetCore. Identity
    * Microsoft. AspNetCore. Localization
    * Microsoft. AspNetCore. Localization. Routing
    * Microsoft. AspNetCore. Миддлевареаналисис
    * Microsoft.AspNetCore.Mvc
    * Microsoft. AspNetCore. MVC. абстракции
    * Microsoft. AspNetCore. MVC. Analyzers
    * Microsoft. AspNetCore. MVC. Апиексплорер
    * Microsoft. AspNetCore. MVC. API. Analyzer
    * Microsoft. AspNetCore. MVC. Core
    * Microsoft. AspNetCore. MVC. CORS
    * Аннотации Microsoft. AspNetCore. MVC.
    * Microsoft. AspNetCore. MVC. Formatter. JSON
    * Microsoft. AspNetCore. MVC. Formatter. XML
    * Microsoft. AspNetCore. MVC. Localization
    * Microsoft.AspNetCore.Mvc.Razor
    * Microsoft. AspNetCore. MVC. Razor. Extensions
    * Microsoft. AspNetCore. MVC. Razor. ViewCompilation
    * Microsoft. AspNetCore. MVC. Разорпажес
    * Microsoft. AspNetCore. MVC. TagHelpers
    * Microsoft. AspNetCore. MVC. Виевфеатурес
    * Microsoft. AspNetCore. Razor
    * Microsoft. AspNetCore. Razor. Runtime
    * Microsoft. AspNetCore. Razor. Design
    * Microsoft. AspNetCore. Респонсекачинг
    * Microsoft. AspNetCore. Респонсекачинг. абстракции
    * Microsoft. AspNetCore. Респонсекомпрессион
    * Microsoft. AspNetCore. перезапись
    * Microsoft.AspNetCore.Routing
    * Microsoft. AspNetCore. Routing. абстракции
    * Microsoft. AspNetCore. Server. HttpSys
    * Microsoft. AspNetCore. Server. IIS
    * Microsoft. AspNetCore. Server. IISIntegration
    * Microsoft. AspNetCore. Server. Kestrel
    * Microsoft. AspNetCore. Server. Kestrel. Core
    * Microsoft. AspNetCore. Server. Kestrel. HTTPS
    * Microsoft. AspNetCore. Server. Kestrel. Transport. абстракции
    * Microsoft. AspNetCore. Server. Kestrel. Transport. Sockets
    * Microsoft. AspNetCore. Session
    * Microsoft. AspNetCore. SignalR
    * Microsoft. AspNetCore. SignalR. Core
    * Microsoft.AspNetCore.StaticFiles
    * Сокеты Microsoft. AspNetCore. WebSockets
    * Служебные программы Microsoft. AspNetCore.
    * Microsoft.Net. http. Headers</details>

### <a name="framework-reference"></a>Справочник по платформе

Функции ASP.NET Core, которые были доступны в одном из перечисленных выше пакетов, доступны в составе `Microsoft.AspNetCore.App` общей платформы.  *Общая платформа* — это набор сборок (*DLL* -файлов), установленных на компьютере и включающий компонент среды выполнения и пакет нацеливания. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).


* Проекты, предназначенные `Microsoft.NET.Sdk.Web` для пакета SDK, неявно `Microsoft.AspNetCore.App` ссылаются на платформу.

Для этих проектов дополнительные ссылки не требуются:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Для проектов, `Microsoft.NET.Sdk` предназначенных для или `Microsoft.NET.Sdk.Razor` для пакета SDK `FrameworkReference` , `Microsoft.AspNetCore.App`следует добавить явный к:

```xml
<Project SDK="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

### <a name="add-package-references-for-removed-assemblies"></a>Добавление ссылок на пакеты для удаленных сборок

ASP.NET Core 3,0 удаляет некоторые сборки, которые ранее были частью `Microsoft.AspNetCore.App` ссылки на пакет. Чтобы продолжить использование функций, предоставляемых этими сборками, сослаться на версии 3,0 соответствующих пакетов.

* Entity Framework Core. Дополнительные https://docs.microsoft.com/ef/core/providers/index сведения об обращении к пакету для конкретного поставщика базы данных см. в разделе.

* Поддержку пользовательского интерфейса удостоверений для [пользовательского интерфейса удостоверений](xref:security/authentication/identity) можно добавить, обратившись к пакету [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Службы SPA
    * [Microsoft. AspNetCore. Спасервицес](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
    * [Microsoft. AspNetCore. Спасервицес. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Проверка подлинности. Поддержка сторонних потоков аутентификации доступна в виде пакетов NuGet:

    * [Facebook OAuth](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook)
    * [Google OAuth](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google)
    * [Токен носителя OpenID Connect Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
    * [Проверка подлинности учетной записи Майкрософт](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount)
    * [Проверка подлинности OpenID Connect Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
    * [OAuth для Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter)
    * [Проверка подлинности WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* Поддержка форматирования и согласования содержимого `System.Net.HttpClient` для — пакет NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) `System.Net.HttpClient` обеспечивает полезную расширяемость с помощью API- `ReadAsAsync`интерфейсов, таких как и `PostJsonAsync` т. д.

* Компиляция среды выполнения Razor. поддержка компиляции представлений и страниц Razor во время выполнения теперь является частью [Microsoft. AspNetCore. MVC. Razor. рунтимекомпилатион](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Поддержка `Newtonsoft.Json` MVC. Поддержка использования MVC с `Newtonsoft.Json` теперь является частью [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Поддержка анализатора

* Проекты, предназначенные `Microsoft.NET.Sdk.Web` для неявной ссылки на анализаторы, ранее поставляемые в составе пакета [Microsoft. AspNetCore. MVC. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Для включения этих дополнительных ссылок не требуется.

* Если приложение использует [анализаторы API](xref:web-api/advanced/analyzers) , которые ранее поставлялись с пакетом [Microsoft. AspNetCore. MVC. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , измените файл проекта, чтобы он ссылался на анализаторы, поставляемые в составе веб-пакета SDK .NET Core:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Библиотека классов Razor

Проекты библиотеки классов Razor, предоставляющие компоненты пользовательского интерфейса для MVC, должны `AddRazorSupportForMvc` задавать свойство в файле проекта:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Модель внутрипроцессного размещения

* По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить `<AspNetCoreHostingModel>` свойство в файле проекта, если его значение равно. `InProcess`

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Параметр Configuration

Миграция конфигурации Kestrel в построитель веб-узлов `ConfigureWebHostDefaults` , предоставляемый (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Если приложение создает узел вручную с помощью `HostBuilder`, вызовите `UseKestrel` в построителе веб-узлов в: `ConfigureWebHostDefaults`

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>По промежуточного слоя соединения заменяет Адаптеры подключений

Адаптеры подключений (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) удалены из Kestrel. Замените адаптеры подключений по промежуточного слоя соединения. По промежуточного слоя соединения аналогично по промежуточного слоя HTTP в ASP.NET Core конвейере, но для соединений более низкого уровня. Протокол HTTPS и регистрация подключения:

* Были перемещены из адаптеров соединений в по промежуточного слоя соединения.
* Эти методы расширения работают как в предыдущих версиях ASP.NET Core. 

Дополнительные сведения см. в [примере тлсфилтерконнектионхандлер в разделе листеноптионс. Protocols статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Абстракции транспорта перемещены и сделаны открытыми

Транспортный уровень Kestrel предоставляется в виде общедоступного интерфейса `Connections.Abstractions`в. В состав этих обновлений:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`и связанные типы были удалены.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>был перемещен из <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> в параметры транспорта.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>был удален из <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Дополнительные сведения см. в следующих ресурсах GitHub:

* [Абстракции сети "клиент-сервер" (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Реализуйте новую абстракцию прослушивателя основой и повторно Plat Kestrel на вершине (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Заголовков анонса запроса Kestrel

Для приложений, предназначенных для более ранних версий ASP.NET Core:

* Kestrel добавляет заголовки поблочного трейлера HTTP/1.1 в коллекцию заголовков запросов.
* Трейлеры доступны после считывания текста запроса в конец.

Это вызывает некоторые проблемы, связанные с неоднозначностью заголовков и трейлеров, поэтому эти трейлеры были перемещены в новую коллекцию (`RequestTrailerExtensions`) в 3,0.

Запросы HTTP/2:

* Недоступно в ASP.NET Core 2,2.
* Доступно в 3,0 как `RequestTrailerExtensions`.

Для доступа к этим трейлерам имеются новые методы расширения запроса. Как и в случае с HTTP/1.1, трейлеры доступны после считывания текста запроса в конец.

Для выпуска 3,0 доступны следующие `RequestTrailerExtensions` методы.

* `GetDeclaredTrailers`Возвращает заголовок запроса `Trailer` , в котором указывается, какие трейлеры должны рассчитываться после текста. &ndash;
* `SupportsTrailers`&ndash; Указывает, поддерживает ли запрос получение заголовков трейлеров.
* `CheckTrailersAvailable`&ndash; Проверяет, поддерживает ли запрос трейлеры и доступны ли они для чтения. Эта проверка не предполагает наличие трейлеров для чтения. Возможно, не существует трейлеров для чтения, `true` даже если он возвращается этим методом.
* `GetTrailer`&ndash; Возвращает запрошенный конечный заголовок из ответа. Проверка `SupportsTrailers` перед вызовом `GetTrailer`или <xref:System.NotSupportedException> может произойти, если запрос не поддерживает конечные заголовки.

Дополнительные сведения см. [в разделе помещение запроса на постановку в отдельную коллекцию (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Алловсинчронаусио отключена

`AllowSynchronousIO`включает или отключает синхронные API-интерфейсы ввода `HttpRequest.Body.Read`- `HttpResponse.Body.Write`вывода, `Stream.Flush`такие как, и. Эти API-интерфейсы являются источником нехватка потоков, ведущих к сбоям приложений. В 3,0 `AllowSynchronousIO` по умолчанию отключен. Дополнительные сведения см. в [разделе синхронный ввод-вывод статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Помимо `AllowSynchronousIO` параметров с `ConfigureKestrel`параметрами, синхронные операции ввода-вывода можно также переопределить для каждого запроса в качестве временного решения проблемы.

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

При возникновении проблем с <xref:System.IO.TextWriter> реализациями или другими потоками, вызывающими синхронные API-интерфейсы в [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), вызывайте новый <xref:System.IO.Stream.DisposeAsync*> API.

Дополнительные сведения см. [в разделе [объявление] алловсинчронаусио Disabled On All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Удалена сборка Microsoft. AspNetCore. Server. Kestrel. HTTPS

В ASP.NET Core 2,1 содержимое *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* было перемещено в файл *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Это обновление было не критическое с помощью `TypeForwardedTo` атрибутов. Для 3,0 пустая сборка *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* (и пакет NuGet) была удалена.

Библиотеки, ссылающиеся на [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) , должны обновлять зависимости ASP.NET Core до 2,1 или более поздней версии.

Приложения и библиотеки, предназначенные для ASP.NET Core 2,1 или более поздней версии, должны удалять все прямые ссылки на пакет [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Поддержка Json.NET

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

По умолчанию для ASP.NET Core теперь используется [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), который является новым в .net Core 3,0. Рассмотрите `System.Text.Json` возможность использования, когда это возможно. Это высокопроизводительное и не требует дополнительной зависимости библиотеки. Однако поскольку `System.Text.Json` это новая возможность, в настоящее время в ней могут отсутствовать функции, необходимые вашему приложению.

Приложению `Netwtonsoft.Json` может потребоваться интеграция, если в нем `Newtonsoft.Json`используются специальные функции, такие как жсонпатч или преобразователи, или типы, зависящие от [формата](xref:web-api/advanced/formatting) `Newtonsoft.Json`.

Сведения об использовании Json.NET в проекте SignalR ASP.NET Core 3,0 см. в разделе [Переключение на Newtonsoft. JSON](#switch-to-newtonsoftjson) в этом документе.

Чтобы использовать Json.NET в проекте ASP.NET Core 3,0, выполните следующие действия.

* Добавьте ссылку на пакет в [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Обновление `Startup.ConfigureServices` для вызова `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`совместима с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Параметры Json.NET можно задать в вызове `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices`.

Доступны три новых метода расширения верхнего уровня `IServiceCollection` , относящихся к сценариям MVC. Шаблоны используют эти новые методы вместо `UseMvc`. Тем не `AddMvc` менее, будет работать так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor Pages и минимальной поддержки контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR`, перенесите приложение в [маршрутизацию конечной точки](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует из `Route`, используйте [динамикраутевалуестрансформер](https://github.com/aspnet/AspNetCore.Docs/issues/12997) в качестве замены.

* Если приложение напрямую обращается `RouteData.Routers` в MVC для анализа URL-адресов, его можно заменить на с `LinkParser.ParsePathByEndpointName`помощью. 
 * Определите маршрут с именем маршрута.
 * Используйте `LinkParser.ParsePathByEndpointName` и передайте нужное имя маршрута.

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания `IRouter`шаблона маршрута, что и. Маршрутизация конечных точек поддерживает `IRouteConstraint`. Маршрутизация конечных `[HttpGet]`точек поддерживает `[Route]`, и другие атрибуты маршрутизации MVC.

Для большинства приложений требуются только `Startup` изменения.

### <a name="migrate-startupconfigure"></a>Миграция запуска. Настройка

Общие рекомендации:

* Добавить `UseRouting`.
* `UseStaticFiles`Если приложение вызывает, `UseStaticFiles` поместите **перед** `UseRouting`ним.
* Если приложение использует функции проверки подлинности и авторизации `AuthorizePage` , `[Authorize]`такие как или, поместите `UseAuthentication` вызов `UseAuthorization` в и **после** `UseRouting` (и **после** `UseCors` использования по промежуточного слоя CORS).
* Замените `UseMvc` или `UseSignalR` на .`UseEndpoints`
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]`, `UseAuthentication` `UseCors` поместите вызов до любого другого по промежуточного слоя, использующего CORS (например, поместите `UseCors` перед, `UseAuthorization`и `UseEndpoints`).
* Замените `IHostingEnvironment` на `IWebHostEnvironment` и добавьте`using`оператор для пространстваимен.<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>
* Замените `IApplicationLifetime` на <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).
* Замените `EnvironmentName` на <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).

Ниже приведен пример `Startup.Configure` кода в типичном приложении ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего `Startup.Configure` кода выполните следующие действия.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Для большинства приложений вызовы `UseAuthentication`, `UseAuthorization`и `UseCors` должны находиться между вызовами функций `UseRouting` и `UseEndpoints` , чтобы быть эффективными.
### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности используют маршрутизацию конечных точек с универсальным узлом. В `Startup.Configure` вызовите `MapHealthChecks` для построителя конечной точки с URL-адресом конечной точки или относительным путем:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Конечные точки проверки работоспособности могут:

* Укажите один или несколько разрешенных узлов и портов.
* Требовать авторизацию.
* Требовать CORS.

Дополнительные сведения см. в разделе <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors`можно указать с политикой по умолчанию, а `[EnableCors]` атрибуты `[DisableCors]` и можно использовать для переопределения политики по умолчанию, если это необходимо.

В следующем примере:

* CORS включена для всех конечных точек с `default` именованной политикой.
* Класс отключает CORS `[DisableCors]` с помощью атрибута. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Авторизация

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с `[Authorize]` помощью атрибута. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется поместить ASP.NET Core по промежуточного слоя авторизации`UseAuthorization`() сразу `UseAuthentication`после. По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure`, а `HomeController` для следующего требуется пользователь, выполнивший вход:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Если приложение использует `AuthorizeFilter` в качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику в `AddAuthorization`вызове.

`DefaultPolicy` Изначально настраивается для обязательной проверки подлинности, поэтому дополнительная настройка не требуется. В следующем примере конечные точки MVC помечаются `RequireAuthorization` как, так что все запросы должны быть разрешены `DefaultPolicy`на основе. Однако разрешает доступ без входа пользователя в приложение `[AllowAnonymous]`из-за: `HomeController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Политики также можно настроить. Основываясь на предыдущем примере, `DefaultPolicy` настройка требует проверки подлинности и определенной области:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Кроме того, для всех конечных точек можно настроить требование `[Authorize]` авторизации `RequireAuthorization` без использования или `FallbackPolicy`настройки. Объект `FallbackPolicy` отличается`DefaultPolicy`от. Триггер активируется `RequireAuthorization`или, а`FallbackPolicy` триггер активируется, когда не задана другая политика. `[Authorize]` `DefaultPolicy` `FallbackPolicy`изначально настроен на разрешение запросов без авторизации.

Следующий пример аналогичен предыдущему `DefaultPolicy` примеру, но использует, `FallbackPolicy` чтобы всегда требовать проверку подлинности для всех конечных `[AllowAnonymous]` точек, за исключением случаев, когда указан параметр.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

Кроме того, каждая конечная точка может настраивать свои требования к авторизации. В следующем примере `UseAuthorization` обрабатывается авторизация `DefaultPolicy`с помощью, но для `/healthz` конечной точки проверки работоспособности `admin` требуется пользователь:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. `UseEndpoint`по промежуточного слоя создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

### <a name="signalr"></a>SignalR

Сопоставление концентраторов SignalR теперь выполняется внутри `UseEndpoints`.

Сопоставьте каждый концентратор с `MapHub`. Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере добавляется поддержка `ChatHub` концентратора SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Существует новый параметр управления ограничениями на размер сообщений от клиентов. Например, в `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

В ASP.NET Core 2,2 можно задать `TransportMaxBufferSize` и, который эффективно управляет максимальным размером сообщения. В ASP.NET Core 3,0 этот параметр теперь позволяет управлять только максимальным размером до подавления нехватки.

### <a name="mvc-controllers"></a>Контроллеры MVC

Теперь сопоставление контроллеров выполняется внутри `UseEndpoints`.

Добавить `MapControllers` , если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием.

Замените следующее:

* `MapRoute`учет`MapControllerRoute`
* `MapAreaRoute`учет`MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие `MapControllerRoute` как / `MapAreaControllerRoute` ,применяютсявпорядкеихдобавления/. `MapDefaultControllerRoute` Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers`добавляет поддержку контроллеров с маршрутизацией на основе атрибутов.
* `MapAreaControllerRoute`добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute`добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Сопоставление Razor Pages теперь выполняется внутри `UseEndpoints`.

Добавьте `MapRazorPages` , если приложение использует Razor Pages. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor Pages теперь является явной.

В следующем примере `MapRazorPages` добавляется поддержка для Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC `UseMvc` с помощью `UseMvcWithDefaultRoute` или в ASP.NET Core 3,0 требует явного согласия внутри. `Startup.ConfigureServices` Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если приложению требуется поддержка прежних версий `IRouter` , отключите `EnableEndpointRouting` их с помощью любого из следующих `Startup.ConfigureServices`подходов в:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks` , чтобы использовать проверки работоспособности с маршрутизацией конечных точек. Метод принимает аргументы, `UseHealthChecks`аналогичные. `MapHealthChecks` Преимущество использования функции `MapHealthChecks` over `UseHealthChecks` заключается в возможности применения авторизации и более точного контроля над политикой сопоставления.

В следующем примере `MapHealthChecks` метод вызывается для `/healthz`конечной точки проверки работоспособности:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан класс ASP.NET Core 3,0, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>остается в 3,0 и является типом, `webBuilder` отображаемым в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>будет считаться устаревшим в будущих выпусках и `HostBuilder`заменено на.

Наиболее существенным изменением `WebHostBuilder` `HostBuilder` в является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder`можно внедрять <xref:Microsoft.Extensions.Configuration.IConfiguration> только конструкторы и <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> в `Startup`. Ограничения `HostBuilder` Di:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Аддаусоризатион перемещен в другую сборку

Методы ASP.NET Core 2,2 и Lower `AddAuthorization` в *Microsoft. AspNetCore. Authorization. dll*:

* Были переименованы `AddAuthorizationCore`.
* Были перемещены в *Microsoft. AspNetCore. Authorization. Policy. dll*.

Приложения, использующие *Microsoft. AspNetCore. Authorization. dll* и *Microsoft. AspNetCore. Authorization. Policy. dll* , не затрагиваются.

Приложения, которые не используют *Microsoft. AspNetCore. Authorization. Policy. dll* , должны выполнять одно из следующих действий:

* Переключиться на использование`AddAuthorizationCore`
* Добавьте ссылку на *Microsoft. AspNetCore. Authorization. Policy. dll*.

Дополнительные сведения см. [в разделе Перегрузка с `AddAuthorization(o =>`критическим изменением) находится в другой #386 сборки](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Код SignalR

Клиент SignalR JavaScript изменился с `@aspnet/signalr` на. `@microsoft/signalr` Чтобы реагировать на это изменение, измените ссылки в файлах *Package. JSON* , инструкции For и инструкции импорта ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON является протоколом по умолчанию

`System.Text.Json`теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices`вызовите `AddJsonProtocol` , чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Клиент:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft. JSON

Если вы используете функции `Newtonsoft.Json` , которые не поддерживаются в `System.Text.Json`, можно переключиться обратно на: `Newtonsoft.Json`

1. Установите пакет NuGet [Microsoft. AspNetCore. SignalR. Protocols. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. На клиенте привязать `AddNewtonsoftJsonProtocol` вызов метода `HubConnectionBuilder` к экземпляру:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. На сервере привязать `AddNewtonsoftJsonProtocol` вызов метода `AddSignalR` к вызову метода в `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

В 3,0 компиляция среды выполнения является сценарием согласия. Сведения о включении компиляции среды <xref:mvc/views/view-compilation#runtime-compilation>выполнения см. в разделе.

## <a name="migrating-libraries-via-multi-targeting"></a>Миграция библиотек через многоплатформенную нацеливание

Библиотекам часто требуется поддержка нескольких версий ASP.NET Core. Большинство библиотек, которые были скомпилированы в предыдущих версиях ASP.NET Core, должны продолжать работать без проблем. Для следующих условий требуется перекрестная компиляция приложения:

* Библиотека использует функцию с двоичным [критическим изменением](#breaking-api-changes).
* Библиотека хочет воспользоваться преимуществами новых функций в ASP.NET Core 3,0. 

Например:

```xml
<Project SDK="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Используйте `#ifdefs` для облегчения работы с интерфейсами API ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Прерывание изменений API

Дополнительные критические изменения в выпуске ASP.NET Core 3,0 см. в [репозитории ASPNET/Announcements](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0). Сводные сведения о критических изменениях 2,2-3,0 в .NET Core, ASP.NET Core и Entity Framework Core см. в разделе [критические изменения для миграции с версии 2,2 на 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 в настоящее время недоступна для службы приложений Azure. 

Мы надеемся, что эта возможность скоро станет доступна. Пока ASP.NET Core 3,0 не будет доступен в службе приложений Azure, следуйте инструкциям в статье [развертывание ASP.NET Core предварительной версии в службе приложений Azure](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
