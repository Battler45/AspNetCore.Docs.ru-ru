---
title: Миграция с ASP.NET Core 2,2 на 3,0 (Предварительная версия)
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 08/17/2019
uid: migration/22-to-30
ms.openlocfilehash: c70c167488b6a7ff3e1bbbc664b0df0dc13d9a74
ms.sourcegitcommit: 8835b6777682da6fb3becf9f9121c03f89dc7614
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69975465"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0.

## <a name="prerequisites"></a>Предварительные требования

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Обновление файла проекта

* Задайте `netcoreapp3.0`для [моникера целевой платформы (TFM)](/dotnet/standard/frameworks) значение:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Удалите все `<PackageReference>` в [Microsoft. AspNetCore. ALL](xref:fundamentals/metapackage) или [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) метапакет.

* Удалите все `<PackageReference>` из пакета [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Обновите `<PackageReference>` `Microsoft.AspNetCore.*` атрибут для оставшихся элементов для пакетов до текущей предварительной версии (например `3.0.0-preview5-19227-01`,). `Version`

  Если версия пакета 3,0 отсутствует, пакет может быть признан устаревшим в 3,0. Многие из этих пакетов являются частью, `Microsoft.AspNetCore.App` и на них не следует ссылаться по отдельности. Предварительный список пакетов, которые больше не создаются в 3,0, см. в разделе [прекращение создания пакетов для общих сборок платформы в 3,0 (#3756 ASPNET/AspNetCore)](https://github.com/aspnet/AspNetCore/issues/3756). *Общая платформа* — это набор сборок (*DLL* -файлов), которые установлены на компьютере `Microsoft.AspNetCore.App`и на которые ссылается. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Сборки для нескольких важных компонентов были удалены из `Microsoft.AspNetCore.App` в 3,0. Добавьте `<PackageReference>` элементы, если вы используете API из пакетов, перечисленных в [сборках, удаляемых из Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Ниже приведены примеры удаленных компонентов.

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  Список сборок, которые поставляются в `Microsoft.AspNetCore.App` , не был завершен и будет изменен до 3,0 RTM.

  Рассмотрим следующий код.

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Метод, вызываемый в приведенном выше коде, включается в `Microsoft.AspNet.WebApi.Client`. `ReadAsAsync` Установите пакет NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) , чтобы устранить проблему компиляции в 3,0.

* Добавьте [поддержку JSON.NET](#jsonnet-support).

* По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить `<AspNetCoreHostingModel>` свойство в файле проекта, если его значение равно. `InProcess`

## <a name="jsonnet-support"></a>Поддержка Json.NET

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

Чтобы использовать Json.NET в проекте ASP.NET Core 3,0, выполните следующие действия.

* Добавьте ссылку на пакет в [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Обновление `Startup.ConfigureServices` для вызова `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson`совместима с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Параметры Json.NET можно задать в вызове `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices`.

Доступны три новых метода расширения верхнего уровня `IServiceCollection` , относящихся к сценариям MVC. Шаблоны используют эти новые методы вместо `UseMvc`. Тем не `AddMvc` менее, будет работать так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor Pages и минимальной поддержки контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Обновить код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR`, перенесите приложение в маршрутизацию [конечной точки](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует от `Route`, в настоящее время можно избежать миграции. Предоставьте отзыв о [плане миграции реализаций на основе ираутер на маршрутизацию конечных точек](https://github.com/aspnet/AspNetCore/issues/4221).

* Если приложение напрямую обращается к `RouteData.Routers` MVC, вам может потребоваться избежать миграции в это время. Оставьте отзыв о [руководстве по миграции для использования RouteData. routers](https://github.com/aspnet/AspNetCore/issues/9148).

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания `IRouter`шаблона маршрута, что и. Маршрутизация конечных точек поддерживает `IRouteContraint`. Маршрутизация конечных `[HttpGet]`точек поддерживает `[Route]`, и другие атрибуты маршрутизации MVC.

Для большинства приложений требуются только `Startup` изменения.

### <a name="migrate-startupconfigure"></a>Миграция запуска. Настройка

Общие рекомендации:

* Добавить `UseRouting`. 
* `UseStaticFiles`Если приложение вызывает, `UseStaticFiles` поместите **перед** `UseRouting`ним.
* Если приложение использует функции проверки подлинности и авторизации `AuthorizePage` , `[Authorize]`такие как или, поместите `UseAuthentication` вызов `UseAuthorization` в и **после** `UseRouting` (и **после** `UseCors` использования по промежуточного слоя CORS).
* Замените `UseMvc` или `UseSignalR` на .`UseEndpoints`
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]`, `UseAuthentication` `UseCors` поместите вызов до любого другого по промежуточного слоя, использующего CORS (например, поместите `UseCors` перед, `UseAuthorization`и `UseMvc`).
* Замените `IHostingEnvironment` на `IWebHostEnvironment` и добавьте`using`оператор для пространстваимен.`Microsoft.Extensions.Hosting`

Ниже приведен пример `Startup.Configure` типичного приложения ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего `Startup.Configure` кода выполните следующие действия.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors`можно указать с политикой по умолчанию, а `[EnableCors]` атрибуты `[DisableCors]` и можно использовать для переопределения политики по умолчанию, если это необходимо. 

В следующем примере:

* CORS включена для всех конечных точек с `default` именованной политикой.
* Класс отключает CORS `[DisableCors]` с помощью атрибута. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с `[Authorize]` помощью атрибута. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется поместить ASP.NET Core по промежуточного слоя авторизации`UseAuthorization`() сразу `UseAuthentication`после. По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure`, а `HomeController` для следующего требуется пользователь, выполнивший вход:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Если приложение использует `AuthorizeFilter` в качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику `UseAuthorization` по промежуточного слоя.

В следующем примере пользовательская политика применяется ко всем запросам, когда `UseAuthorization` вызывается, `HomeController` и разрешает доступ без входа пользователя в приложение:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

В следующем примере `UseAuthorization` обрабатывается авторизация без политики по умолчанию, `/healthz` но конечная точка проверки работоспособности требует, чтобы `admin` пользователь был в роли: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. `UseEndpoint`по промежуточного слоя создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

### <a name="migrate-signalr"></a>Перенесите SignalR

Сопоставление концентраторов SignalR теперь выполняется внутри `UseEndpoints`. 

Сопоставьте каждый концентратор с `MapHub`. Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере добавляется поддержка `ChatHub` концентратора SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Миграция контроллеров MVC

Теперь сопоставление контроллеров выполняется внутри `UseEndpoints`. 

Добавить `MapControllers` , если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием. 

Замените следующее:

* `MapRoute`учет`MapControllerRoute`
* `MapAreaRoute`учет`MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие `MapControllerRoute` как / `MapAreaControllerRoute` ,применяютсявпорядкеихдобавления/. `MapDefaultControllerRoute` Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers`добавляет поддержку контроллеров с маршрутизацией на основе атрибутов.
* `MapAreaControllerRoute`добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute`добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Миграция Razor Pages

Сопоставление Razor Pages теперь выполняется внутри `UseEndpoints`.

Добавьте `MapRazorPages` , если приложение использует Razor Pages. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor Pages теперь является явной.

В следующем примере `MapRazorPages` добавляется поддержка для Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC `UseMvc` с помощью `UseMvcWithDefaultRoute` или в ASP.NET Core 3,0 требует явного согласия внутри. `Startup.ConfigureServices` Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если приложению требуется поддержка прежних версий `IRouter` , отключите `EnableEndpointRouting` их с помощью любого из следующих `Startup.ConfigureServices`подходов в:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Миграция проверок работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks` , чтобы использовать проверки работоспособности с маршрутизацией конечных точек. Метод принимает аргументы, `UseHealthChecks`аналогичные. `MapHealthChecks` Преимущество использования функции `MapHealthChecks` over `UseHealthChecks` заключается в возможности применения авторизации и более точного контроля над политикой сопоставления. 

В следующем примере `MapHealthChecks` метод вызывается для `/healthz`конечной точки проверки работоспособности:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан класс ASP.NET Core 3,0, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный `Program` шаблоном:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>остается в 3,0 и является типом, `webBuilder` отображаемым в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>будет считаться устаревшим в будущих выпусках и `HostBuilder`заменено на.

Наиболее существенным изменением `WebHostBuilder` `HostBuilder` в является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder`можно внедрять <xref:Microsoft.Extensions.Configuration.IConfiguration> только конструкторы и <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> в `Startup`. Ограничения `HostBuilder` Di:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

## <a name="update-signalr-code"></a>Обновить код SignalR

`System.Text.Json`теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices`вызовите `AddJsonProtocol` , чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Клиент:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft. JSON

Если вы используете функции `Newtonsoft.Json` , которые не поддерживаются в `System.Text.Json`, можно переключиться обратно на: `Newtonsoft.Json`

1. Установите пакет NuGet [Microsoft. AspNetCore. SignalR. Protocols. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. На клиенте привязать `AddNewtonsoftJsonProtocol` вызов метода `HubConnectionBuilder` к экземпляру:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. На сервере привязать `AddNewtonsoftJsonProtocol` вызов метода `AddSignalR` к вызову метода в `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

В 3,0 компиляция среды выполнения является сценарием согласия. Сведения о включении компиляции среды https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation выполнения см. в разделе.
