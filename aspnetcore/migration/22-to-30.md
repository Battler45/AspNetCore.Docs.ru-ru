---
title: Миграция с ASP.NET Core 2,2 на 3,0
author: rick-anderson
description: Узнайте, как перенести проект ASP.NET Core 2,2 в ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 01/13/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 346e276fba53c895e7f76bcd865b09e0e0cabfae
ms.sourcegitcommit: f259889044d1fc0f0c7e3882df0008157ced4915
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/18/2020
ms.locfileid: "76268738"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Миграция с ASP.NET Core 2,2 на 3,0

[Скотт Эдди (](https://github.com/scottaddie) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этой статье объясняется, как обновить существующий проект ASP.NET Core 2,2 до ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisites

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code.](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Обновление версии пакета SDK для .NET Core в файле global.json

Если решение использует файл [Global. JSON](/dotnet/core/tools/global-json) , предназначенный для конкретной версии пакет SDK для .NET Core, обновите его свойство `version` до версии 3,0, установленной на компьютере.

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Обновление файла проекта

### <a name="update-the-target-framework"></a>Обновление целевой платформы

ASP.NET Core 3,0 и более поздних версий работают только в .NET Core. Задайте для параметра [моникер целевой платформы (TFM)](/dotnet/standard/frameworks) значение `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Удалить устаревшие ссылки на пакеты

Для ASP.NET Core 3,0 не создается большое количество пакетов NuGet. Такие ссылки на пакеты должны быть удалены из файла проекта. Рассмотрим следующий файл проекта для веб-приложения ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Обновленный файл проекта для ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Обновленный файл проекта ASP.NET Core 3,0:

* На портале `<PropertyGroup>`:
  * Обновляет TFM до `netcoreapp3.0`
  * Удаляет элемент `<AspNetCoreHostingModel>`. Дополнительные сведения см. [в разделе внутрипроцессного размещения модели](#in-process-hosting-model) в этом документе.

* На портале `<ItemGroup>`:
  * `Microsoft.AspNetCore.App` удаляется. Дополнительные сведения см. в [справочнике по платформе](#framework-reference) в этом документе.
  * `Microsoft.AspNetCore.Razor.Design` удаляется, и в следующем списке пакетов больше не создается.

Чтобы просмотреть полный список пакетов, которые больше не создаются, выберите следующий список развертывания:

<details>
    <summary>Щелкните, чтобы развернуть список пакетов, которые больше не создаются</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Центральный</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Проверка критических изменений

[Проверка критических изменений](#break)

### <a name="framework-reference"></a>Справочник по платформе

Функции ASP.NET Core, которые были доступны в одном из перечисленных выше пакетов, доступны в составе `Microsoft.AspNetCore.App` общей платформы. *Общая платформа* — это набор сборок (*DLL*-файлы), которые установлены на компьютере, содержащий компонент среды выполнения и целевой пакет. Дополнительную информацию см. в этой публикации об [общей платформе](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Проекты, предназначенные для пакета SDK `Microsoft.NET.Sdk.Web`, неявно ссылаются на платформу `Microsoft.AspNetCore.App`.

  Для этих проектов не требуются дополнительные ссылки:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* В проектах, предназначенных для `Microsoft.NET.Sdk` или `Microsoft.NET.Sdk.Razor` SDK, следует добавить явную `FrameworkReference` в `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Сборки, зависящие от платформы, с помощью DOCKER

Зависящие от платформы сборки консольных приложений, использующих пакет, который зависит от ASP.NET Core [общей платформы](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , может предоставить следующую ошибку времени выполнения:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` — это общая платформа, содержащая среду выполнения ASP.NET Core, и она доступна только в образе DOCKER [/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . Пакет SDK 3,0 уменьшает размер сборок, зависящих от платформы, с помощью ASP.NET Core, не включая дублированные копии библиотек, доступных в общей платформе. Это может привести к экономии до 18 МБ, но для запуска приложения необходимо, чтобы среда выполнения ASP.NET Core присутствовала или была установлена.

Чтобы определить, имеет ли приложение зависимость (прямую или косвенную) на ASP.NET Core общей платформе, изучите файл *runtimeconfig. JSON* , созданный во время сборки или публикации приложения. В следующем JSON-файле показана зависимость от ASP.NET Core общей платформы:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Если приложение использует DOCKER, используйте базовый образ, включающий ASP.NET Core 3,0. Например, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Добавление ссылок на пакеты для удаленных сборок

ASP.NET Core 3,0 удаляет некоторые сборки, которые ранее были частью ссылки на пакет `Microsoft.AspNetCore.App`. Чтобы визуализировать, какие сборки были удалены, Сравните две папки общей платформы. Например, Сравнение версий 2.2.7 и 3.0.0:

![Сравнение сборок общей платформы](22-to-30/_static/assembly-diff.png)

Чтобы продолжить использование функций, предоставляемых удаленными сборками, сослаться на версии 3,0 соответствующих пакетов:

* Веб-приложение, созданное шаблоном с **отдельными учетными записями пользователей** , требует добавления следующих пакетов:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Дополнительные сведения об обращении к пакету для конкретного поставщика базы данных см. в разделе [поставщики баз данных](/ef/core/providers/index).

* Пользовательский интерфейс удостоверений

  Поддержку [пользовательского интерфейса идентификации](xref:security/authentication/identity) можно добавить, обратившись к пакету [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Службы SPA

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices);
  * [Microsoft. AspNetCore. Спасервицес. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Проверка подлинности &ndash; поддержка сторонних потоков аутентификации доступна в виде пакетов NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Проверка подлинности учетной записи Майкрософт ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Проверка подлинности OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Токен носителя OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Проверка подлинности WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Поддержка форматирования и согласования содержимого для `System.Net.HttpClient` &ndash; пакет NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) предоставляет полезную расширяемость для `System.Net.HttpClient` с помощью интерфейсов API, таких как `ReadAsAsync` и `PostJsonAsync`.

* Компиляция среды выполнения Razor &ndash; поддержка компиляции представлений и страниц Razor в среде выполнения теперь является частью [Microsoft. AspNetCore. MVC. Razor. рунтимекомпилатион](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Поддержка MVC `Newtonsoft.Json` (Json.NET) &ndash; поддержка использования MVC с `Newtonsoft.Json` теперь является частью [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Изменения при запуске

На следующем рисунке показаны удаленные и измененные строки в веб-приложении ASP.NET Core 2,2 Razor Pages.

![Удаленные и измененные строки в веб-приложении ASP.NET Core 2,2 Razor](22-to-30/_static/startup2.2.png)

На предыдущем рисунке удаленный код показан красным цветом. Удаленный код не отображает код параметров файла cookie, который был удален до сравнения файлов.

На следующем рисунке показаны добавленные и измененные строки в веб-приложении ASP.NET Core 3,0 Razor Pages.

![добавленные и измененные строки в веб-приложении ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

На предыдущем рисунке добавлен код, показанный зеленым цветом. Сведения о следующих изменениях:

* `services.AddMvc` `services.AddRazorPages`см. в разделе [Регистрация службы MVC](#mvc-service-registration) в этом документе.
* `CompatibilityVersion`см. в разделе <xref:mvc/compatibility-version>.
* `IHostingEnvironment` `IWebHostEnvironment`см. в [этом объявлении GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` был добавлен в шаблоны для отображения промежуточного слоя авторизации заказа, необходимо добавить. Если приложение не использует авторизацию, можно безопасно удалить вызов `app.UseAuthorization`.
* `app.UseEndpoints`см. в разделе [Razor Pages](#razor-pages) или [Миграция запуска. Настройка](#migrate-startupconfigure) в этом документе.

### <a name="analyzer-support"></a>Поддержка анализатора

Проекты, предназначенные для `Microsoft.NET.Sdk.Web` неявными ссылками на анализаторы, которые ранее поставлялись в составе пакета [Microsoft. AspNetCore. MVC. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Для включения этих дополнительных ссылок не требуется.

Если приложение использует [анализаторы API](xref:web-api/advanced/analyzers) , которые ранее поставлялись с пакетом [Microsoft. AspNetCore. MVC. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , измените файл проекта, чтобы он ссылался на анализаторы, поставляемые в составе веб-пакета SDK .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Библиотека классов Razor

Проекты библиотеки классов Razor, предоставляющие компоненты пользовательского интерфейса для MVC, должны задавать свойство `AddRazorSupportForMvc` в файле проекта:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Модель внутрипроцессного размещения

По умолчанию в проектах используется [модель внутрипроцессного размещения](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) в ASP.NET Core 3,0 или более поздней версии. При необходимости вы можете удалить свойство `<AspNetCoreHostingModel>` в файле проекта, если его значение равно `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Конфигурация

Миграция конфигурации Kestrel в построитель веб-узлов, предоставляемый `ConfigureWebHostDefaults` (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Если приложение создает узел вручную с `HostBuilder`, вызовите `UseKestrel` в построителе веб-узлов в `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>По промежуточного слоя соединения заменяет Адаптеры подключений

Адаптеры подключений (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) были удалены из Kestrel. Замените адаптеры подключений по промежуточного слоя соединения. По промежуточного слоя соединения аналогично по промежуточного слоя HTTP в ASP.NET Core конвейере, но для соединений более низкого уровня. Протокол HTTPS и регистрация подключения:

* Были перемещены из адаптеров соединений в по промежуточного слоя соединения.
* Эти методы расширения работают как в предыдущих версиях ASP.NET Core. 

Дополнительные сведения см. в [примере тлсфилтерконнектионхандлер в разделе листеноптионс. Protocols статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Абстракции транспорта перемещены и сделаны открытыми

Транспортный уровень Kestrel предоставляется как открытый интерфейс в `Connections.Abstractions`. В состав этих обновлений:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` и связанные типы были удалены.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> был перемещен из <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> в параметры транспорта.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` был удален из <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Дополнительные сведения см. в следующих ресурсах GitHub:

* [Абстракции сети "клиент-сервер" (#10308 DotNet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Реализуйте новую абстракцию прослушивателя основой и Plat Kestrel сверху (DotNet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Заголовков анонса запроса Kestrel

Для приложений, предназначенных для более ранних версий ASP.NET Core:

* Kestrel добавляет заголовки поблочного трейлера HTTP/1.1 в коллекцию заголовков запросов.
* Трейлеры доступны после считывания текста запроса в конец.

Это вызывает некоторые проблемы, связанные с неоднозначностью заголовков и трейлеров, поэтому эти трейлеры были перемещены в новую коллекцию (`RequestTrailerExtensions`) в 3,0.

Запросы HTTP/2:

* Недоступно в ASP.NET Core 2,2.
* Доступно в 3,0 как `RequestTrailerExtensions`.

Для доступа к этим трейлерам имеются новые методы расширения запроса. Как и в случае с HTTP/1.1, трейлеры доступны после считывания текста запроса в конец.

Для выпуска 3,0 доступны следующие методы `RequestTrailerExtensions`.

* `GetDeclaredTrailers` &ndash; получает заголовок запроса `Trailer`, в котором указывается, какие трейлеры должны рассчитываться после текста.
* `SupportsTrailers` &ndash; указывает, поддерживает ли запрос получение заголовков трейлеров.
* `CheckTrailersAvailable` &ndash; проверяет, поддерживает ли запрос трейлеры и доступны ли они для чтения. Эта проверка не предполагает наличие трейлеров для чтения. Возможно, не существует трейлеров для чтения, даже если этот метод возвращает `true`.
* `GetTrailer` &ndash; получает запрошенный конечный заголовок из ответа. Проверьте `SupportsTrailers` перед вызовом `GetTrailer`или может возникнуть <xref:System.NotSupportedException>, если запрос не поддерживает конечные заголовки.

Дополнительные сведения см. [в разделе помещение запроса на постановку в отдельную коллекцию (DotNet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Алловсинчронаусио отключена

`AllowSynchronousIO` включает или отключает синхронные API-интерфейсы ввода-вывода, такие как `HttpRequest.Body.Read`, `HttpResponse.Body.Write`и `Stream.Flush`. Эти API-интерфейсы являются источником нехватка потоков, ведущих к сбоям приложений. В 3.0 `AllowSynchronousIO` отключен по умолчанию. Дополнительные сведения см. в [разделе синхронный ввод-вывод статьи Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Если требуется синхронный ввод-вывод, его можно включить, настроив параметр `AllowSynchronousIO` на используемом сервере (при вызове `ConfigureKestrel`, например при использовании Kestrel). Обратите внимание, что у серверов (Kestrel, HttpSys, TestServer и т. д.) есть собственный параметр `AllowSynchronousIO`, который не влияет на другие серверы. Синхронный ввод-вывод можно включить для всех серверов на основе каждого запроса с помощью параметра `IHttpBodyControlFeature.AllowSynchronousIO`:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

При возникновении проблем с реализациями <xref:System.IO.TextWriter> или другими потоками, которые вызывают синхронные API-интерфейсы в [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), вызывайте новый <xref:System.IO.Stream.DisposeAsync*> API.

Дополнительные сведения см. [в разделе [объявление] алловсинчронаусио Disabled On All Servers (DotNet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Удалена сборка Microsoft. AspNetCore. Server. Kestrel. HTTPS

В ASP.NET Core 2,1 содержимое *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* было перемещено в файл *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Это не критическое обновление с использованием `TypeForwardedTo` атрибутов. Для 3,0 пустая сборка *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* и пакет NuGet удалены.

Библиотеки, ссылающиеся на [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) , должны обновлять зависимости ASP.NET Core до 2,1 или более поздней версии.

Приложения и библиотеки, предназначенные для ASP.NET Core 2,1 или более поздней версии, должны удалять все прямые ссылки на пакет [Microsoft. AspNetCore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Поддержка Newtonsoft. JSON (Json.NET)

В рамках работы по [улучшению ASP.NET Core общей платформы](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [Newtonsoft. JSON (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) был удален из ASP.NET Core общей платформы.

Сериализатор JSON по умолчанию для ASP.NET Core теперь <xref:System.Text.Json>, что является новым в .NET Core 3,0. По возможности рекомендуется использовать `System.Text.Json`. Это высокопроизводительное и не требует дополнительной зависимости библиотеки. Однако поскольку `System.Text.Json` является новым, в настоящее время могут отсутствовать функции, необходимые приложению. Дополнительные сведения см. в статье [Миграция из Newtonsoft. JSON в System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Использование Newtonsoft. JSON в проекте ASP.NET Core 3,0 SignalR

* Установите [Microsoft.AspNetCore.SignalR.Пакет NuGet protocols. Невтонсофтжсон](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* На клиенте привязать вызов метода `AddNewtonsoftJsonProtocol` к экземпляру `HubConnectionBuilder`:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* На сервере привязать вызов метода `AddNewtonsoftJsonProtocol` к вызову метода `AddSignalR` в `Startup.ConfigureServices`:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Использование Newtonsoft. JSON в проекте MVC ASP.NET Core 3,0

* Установите пакет [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Обновите `Startup.ConfigureServices`, чтобы вызвать `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` совместима с новыми методами регистрации службы MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Параметры `Newtonsoft.Json` можно задать в вызове `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Примечание.** Если метод `AddNewtonsoftJson` недоступен, убедитесь, что установлен пакет [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Распространенной ошибкой является установка пакета [Newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) вместо пакета [Microsoft. AspNetCore. MVC. невтонсофтжсон](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="mvc-service-registration"></a>Регистрация службы MVC

ASP.NET Core 3,0 добавляет новые параметры для регистрации сценариев MVC в `Startup.ConfigureServices`.

Доступны три новых метода расширения верхнего уровня, связанные с сценариями MVC на `IServiceCollection`. Шаблоны используют эти новые методы вместо `AddMvc`. Однако `AddMvc` продолжит вести себя так же, как в предыдущих выпусках.

В следующем примере добавлена поддержка контроллеров и функций, связанных с API, но не представлений и страниц. Шаблон API использует следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

В следующем примере добавлена поддержка контроллеров, функций, связанных с API, и представлений, но не страниц. В шаблоне веб-приложения (MVC) используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

В следующем примере добавлена поддержка Razor Pages и минимальной поддержки контроллера. В шаблоне веб-приложения используется следующий код:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Новые методы также можно сочетать. Следующий пример эквивалентен вызову `AddMvc` в ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Код запуска маршрутизации

Если приложение вызывает `UseMvc` или `UseSignalR`, перенесите приложение в [службу маршрутизации конечных точек](xref:fundamentals/routing) , если это возможно. Чтобы улучшить совместимость маршрутизации конечных точек с предыдущими версиями MVC, мы отправили некоторые изменения в формировании URL-адресов, появившиеся в ASP.NET Core 2,2. Если у вас возникли проблемы с маршрутизацией конечных точек в 2,2, предполагаю, что улучшения ASP.NET Core 3,0, за исключением следующих:

* Если приложение реализует `IRouter` или наследует от `Route`, используйте [динамикраутевалуестрансформер](https://github.com/dotnet/AspNetCore.Docs/issues/12997) в качестве замены.

* Если приложение напрямую обращается `RouteData.Routers` в MVC для анализа URL-адресов, его можно заменить на использование `LinkParser.ParsePathByEndpointName`. 
 * Определите маршрут с именем маршрута.
 * Используйте `LinkParser.ParsePathByEndpointName` и передайте нужное имя маршрута.

Маршрутизация конечных точек поддерживает тот же синтаксис шаблона маршрута и функции создания шаблона маршрута, что и `IRouter`. Маршрутизация конечных точек поддерживает `IRouteConstraint`. Маршрутизация конечных точек поддерживает `[Route]`, `[HttpGet]`и другие атрибуты маршрутизации MVC.

Для большинства приложений только `Startup` требует внесения изменений.

### <a name="migrate-startupconfigure"></a>Миграция запуска. Настройка

Общие рекомендации:

* Добавьте `UseRouting`.
* Если приложение вызывает `UseStaticFiles`, разместите `UseStaticFiles` **перед** `UseRouting`.
* Если приложение использует функции проверки подлинности и авторизации, такие как `AuthorizePage` или `[Authorize]`, поместите вызов в `UseAuthentication` и `UseAuthorization`: **After**, `UseRouting` и `UseCors`, но до `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Замените `UseMvc` или `UseSignalR` `UseEndpoints`.
* Если приложение использует сценарии [CORS](xref:security/cors) , например `[EnableCors]`, поместите вызов `UseCors` перед любым другим по промежуточного слоя, использующим CORS (например `UseCors`, перед `UseAuthentication`, `UseAuthorization`и `UseEndpoints`).
* Замените `IHostingEnvironment` `IWebHostEnvironment` и добавьте оператор `using` для пространства имен <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Замените `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (пространство имен<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Замените `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> (пространство имен<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Следующий код является примером `Startup.Configure` в типичном приложении ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

После обновления предыдущего `Startup.Configure` кода:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Для большинства приложений вызовы `UseAuthentication`, `UseAuthorization`и `UseCors` должны находиться между вызовами `UseRouting` и `UseEndpoints`, чтобы быть эффективным.

### <a name="health-checks"></a>Проверки работоспособности

Для проверок работоспособности используется маршрутизация конечных точек с универсальным узлом. В `Startup.Configure` вызовите `MapHealthChecks` для построителя конечной точки с URL-адресом конечной точки или относительным путем:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Конечные точки проверки работоспособности могут:

* указать один или несколько разрешенных узлов или портов;
* требовать авторизацию;
* требовать CORS.

Для получения дополнительной информации см. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Руководство по по промежуточного слоя безопасности

Поддержка авторизации и CORS унифицирована на основе подхода по [промежуточного слоя](xref:fundamentals/middleware/index) . Это позволяет использовать одно и то же по промежуточного слоя и функциональные возможности в этих сценариях. В этом выпуске реализовано обновленное по по промежуточного слоя авторизации, а по промежуточного слоя CORS улучшено, чтобы он мог понять, какие атрибуты используются контроллерами MVC.

#### <a name="cors"></a>CORS

Ранее CORS было сложно настроить. По промежуточного слоя было предоставлено для использования в некоторых случаях, но фильтры MVC предназначены для использования **без** по промежуточного слоя в других вариантах использования. В ASP.NET Core 3,0 рекомендуется, чтобы все приложения, требующие CORS, использовали по промежуточного слоя CORS в сочетании с маршрутизацией конечных точек. `UseCors` может быть предоставлена с политикой по умолчанию, а атрибуты `[EnableCors]` и `[DisableCors]` можно использовать для переопределения политики по умолчанию, если это необходимо.

В следующем примере:

* CORS включается для всех конечных точек с `default` именованной политикой.
* Класс `MyController` отключает CORS с помощью атрибута `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Авторизация

В более ранних версиях ASP.NET Core Поддержка авторизации была предоставлена с помощью атрибута `[Authorize]`. По промежуточного слоя авторизации недоступно. В ASP.NET Core 3,0 требуется по промежуточного слоя авторизации. Рекомендуется размещать ASP.NET Core по промежуточного слоя авторизации (`UseAuthorization`) сразу после `UseAuthentication`. По промежуточного слоя авторизации также можно настроить политику по умолчанию, которую можно переопределить.

В ASP.NET Core 3,0 или более поздней версии `UseAuthorization` вызывается в `Startup.Configure`, а для следующих `HomeController` требуется вход пользователя.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

При использовании маршрутизации конечных точек рекомендуется настроить `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` и, вместо этого, полагаться на по промежуточного слоя авторизации.  Если приложение использует `AuthorizeFilter` в качестве глобального фильтра в MVC, рекомендуется выполнить рефакторинг кода, чтобы предоставить политику в вызове `AddAuthorization`.

Изначально `DefaultPolicy` настроена для обязательной проверки подлинности, поэтому дополнительная настройка не требуется. В следующем примере конечные точки MVC помечаются как `RequireAuthorization`, поэтому все запросы должны быть разрешены на основе `DefaultPolicy`. Однако `HomeController` предоставляет доступ без входа пользователя в приложение из-за `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Авторизация для конкретных конечных точек

Авторизацию также можно настроить для конкретных классов конечных точек. Следующий код представляет собой пример преобразования приложения MVC, которое настроило глобальное `AuthorizeFilter` приложению, с определенной политикой, которая требует авторизации:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Политики также можно настроить. `DefaultPolicy` настроена для обязательной проверки подлинности:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Кроме того, для всех конечных точек можно настроить требование авторизации без `[Authorize]` или `RequireAuthorization`, настроив `FallbackPolicy`. `FallbackPolicy` отличается от `DefaultPolicy`. `DefaultPolicy` активируется `[Authorize]` или `RequireAuthorization`, а `FallbackPolicy` активируется, если не задана другая политика. `FallbackPolicy` изначально настроена для разрешения запросов без авторизации.

Следующий пример аналогичен приведенному выше `DefaultPolicy` примере, но использует `FallbackPolicy`, чтобы всегда требовать проверку подлинности для всех конечных точек, за исключением случаев, когда `[AllowAnonymous]` указана:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Авторизация по промежуточного слоя работает без каких бы то ни было конкретных знаний авторизации. Например, [проверки работоспособности](xref:host-and-deploy/health-checks) не имеют определенных знаний авторизации, но проверки работоспособности могут иметь настраиваемую политику авторизации по промежуточного слоя.

Кроме того, каждая конечная точка может настраивать свои требования к авторизации. В следующем примере `UseAuthorization` обрабатывает авторизацию с `DefaultPolicy`, но `/healthz` конечной точке проверки работоспособности требуется `admin` пользователя:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Защита реализована в некоторых сценариях. По промежуточного слоя конечных точек создает исключение, если политика авторизации или CORS пропускается из-за отсутствия по промежуточного слоя. Поддержка анализатора для предоставления дополнительных отзывов о ненастроенном состоянии.

#### <a name="custom-authorization-handlers"></a>Пользовательские обработчики авторизации

Если приложение использует пользовательские [обработчики авторизации](xref:security/authorization/policies#authorization-handlers), то маршрутизация конечных точек передает обработчикам различные типы ресурсов, чем MVC. Обработчики, которые предполагают, что ресурс контекста обработчика авторизации имеет тип <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (тип ресурса, [предоставляемый фильтрами MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)), необходимо обновить для обработки ресурсов типа <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (тип ресурса, предоставленный для обработчиков авторизации по маршрутизации конечной точки).

MVC по-прежнему использует ресурсы `AuthorizationFilterContext`, поэтому, если приложение использует фильтры авторизации MVC вместе с авторизацией маршрутизации конечных точек, может потребоваться обрабатывать оба типа ресурсов.

### SignalR

Сопоставление концентраторов SignalR теперь выполняется в `UseEndpoints`.

Сопоставьте каждый концентратор с `MapHub`. Как и в предыдущих версиях, каждый концентратор явно указан.

В следующем примере добавляется поддержка центра SignalR `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Существует новый параметр управления ограничениями на размер сообщений от клиентов. Например, для `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

В ASP.NET Core 2,2 можно задать `TransportMaxBufferSize` и эффективно управлять максимальным размером сообщения. В ASP.NET Core 3,0 этот параметр теперь позволяет управлять только максимальным размером до подавления нехватки.

### <a name="mvc-controllers"></a>Контроллеры MVC

Теперь сопоставление контроллеров выполняется в `UseEndpoints`.

Добавьте `MapControllers`, если приложение использует маршрутизацию атрибутов. Так как маршрутизация включает поддержку многих платформ в ASP.NET Core 3,0 или более поздней версии, Добавление контроллеров с маршрутизацией с атрибутами является явным согласием.

Замените следующие значения:

* `MapRoute` с `MapControllerRoute`
* `MapAreaRoute` с `MapAreaControllerRoute`

Так как маршрутизация теперь включает поддержку не только для MVC, терминология была изменена, чтобы эти методы были четко изменяли то, что они делают. Стандартные маршруты, такие как `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute`, применяются в порядке их добавления. Сначала разместите более конкретные маршруты (например, маршруты для области).

В следующем примере:

* `MapControllers` добавлена поддержка контроллеров с маршрутизацией с атрибутами.
* `MapAreaControllerRoute` добавляет стандартный маршрут для контроллеров в области.
* `MapControllerRoute` добавляет стандартный маршрут для контроллеров.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Удаление асинхронного суффикса из имен действий контроллера

В ASP.NET Core 3,0 ASP.NET Core MVC удаляет суффикс `Async` из имен действий контроллера. Это новое значение по умолчанию затрагивает маршрутизацию и создание ссылок. Например:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

До ASP.NET Core 3,0:

* Предыдущее действие можно было получить в маршруте *Products/ListAsync* .
* Требуется создание ссылки с указанием суффикса `Async`. Например:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

В ASP.NET Core 3,0:

* Предыдущее действие можно получить с помощью маршрута *Products/List* .
* Для создания канала не требуется указывать суффикс `Async`. Например:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Это изменение не влияет на имена, указанные с помощью атрибута [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Поведение по умолчанию можно отключить с помощью следующего кода в `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Изменения в поколении ссылок

Как описано в документации по [различиям между предыдущими версиями маршрутизации](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), существуют некоторые различия в создании ссылок (например, с помощью `Url.Link` и аналогичных интерфейсов API). Сюда входит следующее.

* По умолчанию при использовании маршрутизации конечных точек регистр параметров маршрута в созданных URI не обязательно сохраняется. Это поведение можно контролировать с помощью интерфейса `IOutboundParameterTransformer`.
* Создание URI для недопустимого маршрута (несуществующий контроллер, действие или страница) создаст пустую строку в разделе "Маршрутизация конечных точек" вместо создания недопустимого URI.
* Значения окружения (параметры маршрута из текущего контекста) не используются автоматически в создании ссылок с маршрутизацией конечных точек. Ранее при создании ссылки на другое действие (или страницу) неопределенные значения маршрута выводятся из значений окружающей среды *текущих* маршрутов. При использовании маршрутизации конечных точек все параметры маршрута должны быть заданы явным образом во время создания ссылки.

### <a name="razor-pages"></a>Razor Pages

Сопоставление Razor Pages теперь выполняется в `UseEndpoints`.

Добавьте `MapRazorPages`, если приложение использует Razor Pages. Так как маршрутизация конечных точек включает поддержку многих платформ, добавление Razor Pages теперь является явной.

В следующем методе `Startup.Configure` `MapRazorPages` добавляет поддержку Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Использовать MVC без маршрутизации конечных точек

Использование MVC с помощью `UseMvc` или `UseMvcWithDefaultRoute` в ASP.NET Core 3,0 требует явного согласия внутри `Startup.ConfigureServices`. Это необходимо, так как MVC должен определить, может ли он полагаться на по промежуточного слоя авторизации и CORS во время инициализации. Предоставляется анализатор, предупреждающий, попытается ли приложение использовать неподдерживаемую конфигурацию.

Если приложению требуется поддержка устаревших `IRouter`, отключите `EnableEndpointRouting` одним из следующих подходов в `Startup.ConfigureServices`.

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Проверки работоспособности

Проверки работоспособности можно использовать в качестве *маршрутизатора — вредоносные программы* с маршрутизацией конечных точек.

Добавьте `MapHealthChecks` для использования проверок работоспособности с маршрутизацией конечных точек. Метод `MapHealthChecks` принимает аргументы, аналогичные `UseHealthChecks`. Преимуществом использования `MapHealthChecks` для `UseHealthChecks` является возможность применения авторизации и более точного контроля над политикой сопоставления.

В следующем примере `MapHealthChecks` вызывается для конечной точки проверки работоспособности на `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Хостбуилдер заменяет WebHostBuilder

Шаблоны ASP.NET Core 3,0 используют [универсальный узел](xref:fundamentals/host/generic-host). В предыдущих версиях использовался [веб-узел](xref:fundamentals/host/web-host). В следующем коде показан шаблон ASP.NET Core 3,0, созданный `Program` класса:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

В следующем коде показан класс ASP.NET Core 2,2, созданный шаблоном `Program`:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> остается в 3,0 и является типом `webBuilder`, который рассматривается в предыдущем примере кода. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> будет считаться устаревшим в будущем выпуске и заменено `HostBuilder`.

Наиболее существенным изменением с `WebHostBuilder` на `HostBuilder` является [внедрение зависимостей (DI)](xref:fundamentals/dependency-injection). При использовании `HostBuilder`в конструктор `Startup`можно ввести только следующее:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Ограничения `HostBuilder` DI:

* Включите построение контейнера DI только один раз.
* Позволяет избежать итоговых проблем со временем существования объектов, таких как разрешение нескольких экземпляров Singleton.

Дополнительные сведения см. [в разделе Предотвращение введения в службу запуска в ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Аддаусоризатион перемещен в другую сборку

Методы ASP.NET Core 2,2 и Lower `AddAuthorization` в *Microsoft. AspNetCore. Authorization. dll*:

* Были переименованы `AddAuthorizationCore`.
* Были перемещены в *Microsoft. AspNetCore. Authorization. Policy. dll*.

Приложения, использующие *Microsoft. AspNetCore. Authorization. dll* и *Microsoft. AspNetCore. Authorization. Policy. dll* , не затрагиваются.

Приложения, которые не используют *Microsoft. AspNetCore. Authorization. Policy. dll* , должны выполнять одно из следующих действий:

* Добавьте ссылку на *Microsoft. AspNetCore. Authorization. Policy. dll*. Этот подход работает для большинства приложений и является обязательным.
* Переключиться на использование `AddAuthorizationCore`

Дополнительные сведения см. [в разделе критическое изменение перегрузки `AddAuthorization(o =>`) находится в другой #386 сборки](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Пользовательский интерфейс удостоверений

Обновления пользовательского интерфейса удостоверений для ASP.NET Core 3,0:

* Добавьте ссылку на пакет в [Microsoft. AspNetCore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Приложения, которые не используют Razor Pages, должны вызывать `MapRazorPages`. См. [Razor Pages](#razor-pages) в этом документе.
* Начальная загрузка 4 является инфраструктурой пользовательского интерфейса по умолчанию. Задайте свойство проекта `IdentityUIFrameworkVersion`, чтобы изменить значение по умолчанию. Дополнительные сведения см. в [этом объявлении GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

SignalR клиент JavaScript изменился с `@aspnet/signalr` на `@microsoft/signalr`. Чтобы реагировать на это изменение, измените ссылки в файлах *Package. JSON* , `require` операторах и ECMAScript `import` инструкции.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON является протоколом по умолчанию

`System.Text.Json` теперь является протоколом концентратора по умолчанию, используемым как клиентом, так и сервером.

В `Startup.ConfigureServices`вызовите `AddJsonProtocol`, чтобы задать параметры сериализатора.

**Сервером**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Клиент:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Переключиться на Newtonsoft. JSON

Если вы используете [функции Newtonsoft. JSON, которые не поддерживаются в System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), можно переключиться обратно на `Newtonsoft.Json`. См. раздел [Использование Newtonsoft. JSON в проекте ASP.NET Core 3,0 SignalR](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) ранее в этой статье.

## <a name="opt-in-to-runtime-compilation"></a>Согласие на компиляцию среды выполнения

До ASP.NET Core 3,0, компиляция представлений во время выполнения была неявной функцией платформы. Компиляция среды выполнения дополняет компиляцию представлений во время сборки. Она позволяет платформе компилировать представления Razor и страницы (*CSHTML* -файлы) при изменении файлов без необходимости перестроения всего приложения. Эта функция поддерживает сценарий выполнения быстрого редактирования в интегрированной среде разработки и обновления браузера для просмотра изменений.

В ASP.NET Core 3,0 компиляция среды выполнения является сценарием согласия. Компиляция во время сборки — единственный механизм для просмотра компиляции, включенный по умолчанию. Среда выполнения полагается на Visual Studio или [DotNet-Watch](xref:tutorials/dotnet-watch) в Visual Studio Code, чтобы перестроить проект, когда обнаруживает изменения в *CSHTML* -файлы. В Visual Studio изменения в файлах *CS*, *CSHTML*или *Razor* в выполняемом проекте (<kbd>CTRL + F5</kbd>), но не в режиме отладки (<kbd>F5</kbd>) активируют повторную компиляцию проекта.

Включение компиляции во время выполнения в проекте ASP.NET Core 3,0:

1. установить пакет NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Обновите `Startup.ConfigureServices`, чтобы вызвать `AddRazorRuntimeCompilation`:

    Для ASP.NET Core MVC используйте следующий код:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Для ASP.NET Core Razor Pages используйте следующий код:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
В примере на https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation показан пример включения условия компиляции среды выполнения в средах разработки.

Дополнительные сведения о компиляции файла Razor см. в разделе <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Миграция библиотек через многоплатформенную нацеливание

Библиотекам часто требуется поддержка нескольких версий ASP.NET Core. Большинство библиотек, которые были скомпилированы в предыдущих версиях ASP.NET Core, должны продолжать работать без проблем. Для следующих условий требуется перекрестная компиляция приложения:

* Библиотека использует функцию с двоичным [критическим изменением](#breaking-api-changes).
* Библиотека хочет воспользоваться преимуществами новых функций в ASP.NET Core 3,0. 

Например:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Используйте `#ifdefs`, чтобы включить API-интерфейсы ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Дополнительные сведения об использовании ASP.NET Core API в библиотеке классов см. в разделе <xref:fundamentals/target-aspnetcore>.

## <a name="miscellaneous-changes"></a>Прочие изменения

Система проверки в .NET Core 3,0 и более поздних версий рассматривает параметры, не допускающие значения NULL, или привязанные свойства так, как если бы они имели атрибут `[Required]`. Дополнительные сведения см. в разделе [атрибут [Required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Опубликовать

Удалите папки *bin* и *obj* в каталоге проекта.

## <a name="testserver"></a>TestServer

Для приложений, которые используют <xref:Microsoft.AspNetCore.TestHost.TestServer> непосредственно с [универсальным узлом](xref:fundamentals/host/web-host), создайте `TestServer` на <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> в <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Прерывание изменений API

Ознакомьтесь с критическими изменениями:

* [Полный список критических изменений в выпуске ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Прерывание изменений API в подделке, CORS, диагностике, MVC и маршрутизации](https://github.com/aspnet/Announcements/issues/387). Этот список содержит критические изменения для параметров совместимости.
* Сводные сведения о критических изменениях 2,2-3,0 в .NET Core, ASP.NET Core и Entity Framework Core см. в разделе [критические изменения для миграции с версии 2,2 на 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 в службе приложений Azure

Сведения о ходе развертывания .NET Core в службе приложений Azure см. на странице официальное приложение [.NET Core на](https://aspnetcoreon.azurewebsites.net/) веб-сайте службы приложений. Пока .NET Core 3,0 не будет доступен в службе приложений Azure, следуйте инструкциям в статье [развертывание ASP.NET Core предварительной версии в службе приложений Azure](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
