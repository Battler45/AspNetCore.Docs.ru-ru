---
title: Модели размещения Blazor ASP.NET Core
author: guardrex
description: Общие сведения о моделях размещения Blazor и Blazor Server.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 11/23/2019
no-loc:
- Blazor
- SignalR
uid: blazor/hosting-models
ms.openlocfilehash: 38db9804c9cdd1aa31ca48af2dd9ec2e85175156
ms.sourcegitcommit: 0dd224b2b7efca1fda0041b5c3f45080327033f6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/02/2019
ms.locfileid: "74681049"
---
# <a name="aspnet-core-opno-locblazor-hosting-models"></a>Модели размещения Blazor ASP.NET Core

По [Даниэль Roth)](https://github.com/danroth27)

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

Blazor — это веб-платформа, предназначенная для запуска на стороне клиента в браузере в среде выполнения .NET на основе [сборки](https://webassembly.org/)(Blazor веб- *сборки*) или на стороне сервера в ASP.NET Core ( *Blazor Server*). Независимо от модели размещения, модели приложения и компонента *одинаковы*.

Сведения о создании проекта для моделей размещения, описанных в этой статье, см. в разделе <xref:blazor/get-started>.

## <a name="opno-locblazor-webassembly"></a>Blazor WebAssembly

Основная модель размещения для Blazor работает на стороне клиента в браузере на веб-сборке. Приложение Blazor, его зависимости и среда выполнения .NET скачиваются в браузере. Приложение выполняется непосредственно в потоке пользовательского интерфейса браузера. Обновления пользовательского интерфейса и обработка событий выполняются в рамках одного процесса. Ресурсы приложения развертываются как статические файлы на веб-сервере или в службе, способной обслуживать статические содержимое клиентам.

![[! Операцион. NO-LOC (Блазор)]. сборка: [! Операцион. Приложение NO-LOC (Блазор)] выполняется в потоке пользовательского интерфейса в браузере.](hosting-models/_static/blazor-webassembly.png)

Чтобы создать Blazor приложение с помощью клиентской модели размещения, используйте шаблон **приложенияBlazor сборки** ([DotNet New блазорвасм](/dotnet/core/tools/dotnet-new)).

ВыбравBlazor шаблон **приложения-сборки** , вы можете настроить приложение для использования ASP.NET Core серверной части, установив флажок **ASP.NET Core Hosted** ([DotNet New блазорвасм — Hosted](/dotnet/core/tools/dotnet-new)). ASP.NET Core приложение обслуживает Blazor приложение клиентам. Blazor приложение веб-сборки может взаимодействовать с сервером по сети с помощью вызовов или [SignalR](xref:signalr/introduction).

Шаблоны включают скрипт *блазор... js* , который обрабатывает:

* Загрузка среды выполнения .NET, приложения и зависимостей приложения.
* Инициализация среды выполнения для запуска приложения.

Модель размещения Blazorных сборок предоставляет несколько преимуществ.

* Зависимость на стороне сервера .NET отсутствует. Приложение полностью работает после загрузки на клиент.
* Ресурсы и возможности клиента полностью используются.
* Работа разгружается с сервера на клиент.
* Веб-сервер ASP.NET Core не требуется для размещения приложения. Возможны сценарии бессерверного развертывания (например, обслуживание приложения из CDN).

Существует недостаток для Blazor размещения сборки:

* Приложение ограничено возможностями браузера.
* Требуется аппаратное и программное обеспечение, поддерживающее клиент (например, поддержка сборок).
* Размер скачивания больше, и приложения загружаются дольше.
* Поддержка среды выполнения .NET и инструментария менее зрела. Например, существуют ограничения на поддержку и отладку [.NET Standard](/dotnet/standard/net-standard) .

## <a name="opno-locblazor-server"></a>Сервер Blazor

При использовании модели размещения сервера Blazor приложение выполняется на сервере из приложения ASP.NET Core. Обновление элементов пользовательского интерфейса, обработка событий и вызовы JavaScript обрабатываются через подключение [SignalR](xref:signalr/introduction).

![Браузер взаимодействует с приложением (размещенным в приложении ASP.NET Core) на сервере через [! Операцион. НЕТ-LOC (SignalR)] подключение.](hosting-models/_static/blazor-server.png)

Чтобы создать Blazor приложение с помощью модели размещения сервера Blazor, используйте шаблон **серверного приложения ASP.NET CoreBlazor** ([DotNet New блазорсервер](/dotnet/core/tools/dotnet-new)). Приложение ASP.NET Core размещает приложение Blazor Server и создает конечную точку SignalR, в которую подключаются клиенты.

ASP.NET Core приложение ссылается на класс `Startup` приложения для добавления:

* Службы на стороне сервера.
* Приложение в конвейер обработки запросов.

Скрипт *блазор. Server. js*&dagger; устанавливает клиентское соединение. Ответственность за сохранение и восстановление состояния приложения в случае необходимости (например, в случае потери сетевого подключения) несет приложение.

Модель размещения серверов Blazor предлагает несколько преимуществ.

* Размер загружаемого файла значительно меньше, чем Blazor приложение сборки, и приложение загружается гораздо быстрее.
* Приложение обладает всеми преимуществами серверных возможностей, включая использование любых API-интерфейсов, совместимых с .NET Core.
* .NET Core на сервере используется для запуска приложения, поэтому существующие инструменты .NET, такие как отладка, работают должным образом.
* Поддерживаются тонкие клиенты. Например, Blazor серверные приложения работают с браузерами, которые не поддерживают сборку и устройства с ограниченными ресурсами.
* База .NET (C# код) приложения, включая код компонента приложения, не обслуживаются для клиентов.

Существуют недостатки Blazor размещения сервера:

* Обычно существует большая задержка. Каждое взаимодействие с пользователем включает сетевой прыжок.
* Автономная поддержка отсутствует. Если подключение клиента завершается сбоем, приложение перестает работать.
* Масштабируемость — это сложная задача для приложений с большим количеством пользователей. Сервер должен управлять несколькими клиентскими подключениями и обрабатывать состояние клиента.
* Для обслуживания приложения требуется сервер ASP.NET Core. Сценарии бессерверного развертывания невозможны (например, обслуживание приложения из CDN).

&dagger;сценарий *блазор. Server. js* обслуживается из внедренного ресурса в ASP.NET Core общей платформе.

### <a name="comparison-to-server-rendered-ui"></a>Сравнение с ИНТЕРФЕЙСом, отображаемым сервером

Одним из способов понимания Blazor серверных приложений является понимание того, как оно отличается от традиционных моделей для отрисовки пользовательского интерфейса в ASP.NET Core приложениях с помощью представлений Razor или Razor Pages. В обеих моделях используется язык Razor для описания содержимого HTML, но они значительно отличаются от отрисовки разметки.

При отрисовке страницы Razor или представления каждая строка кода Razor выдает HTML в виде текста. После отрисовки сервер удаляет экземпляр страницы или представления, включая любое созданное состояние. Когда происходит другой запрос к странице, например при сбое проверки сервера и отображении сводки проверки:

* Вся страница снова преобразуется в HTML-текст.
* Страница отправляется клиенту.

Blazor приложение состоит из многократно используемых элементов пользовательского интерфейса, называемых *компонентами*. Компонент содержит C# код, разметку и другие компоненты. При подготовке компонента к просмотру Blazor создает граф включенных компонентов, аналогичный HTML-или модель DOM XML (DOM). Эта диаграмма включает в себя состояние компонента, содержащееся в свойствах и полях. Blazor оценивает граф компонентов для создания двоичного представления разметки. Двоичный формат может быть следующим:

* Преобразуется в текст HTML (во время предварительной отрисовки).
* Используется для эффективного обновления разметки во время обычной отрисовки.

Обновление пользовательского интерфейса в Blazor активируется следующим образом:

* Взаимодействие с пользователем, например выбор кнопки.
* Триггеры приложений, например таймер.

Граф перерисовывается, и вычисляется *различие в пользовательском* интерфейсе (разница). Это различие является наименьшим набором изменений DOM, необходимых для обновления пользовательского интерфейса на клиенте. Diff отправляется клиенту в двоичном формате и применяется в браузере.

Компонент уничтожается после того, как пользователь выходит из него с клиента. Несмотря на то, что пользователь взаимодействует с компонентом, состояние компонента (службы, ресурсы) должно храниться в памяти сервера. Так как состояние множества компонентов может поддерживаться сервером одновременно, нехватка памяти является проблемой, которую необходимо решить. Инструкции по созданию приложения Blazor Server для обеспечения оптимального использования памяти сервера см. в разделе <xref:security/blazor/server>.

### <a name="circuits"></a>Защит

Серверное приложение Blazor построено на основе [ASP.NET Core SignalR](xref:signalr/introduction). Каждый клиент взаимодействует с сервером через одно или несколько SignalR соединений, называемых *каналом*. Цепь — это Blazorабстракции для SignalR подключений, которые могут допускать временные перерывы в сети. Когда клиент Blazor видит, что SignalRное подключение отключено, оно пытается повторно подключиться к серверу с помощью нового соединения SignalR.

Каждый экран браузера (вкладка браузера или IFRAME), подключенный к Blazor серверному приложению, использует SignalRное соединение. Это еще одно важное различие по сравнению с обычными серверно-визуализированными приложениями. В приложении, готовом для просмотра, открытие одного и того же приложения на нескольких экранах браузера обычно не приводит к дополнительным требованиям к ресурсам на сервере. В приложении Blazor Server каждый экран браузера требует отдельного канала и отдельных экземпляров состояния компонента для управления сервером.

Blazor рассматривает закрытие вкладки браузера или переход по внешнему URL-адресу *корректное* завершение. В случае корректного завершения работы канал и связанные ресурсы немедленно освобождаются. Клиент может также отключиться от некорректного, например, из-за прерывания работы сети. Blazor Server хранит отключенные цепи в течение настраиваемого интервала, чтобы разрешить клиенту повторное подключение. Дополнительные сведения см. в разделе повторное [Подключение к тому же серверу](#reconnection-to-the-same-server) .

### <a name="ui-latency"></a>Задержка пользовательского интерфейса

Задержка пользовательского интерфейса — это время, которое занимает от инициированного действия до момента обновления пользовательского интерфейса. Меньшее значение задержки пользовательского интерфейса является обязательным, чтобы приложение было легко реагировать на пользователя. В приложении Blazor Server каждое действие отправляется на сервер, обрабатывается, и разница пользовательского интерфейса отсылается обратно. Следовательно, задержка пользовательского интерфейса — это сумма задержки в сети и задержки сервера при обработке действия.

Для бизнес-приложения, которое ограничено частной корпоративной сетью, воздействие на восприятие пользователей задержки из-за задержки в сети обычно незаметно. Для приложения, развернутого через Интернет, задержка может стать заметным для пользователей, особенно в том случае, если пользователи широко распределены географически.

Использование памяти может также повлиять на задержку приложения. Увеличение использования памяти приводит к частым сборкам мусора или выделению памяти на диск, что снижает производительность приложений и, следовательно, увеличивает задержку пользовательского интерфейса. Для получения дополнительной информации см. <xref:security/blazor/server>.

Blazor серверные приложения должны быть оптимизированы для минимизации задержки пользовательского интерфейса за счет уменьшения задержки сети и использования памяти. Способ измерения задержки в сети см. в разделе <xref:host-and-deploy/blazor/server#measure-network-latency>. Дополнительные сведения о SignalR и Blazorсм. в следующих статьях:

* <xref:host-and-deploy/blazor/server>
* <xref:security/blazor/server>

### <a name="connection-to-the-server"></a>Соединение с сервером

для Blazor серверных приложений требуется активное подключение SignalR к серверу. Если соединение потеряно, приложение попытается повторно подключиться к серверу. Пока состояние клиента по-прежнему находится в памяти, сеанс клиента возобновляется без потери состояния.

#### <a name="reconnection-to-the-same-server"></a>Повторное подключение к тому же серверу

Приложение Blazor Server предварительно отображается в ответ на первый клиентский запрос, который настраивает состояние пользовательского интерфейса на сервере. Когда клиент пытается создать SignalR подключение, клиент должен повторно подключиться к тому же серверу. Blazor серверных приложений, использующих более одного внутреннего сервера, должны реализовывать *закрепленные сеансы* для SignalRных соединений.

Мы рекомендуем использовать для серверных приложений Blazor [службу Azure SignalR](/azure/azure-signalr). Она позволяет вертикально масштабировать серверные приложения Blazor для одновременного использования большого числа подключений SignalR. Прикрепленные сеансы включены для службы SignalR Azure, задав для параметра `ServerStickyMode` или значения конфигурации службы значение `Required`. Для получения дополнительной информации см. <xref:host-and-deploy/blazor/server#signalr-configuration>.

При использовании IIS работа с прикрепленными сеансами включает маршрутизацию запросов приложений. Дополнительные сведения см. в разделе [Балансировка нагрузки HTTP с использованием маршрутизации запросов приложений](/iis/extensions/configuring-application-request-routing-arr/http-load-balancing-using-application-request-routing).

#### <a name="reflect-the-connection-state-in-the-ui"></a>Отражение состояния соединения в пользовательском интерфейсе

Когда клиент обнаруживает, что соединение потеряно, пользователь по умолчанию отображает пользовательский интерфейс, когда клиент пытается повторно подключиться. Если происходит сбой повторного подключения, пользователь предоставляет возможность повторить попытку.

Чтобы настроить пользовательский интерфейс, определите элемент с `id` `components-reconnect-modal` в `<body>` страницы Razor *_Host. cshtml* :

```html
<div id="components-reconnect-modal">
    ...
</div>
```

В следующей таблице описаны классы CSS, применяемые к элементу `components-reconnect-modal`.

| Класс CSS                       | Указывает,&hellip; |
| ------------------------------- | ------------------------- |
| `components-reconnect-show`     | Утерянное подключение. Клиент пытается повторно подключиться. Отображение модального окна. |
| `components-reconnect-hide`     | Активное подключение будет восстановлено на сервере. Скрыть модальное окно. |
| `components-reconnect-failed`   | Сбой повторного подключения, возможно, из-за сбоя сети. Чтобы повторить попытку подключения, вызовите `window.Blazor.reconnect()`. |
| `components-reconnect-rejected` | Повторное подключение отклонено. Сервер был достигнут, но отклонил подключение, и состояние пользователя на сервере потеряно. Чтобы перезагрузить приложение, вызовите `location.reload()`. Это состояние соединения может появиться в следующих случаях:<ul><li>Происходит сбой в цепи на стороне сервера.</li><li>Клиент отключается достаточно долго, чтобы сервер отключил состояние пользователя. Удаляются экземпляры компонентов, с которыми взаимодействует пользователь.</li><li>Сервер перезагружается, или рабочий процесс приложения перезапускается.</li></ul> |

### <a name="stateful-reconnection-after-prerendering"></a>Повторное подключение с отслеживанием состояния после предварительной подготовки к просмотру

Серверные приложения Blazor настроены по умолчанию для выprerender пользовательский интерфейс на сервере, прежде чем будет установлено клиентское соединение с сервером. Это настраивается на странице Razor *_Host. cshtml* :

::: moniker range=">= aspnetcore-3.1"

```cshtml
<body>
    <app>
      <component type="typeof(App)" render-mode="ServerPrerendered" />
    </app>

    <script src="_framework/blazor.server.js"></script>
</body>
```

::: moniker-end

::: moniker range="< aspnetcore-3.1"

```cshtml
<body>
    <app>@(await Html.RenderComponentAsync<App>(RenderMode.ServerPrerendered))</app>

    <script src="_framework/blazor.server.js"></script>
</body>
```

::: moniker-end

`RenderMode` настраивает, является ли компонент:

* Предварительно отображается на странице.
* Отображается как статический HTML на странице или включает необходимые сведения для начальной загрузки Blazor приложения из агента пользователя.

::: moniker range=">= aspnetcore-3.1"

| `RenderMode`        | Описание |
| ------------------- | ----------- |
| `ServerPrerendered` | Преобразует компонент в статический HTML и включает маркер для Blazor серверного приложения. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. |
| `Server`            | Отображает маркер для серверного приложения Blazor. Выходные данные компонента не включаются. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. |
| `Static`            | Преобразует компонент в статический HTML. |

::: moniker-end

::: moniker range="< aspnetcore-3.1"

| `RenderMode`        | Описание |
| ------------------- | ----------- |
| `ServerPrerendered` | Преобразует компонент в статический HTML и включает маркер для Blazor серверного приложения. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. Параметры не поддерживаются. |
| `Server`            | Отображает маркер для серверного приложения Blazor. Выходные данные компонента не включаются. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. Параметры не поддерживаются. |
| `Static`            | Преобразует компонент в статический HTML. Поддерживаются параметры. |

::: moniker-end

Отрисовка компонентов сервера из статической HTML-страницы не поддерживается.

Если `RenderMode` `ServerPrerendered`, компонент изначально отрисовывается статически как часть страницы. После того, как браузер установит соединение с сервером, компонент *снова*готовится к просмотру, и теперь компонент является интерактивным. Если имеется метод жизненно инициализированного метода жизненный цикл [{Async}](xref:blazor/lifecycle#component-initialization-methods) для инициализации компонента, метод выполняется *дважды*:

* Когда компонент предварительно отображается статически.
* После установки соединения с сервером.

Это может привести к заметному изменению данных, отображаемых в пользовательском интерфейсе, когда компонент в итоге готовится к просмотру.

Чтобы избежать сценария двойной визуализации в приложении Blazor Server, выполните следующие действия.

* Передайте идентификатор, который можно использовать для кэширования состояния во время подготовки к просмотру, и для получения состояния после перезапуска приложения.
* Используйте идентификатор во время подготовки к просмотру для сохранения состояния компонента.
* Используйте идентификатор после предварительной подготовки для получения кэшированного состояния.

В следующем коде показано обновленное `WeatherForecastService` в серверном приложении Blazor на основе шаблонов, которое позволяет избежать двойной отрисовки:

```csharp
public class WeatherForecastService
{
    private static readonly string[] Summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild",
        "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };
    
    public WeatherForecastService(IMemoryCache memoryCache)
    {
        MemoryCache = memoryCache;
    }
    
    public IMemoryCache MemoryCache { get; }

    public Task<WeatherForecast[]> GetForecastAsync(DateTime startDate)
    {
        return MemoryCache.GetOrCreateAsync(startDate, async e =>
        {
            e.SetOptions(new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = 
                    TimeSpan.FromSeconds(30)
            });

            var rng = new Random();

            await Task.Delay(TimeSpan.FromSeconds(10));

            return Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = startDate.AddDays(index),
                TemperatureC = rng.Next(-20, 55),
                Summary = Summaries[rng.Next(Summaries.Length)]
            }).ToArray();
        });
    }
}
```

### <a name="render-stateful-interactive-components-from-razor-pages-and-views"></a>Отображение интерактивных компонентов с отслеживанием состояния из страниц и представлений Razor

Интерактивные компоненты с отслеживанием состояния могут быть добавлены на страницу Razor или в представление.

При визуализации страницы или представления:

* Компонент предварительно отображается страницей или представлением.
* Исходное состояние компонента, используемое для предварительной визуализации, потеряно.
* Новое состояние компонента создается при установке подключения SignalR.

Следующая страница Razor визуализирует компонент `Counter`:

::: moniker range=">= aspnetcore-3.1"

```cshtml
<h1>My Razor Page</h1>

<component type="typeof(Counter)" render-mode="ServerPrerendered" 
    param-InitialValue="InitialValue" />

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

::: moniker-end

::: moniker range="< aspnetcore-3.1"

```cshtml
<h1>My Razor Page</h1>

@(await Html.RenderComponentAsync<Counter>(RenderMode.ServerPrerendered))

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

::: moniker-end

### <a name="render-noninteractive-components-from-razor-pages-and-views"></a>Прорисовка неинтерактивных компонентов на страницах и представлениях Razor

На следующей странице Razor компонент `MyComponent` статически подготавливается к просмотру с начальным значением, указанным с помощью формы:

::: moniker range=">= aspnetcore-3.1"

```cshtml
<h1>My Razor Page</h1>

<form>
    <input type="number" asp-for="InitialValue" />
    <button type="submit">Set initial value</button>
</form>

<component type="typeof(Counter)" render-mode="Static" 
    param-InitialValue="InitialValue" />

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

::: moniker-end

::: moniker range="< aspnetcore-3.1"

```cshtml
<h1>My Razor Page</h1>

<form>
    <input type="number" asp-for="InitialValue" />
    <button type="submit">Set initial value</button>
</form>

@(await Html.RenderComponentAsync<MyComponent>(RenderMode.Static, 
    new { InitialValue = InitialValue }))

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

::: moniker-end

Поскольку `MyComponent` является статически отображаемым, компонент не может быть интерактивным.

### <a name="detect-when-the-app-is-prerendering"></a>Обнаруживать время подготовки приложения к просмотру

[!INCLUDE[](~/includes/blazor-prerendering.md)]

### <a name="configure-the-opno-locsignalr-client-for-opno-locblazor-server-apps"></a>Настройка клиента SignalR для приложений Blazor Server

Иногда необходимо настроить клиент SignalR, используемый приложениями Blazor Server. Например, может потребоваться настроить ведение журнала на SignalRном клиенте для диагностики проблемы с подключением.

Настройка клиента SignalR в файле *pages/_Host. cshtml* :

* Добавьте атрибут `autostart="false"` в тег `<script>` для скрипта *блазор. Server. js* .
* Вызовите `Blazor.start` и передайте объект конфигурации, указывающий построитель SignalR.

```html
<script src="_framework/blazor.server.js" autostart="false"></script>
<script>
  Blazor.start({
    configureSignalR: function (builder) {
      builder.configureLogging("information"); // LogLevel.Information
    }
  });
</script>
```

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:blazor/get-started>
* <xref:signalr/introduction>
