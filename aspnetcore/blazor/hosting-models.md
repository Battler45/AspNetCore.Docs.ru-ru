---
title: Модели размещения Blazor ASP.NET Core
author: guardrex
description: Общие сведения о моделях размещения Blazor и Blazor Server.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 01/31/2020
no-loc:
- Blazor
- SignalR
uid: blazor/hosting-models
ms.openlocfilehash: 7b4d4aca0bc4650c31bc8e5c4a84ecbad6a49b09
ms.sourcegitcommit: 0e21d4f8111743bcb205a2ae0f8e57910c3e8c25
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2020
ms.locfileid: "77034095"
---
# <a name="aspnet-core-blazor-hosting-models"></a>ASP.NET Core моделей размещения Блазор

По [Даниэль Roth)](https://github.com/danroth27)

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

Блазор — это веб-платформа, предназначенная для запуска на стороне клиента в браузере в среде выполнения .NET на основе [сборки](https://webassembly.org/)(*блазор*) или на стороне сервера в ASP.NET Core (*блазор Server*). Независимо от модели размещения, модели приложения и компонента *одинаковы*.

Сведения о создании проекта для моделей размещения, описанных в этой статье, см. в разделе <xref:blazor/get-started>.

## <a name="blazor-webassembly"></a>Blazor WebAssembly

Основная модель размещения для Блазор работает на стороне клиента в браузере на веб-сборке. Приложение Blazor, его зависимости и среда выполнения .NET скачиваются в браузере. Приложение выполняется непосредственно в потоке пользовательского интерфейса браузера. Обновления пользовательского интерфейса и обработка событий выполняются в рамках одного процесса. Ресурсы приложения развертываются как статические файлы на веб-сервере или в службе, способной обслуживать статические содержимое клиентам.

![Блазор веб-сборка: приложение Блазор выполняется в потоке пользовательского интерфейса в браузере.](hosting-models/_static/blazor-webassembly.png)

Чтобы создать приложение Блазор с помощью клиентской модели размещения, используйте шаблон **приложения блазор для сборки** ([DotNet New блазорвасм](/dotnet/core/tools/dotnet-new)).

Выбрав шаблон **приложения блазор-Assembly** , вы можете настроить приложение для использования ASP.NET Core серверной части, установив флажок **ASP.NET Core размещения** ([DotNet New блазорвасм — Hosted](/dotnet/core/tools/dotnet-new)). ASP.NET Core приложение обслуживает приложения Блазор для клиентов. Приложение Блазор сборки может взаимодействовать с сервером по сети с помощью вызовов веб-API или [SignalR](xref:signalr/introduction) (<xref:tutorials/signalr-blazor-webassembly>).

Шаблоны включают `blazor.webassembly.js` сценарий, который обрабатывает:

* Загрузка среды выполнения .NET, приложения и зависимостей приложения.
* Инициализация среды выполнения для запуска приложения.

Модель размещения Блазор содержит несколько преимуществ.

* Зависимость на стороне сервера .NET отсутствует. Приложение полностью работает после загрузки на клиент.
* Ресурсы и возможности клиента полностью используются.
* Работа разгружается с сервера на клиент.
* Веб-сервер ASP.NET Core не требуется для размещения приложения. Возможны сценарии бессерверного развертывания (например, обслуживание приложения из CDN).

Существует недостаток для Блазор размещения сборки.

* Приложение ограничено возможностями браузера.
* Требуется аппаратное и программное обеспечение, поддерживающее клиент (например, поддержка сборок).
* Размер скачивания больше, и приложения загружаются дольше.
* Поддержка среды выполнения .NET и инструментария менее зрела. Например, существуют ограничения на поддержку и отладку [.NET Standard](/dotnet/standard/net-standard) .

## <a name="blazor-server"></a>Blazor Server

При использовании модели размещения сервера Блазор приложение выполняется на сервере в приложении ASP.NET Core. Обновление элементов пользовательского интерфейса, обработка событий и вызовы JavaScript обрабатываются через подключение [SignalR](xref:signalr/introduction).

![Браузер взаимодействует с приложением (размещенным в приложении ASP.NET Core) на сервере через подключение SignalR.](hosting-models/_static/blazor-server.png)

Чтобы создать приложение Блазор с помощью модели размещения сервера Блазор, используйте шаблон **серверное приложение ASP.NET Core блазор** ([DotNet New блазорсервер](/dotnet/core/tools/dotnet-new)). В ASP.NET Core приложении размещается серверное приложение Блазор и создается конечная точка SignalR, в которую подключаются клиенты.

ASP.NET Core приложение ссылается на класс `Startup` приложения для добавления:

* Службы на стороне сервера.
* Приложение в конвейер обработки запросов.

Сценарий `blazor.server.js`&dagger; устанавливает соединение с клиентом. Ответственность за сохранение и восстановление состояния приложения в случае необходимости (например, в случае потери сетевого подключения) несет приложение.

Модель размещения сервера Блазор предлагает несколько преимуществ.

* Размер загружаемого файла значительно меньше, чем Блазор приложение сборки, и приложение загружается гораздо быстрее.
* Приложение обладает всеми преимуществами серверных возможностей, включая использование любых API-интерфейсов, совместимых с .NET Core.
* .NET Core на сервере используется для запуска приложения, поэтому существующие инструменты .NET, такие как отладка, работают должным образом.
* Поддерживаются тонкие клиенты. Например, серверные приложения Блазор работают с браузерами, которые не поддерживают сборку и устройства с ограниченными ресурсами.
* База .NET (C# код) приложения, включая код компонента приложения, не обслуживаются для клиентов.

Существуют недостатки для размещения сервера Блазор:

* Обычно существует большая задержка. Каждое взаимодействие с пользователем включает сетевой прыжок.
* Автономная поддержка отсутствует. Если подключение клиента завершается сбоем, приложение перестает работать.
* Масштабируемость — это сложная задача для приложений с большим количеством пользователей. Сервер должен управлять несколькими клиентскими подключениями и обрабатывать состояние клиента.
* Для обслуживания приложения требуется сервер ASP.NET Core. Сценарии бессерверного развертывания невозможны (например, обслуживание приложения из CDN).

&dagger;сценарий `blazor.server.js` обслуживается из внедренного ресурса в ASP.NET Core общей платформе.

### <a name="comparison-to-server-rendered-ui"></a>Сравнение с ИНТЕРФЕЙСом, отображаемым сервером

Одним из способов понимания серверных приложений Блазор является понимание того, как оно отличается от традиционных моделей для отрисовки пользовательского интерфейса в ASP.NET Core приложениях с помощью представлений Razor или Razor Pages. В обеих моделях используется язык Razor для описания содержимого HTML, но они значительно отличаются от отрисовки разметки.

При отрисовке страницы Razor или представления каждая строка кода Razor выдает HTML в виде текста. После отрисовки сервер удаляет экземпляр страницы или представления, включая любое созданное состояние. Когда происходит другой запрос к странице, например при сбое проверки сервера и отображении сводки проверки:

* Вся страница снова преобразуется в HTML-текст.
* Страница отправляется клиенту.

Приложение Блазор состоит из многократно используемых элементов пользовательского интерфейса, называемых *компонентами*. Компонент содержит C# код, разметку и другие компоненты. При подготовке компонента к просмотру Блазор создает граф включенных компонентов, аналогичный HTML-или XML-модель DOM (DOM). Эта диаграмма включает в себя состояние компонента, содержащееся в свойствах и полях. Блазор оценивает граф компонентов для создания двоичного представления разметки. Двоичный формат может быть следующим:

* Преобразуется в текст HTML (во время предварительной отрисовки).
* Используется для эффективного обновления разметки во время обычной отрисовки.

Обновление пользовательского интерфейса в Блазор активируется следующим образом:

* Взаимодействие с пользователем, например выбор кнопки.
* Триггеры приложений, например таймер.

Граф перерисовывается, и вычисляется *различие в пользовательском* интерфейсе (разница). Это различие является наименьшим набором изменений DOM, необходимых для обновления пользовательского интерфейса на клиенте. Diff отправляется клиенту в двоичном формате и применяется в браузере.

Компонент уничтожается после того, как пользователь выходит из него с клиента. Несмотря на то, что пользователь взаимодействует с компонентом, состояние компонента (службы, ресурсы) должно храниться в памяти сервера. Так как состояние множества компонентов может поддерживаться сервером одновременно, нехватка памяти является проблемой, которую необходимо решить. Инструкции по созданию Блазор серверного приложения для обеспечения оптимального использования памяти сервера см. в разделе <xref:security/blazor/server>.

### <a name="integrate-razor-components-into-razor-pages-and-mvc-apps"></a>Интеграция компонентов Razor в приложения Razor Pages и MVC

#### <a name="use-components-in-pages-and-views"></a>Использование компонентов в страницах и представлениях

Существующее приложение Razor Pages или MVC может интегрировать компоненты Razor в страницы и представления:

1. В файле макета приложения ( *_layout. cshtml*):

   * Добавьте следующий тег `<base>` в элемент `<head>`:

     ```html
     <base href="~/" />
     ```

     Значение `href` ( *базовый путь приложения*) в предыдущем примере предполагает, что приложение находится по КОРНЕВОМУ URL-пути (`/`). Если приложение является вложенным приложением, следуйте указаниям в разделе " *базовый путь приложения* " статьи <xref:host-and-deploy/blazor/index#app-base-path>.

     Файл *_layout. cshtml* находится в папке *pages/shared* в приложении Razor Pages или в папке *views/Shared* приложения MVC.

   * Добавьте тег `<script>` для скрипта *блазор. Server. js* внутри закрывающего тега `</body>`:

     ```html
     <script src="_framework/blazor.server.js"></script>
     ```

     Платформа добавляет в приложение скрипт *блазор. Server. js* . Нет необходимости вручную добавлять скрипт в приложение.

1. Добавьте файл *_Imports. Razor* в корневую папку проекта со следующим содержимым (измените Последнее пространство имен, `MyAppNamespace`, в пространство имен приложения):

   ```csharp
   @using System.Net.Http
   @using Microsoft.AspNetCore.Authorization
   @using Microsoft.AspNetCore.Components.Authorization
   @using Microsoft.AspNetCore.Components.Forms
   @using Microsoft.AspNetCore.Components.Routing
   @using Microsoft.AspNetCore.Components.Web
   @using Microsoft.JSInterop
   @using MyAppNamespace
   ```

1. В `Startup.ConfigureServices`добавьте службу Блазор Server:

   ```csharp
   services.AddServerSideBlazor();
   ```

1. В `Startup.Configure`Добавьте конечную точку концентратора Блазор в `app.UseEndpoints`:

   ```csharp
   endpoints.MapBlazorHub();
   ```

1. Интегрируйте компоненты в любую страницу или представление. Дополнительные сведения см. в разделе *Интеграция компонентов в Razor Pages и приложения MVC* статьи <xref:blazor/components#integrate-components-into-razor-pages-and-mvc-apps>.

#### <a name="use-routable-components-in-a-razor-pages-app"></a>Использование маршрутизируемых компонентов в приложении Razor Pages

Для поддержки маршрутизируемых компонентов Razor в Razor Pages приложениях:

1. Следуйте указаниям в разделе [Использование компонентов в страницах и представлениях](#use-components-in-pages-and-views) .

1. Добавьте файл *app. Razor* в корневую папку проекта со следующим содержимым:

   ```razor
   @using Microsoft.AspNetCore.Components.Routing

   <Router AppAssembly="typeof(Program).Assembly">
       <Found Context="routeData">
           <RouteView RouteData="routeData" />
       </Found>
       <NotFound>
           <h1>Page not found</h1>
           <p>Sorry, but there's nothing here!</p>
       </NotFound>
   </Router>
   ```

1. Добавьте файл *_Host. cshtml* в папку *pages* со следующим содержимым:

   ```cshtml
   @page "/blazor"
   @{
       Layout = "_Layout";
   }

   <app>
       <component type="typeof(App)" render-mode="ServerPrerendered" />
   </app>
   ```

   Компоненты используют общий файл *_layout. cshtml* для их макета.

1. Добавьте маршрут с низким приоритетом для страницы *_Host. cshtml* в конфигурацию конечной точки в `Startup.Configure`:

   ```csharp
   app.UseEndpoints(endpoints =>
   {
       ...

       endpoints.MapFallbackToPage("/_Host");
   });
   ```

1. Добавьте маршрутизируемые компоненты в приложение. Пример:

   ```razor
   @page "/counter"

   <h1>Counter</h1>

   ...
   ```

   При использовании пользовательской папки для хранения компонентов приложения добавьте пространство имен, представляющее папку, в файл *pages/_ViewImports. cshtml* . Дополнительные сведения см. в разделе <xref:blazor/components#integrate-components-into-razor-pages-and-mvc-apps>.

#### <a name="use-routable-components-in-an-mvc-app"></a>Использование маршрутизируемых компонентов в приложении MVC

Для поддержки маршрутизации компонентов Razor в приложениях MVC:

1. Следуйте указаниям в разделе [Использование компонентов в страницах и представлениях](#use-components-in-pages-and-views) .

1. Добавьте файл *app. Razor* в корневую папку проекта со следующим содержимым:

   ```razor
   @using Microsoft.AspNetCore.Components.Routing

   <Router AppAssembly="typeof(Program).Assembly">
       <Found Context="routeData">
           <RouteView RouteData="routeData" />
       </Found>
       <NotFound>
           <h1>Page not found</h1>
           <p>Sorry, but there's nothing here!</p>
       </NotFound>
   </Router>
   ```

1. Добавьте файл *_Host. cshtml* в папку *Views/Home* со следующим содержимым:

   ```cshtml
   @{
       Layout = "_Layout";
   }

   <app>
       <component type="typeof(App)" render-mode="ServerPrerendered" />
   </app>
   ```

   Компоненты используют общий файл *_layout. cshtml* для их макета.

1. Добавьте действие в контроллер Home:

   ```csharp
   public IActionResult Blazor()
   {
      return View("_Host");
   }
   ```

1. Добавьте маршрут с низким приоритетом для действия контроллера, которое возвращает представление *_Host. cshtml* в конфигурацию конечной точки в `Startup.Configure`:

   ```csharp
   app.UseEndpoints(endpoints =>
   {
       ...

       endpoints.MapFallbackToController("Blazor", "Home");
   });
   ```

1. Создайте папку *pages* и добавьте в приложение маршрутизируемые компоненты. Пример:

   ```razor
   @page "/counter"

   <h1>Counter</h1>

   ...
   ```

   При использовании пользовательской папки для хранения компонентов приложения добавьте пространство имен, представляющее папку, в файл *views/_ViewImports. cshtml* . Дополнительные сведения см. в разделе <xref:blazor/components#integrate-components-into-razor-pages-and-mvc-apps>.

### <a name="circuits"></a>Защит

Серверное приложение Блазор построено на основе [ASP.NET Core SignalR](xref:signalr/introduction). Каждый клиент обменивается данными с сервером по одному или нескольким подключениям SignalR, называемым *каналом*. Цепь — это Блазор абстракции соединений SignalR, которые могут допускать временные перерывы в сети. Когда клиент Блазор видит, что подключение SignalR разорвано, оно пытается повторно подключиться к серверу с помощью нового подключения SignalR.

Каждый экран браузера (вкладка браузера или IFRAME), подключенный к серверному приложению Блазор, использует подключение SignalR. Это еще одно важное различие по сравнению с обычными серверно-визуализированными приложениями. В приложении, готовом для просмотра, открытие одного и того же приложения на нескольких экранах браузера обычно не приводит к дополнительным требованиям к ресурсам на сервере. В серверном приложении Блазор каждый экран браузера требует отдельного канала и отдельных экземпляров состояния компонента для управления сервером.

Блазор рассматривает закрытие вкладки браузера или переход по внешнему URL-адресу *корректное* завершение. В случае корректного завершения работы канал и связанные ресурсы немедленно освобождаются. Клиент может также отключиться от некорректного, например, из-за прерывания работы сети. Блазор Server сохраняет отключенные цепи в течение настраиваемого интервала, чтобы разрешить клиенту повторное подключение. Дополнительные сведения см. в разделе повторное [Подключение к тому же серверу](#reconnection-to-the-same-server) .

### <a name="ui-latency"></a>Задержка пользовательского интерфейса

Задержка пользовательского интерфейса — это время, которое занимает от инициированного действия до момента обновления пользовательского интерфейса. Меньшее значение задержки пользовательского интерфейса является обязательным, чтобы приложение было легко реагировать на пользователя. В серверном приложении Блазор каждое действие отправляется на сервер, обрабатывается, и разница пользовательского интерфейса отправляется обратно. Следовательно, задержка пользовательского интерфейса — это сумма задержки в сети и задержки сервера при обработке действия.

Для бизнес-приложения, которое ограничено частной корпоративной сетью, воздействие на восприятие пользователей задержки из-за задержки в сети обычно незаметно. Для приложения, развернутого через Интернет, задержка может стать заметным для пользователей, особенно в том случае, если пользователи широко распределены географически.

Использование памяти может также повлиять на задержку приложения. Увеличение использования памяти приводит к частым сборкам мусора или выделению памяти на диск, что снижает производительность приложений и, следовательно, увеличивает задержку пользовательского интерфейса. Дополнительные сведения см. в разделе <xref:security/blazor/server>.

Блазор серверные приложения должны быть оптимизированы для минимизации задержки пользовательского интерфейса путем уменьшения задержки сети и использования памяти. Способ измерения задержки в сети см. в разделе <xref:host-and-deploy/blazor/server#measure-network-latency>. Дополнительные сведения о SignalR и Блазор см. в следующих статьях:

* <xref:host-and-deploy/blazor/server>
* <xref:security/blazor/server>

### <a name="connection-to-the-server"></a>Соединение с сервером

Для серверных приложений блазор требуется активное подключение SignalR к серверу. Если соединение потеряно, приложение попытается повторно подключиться к серверу. Пока состояние клиента по-прежнему находится в памяти, сеанс клиента возобновляется без потери состояния.

#### <a name="reconnection-to-the-same-server"></a>Повторное подключение к тому же серверу

Серверное приложение Блазор предварительно отображается в ответ на первый клиентский запрос, который настраивает состояние пользовательского интерфейса на сервере. Когда клиент пытается создать подключение SignalR, клиент должен повторно подключиться к тому же серверу. Серверные приложения блазор, использующие более одного внутреннего сервера, должны реализовывать *прикрепленные сеансы* для соединений SignalR.

Мы рекомендуем использовать для серверных приложений Blazor [службу Azure SignalR](/azure/azure-signalr). Она позволяет вертикально масштабировать серверные приложения Blazor для одновременного использования большого числа подключений SignalR. Для службы Azure SignalR включены закрепленные сеансы, присвоив параметру `ServerStickyMode` службы или значению конфигурации значение `Required`. Дополнительные сведения см. в разделе <xref:host-and-deploy/blazor/server#signalr-configuration>.

При использовании служб IIS прикрепленные сеансы включаются с помощью маршрутизации запросов приложений. Дополнительные сведения см. в статье [Балансировка нагрузки HTTP с помощью маршрутизации запросов приложений](/iis/extensions/configuring-application-request-routing-arr/http-load-balancing-using-application-request-routing).

#### <a name="reflect-the-connection-state-in-the-ui"></a>Отражение состояния соединения в пользовательском интерфейсе

Когда клиент обнаруживает, что соединение потеряно, пользователь по умолчанию отображает пользовательский интерфейс, когда клиент пытается повторно подключиться. Если происходит сбой повторного подключения, пользователь предоставляет возможность повторить попытку.

Чтобы настроить пользовательский интерфейс, определите элемент с `id` `components-reconnect-modal` в `<body>` страницы Razor *_Host. cshtml* :

```cshtml
<div id="components-reconnect-modal">
    ...
</div>
```

В следующей таблице описаны классы CSS, применяемые к элементу `components-reconnect-modal`.

| Класс CSS                       | Указывает,&hellip; |
| ------------------------------- | ------------------------- |
| `components-reconnect-show`     | Утерянное подключение. Клиент пытается повторно подключиться. Отображение модального окна. |
| `components-reconnect-hide`     | Активное подключение будет восстановлено на сервере. Скрыть модальное окно. |
| `components-reconnect-failed`   | Сбой повторного подключения, возможно, из-за сбоя сети. Чтобы повторить попытку подключения, вызовите `window.Blazor.reconnect()`. |
| `components-reconnect-rejected` | Повторное подключение отклонено. Сервер был достигнут, но отклонил подключение, и состояние пользователя на сервере потеряно. Чтобы перезагрузить приложение, вызовите `location.reload()`. Это состояние соединения может появиться в следующих случаях:<ul><li>Происходит сбой в цепи на стороне сервера.</li><li>Клиент отключается достаточно долго, чтобы сервер отключил состояние пользователя. Удаляются экземпляры компонентов, с которыми взаимодействует пользователь.</li><li>Сервер перезагружается, или рабочий процесс приложения перезапускается.</li></ul> |

### <a name="stateful-reconnection-after-prerendering"></a>Повторное подключение с отслеживанием состояния после предварительной подготовки к просмотру

Серверные приложения блазор по умолчанию настроены на выстройку пользовательского интерфейса на сервере, прежде чем будет установлено клиентское соединение с сервером. Это настраивается на странице Razor *_Host. cshtml* :

```cshtml
<body>
    <app>
      <component type="typeof(App)" render-mode="ServerPrerendered" />
    </app>

    <script src="_framework/blazor.server.js"></script>
</body>
```

`RenderMode` настраивает, является ли компонент:

* Предварительно отображается на странице.
* Отображается как статический HTML на странице или включает необходимые сведения для начальной загрузки приложения Блазор из агента пользователя.

| `RenderMode`        | Description |
| ------------------- | ----------- |
| `ServerPrerendered` | Преобразует компонент в статический HTML и включает маркер для Blazor серверного приложения. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. |
| `Server`            | Отображает маркер для серверного приложения Blazor. Выходные данные компонента не включаются. При запуске агента пользователя этот маркер используется для начальной загрузки Blazor приложения. |
| `Static`            | Преобразует компонент в статический HTML. |

Отрисовка компонентов сервера из статической HTML-страницы не поддерживается.

Если `RenderMode` `ServerPrerendered`, компонент изначально отрисовывается статически как часть страницы. После того, как браузер установит соединение с сервером, компонент *снова*готовится к просмотру, и теперь компонент является интерактивным. Если имеется метод жизненно инициализированного метода жизненный цикл [{Async}](xref:blazor/lifecycle#component-initialization-methods) для инициализации компонента, метод выполняется *дважды*:

* Когда компонент предварительно отображается статически.
* После установки соединения с сервером.

Это может привести к заметному изменению данных, отображаемых в пользовательском интерфейсе, когда компонент в итоге готовится к просмотру.

Чтобы избежать сценария двойной визуализации в приложении Blazor Server, выполните следующие действия.

* Передайте идентификатор, который можно использовать для кэширования состояния во время подготовки к просмотру, и для получения состояния после перезапуска приложения.
* Используйте идентификатор во время подготовки к просмотру для сохранения состояния компонента.
* Используйте идентификатор после предварительной подготовки для получения кэшированного состояния.

В следующем коде показано обновленное `WeatherForecastService` в серверном приложении Blazor на основе шаблонов, которое позволяет избежать двойной отрисовки:

```csharp
public class WeatherForecastService
{
    private static readonly string[] _summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild",
        "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };
    
    public WeatherForecastService(IMemoryCache memoryCache)
    {
        MemoryCache = memoryCache;
    }
    
    public IMemoryCache MemoryCache { get; }

    public Task<WeatherForecast[]> GetForecastAsync(DateTime startDate)
    {
        return MemoryCache.GetOrCreateAsync(startDate, async e =>
        {
            e.SetOptions(new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = 
                    TimeSpan.FromSeconds(30)
            });

            var rng = new Random();

            await Task.Delay(TimeSpan.FromSeconds(10));

            return Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = startDate.AddDays(index),
                TemperatureC = rng.Next(-20, 55),
                Summary = _summaries[rng.Next(_summaries.Length)]
            }).ToArray();
        });
    }
}
```

### <a name="render-stateful-interactive-components-from-razor-pages-and-views"></a>Отображение интерактивных компонентов с отслеживанием состояния из страниц и представлений Razor

Интерактивные компоненты с отслеживанием состояния могут быть добавлены на страницу Razor или в представление.

При визуализации страницы или представления:

* Компонент предварительно отображается страницей или представлением.
* Исходное состояние компонента, используемое для предварительной визуализации, потеряно.
* Новое состояние компонента создается при установке подключения SignalR.

Следующая страница Razor визуализирует компонент `Counter`:

```cshtml
<h1>My Razor Page</h1>

<component type="typeof(Counter)" render-mode="ServerPrerendered" 
    param-InitialValue="InitialValue" />

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

### <a name="render-noninteractive-components-from-razor-pages-and-views"></a>Прорисовка неинтерактивных компонентов на страницах и представлениях Razor

На следующей странице Razor компонент `Counter` статически подготавливается к просмотру с начальным значением, указанным с помощью формы:

```cshtml
<h1>My Razor Page</h1>

<form>
    <input type="number" asp-for="InitialValue" />
    <button type="submit">Set initial value</button>
</form>

<component type="typeof(Counter)" render-mode="Static" 
    param-InitialValue="InitialValue" />

@code {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
}
```

Поскольку `MyComponent` является статически отображаемым, компонент не может быть интерактивным.

### <a name="detect-when-the-app-is-prerendering"></a>Обнаруживать время подготовки приложения к просмотру

[!INCLUDE[](~/includes/blazor-prerendering.md)]

### <a name="configure-the-opno-locsignalr-client-for-opno-locblazor-server-apps"></a>Настройка клиента SignalR для приложений Blazor Server

Иногда необходимо настроить клиент SignalR, используемый приложениями Blazor Server. Например, может потребоваться настроить ведение журнала на SignalRном клиенте для диагностики проблемы с подключением.

Настройка клиента SignalR в файле *pages/_Host. cshtml* :

* Добавьте атрибут `autostart="false"` в тег `<script>` для скрипта `blazor.server.js`.
* Вызовите `Blazor.start` и передайте объект конфигурации, указывающий построитель SignalR.

```html
<script src="_framework/blazor.server.js" autostart="false"></script>
<script>
  Blazor.start({
    configureSignalR: function (builder) {
      builder.configureLogging("information"); // LogLevel.Information
    }
  });
</script>
```

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:blazor/get-started>
* <xref:signalr/introduction>
* <xref:tutorials/signalr-blazor-webassembly>
