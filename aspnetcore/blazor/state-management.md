---
title: Управление состоянием ASP.NET Core Блазор
author: guardrex
description: Узнайте, как сохранить состояние в приложениях Блазор на стороне сервера.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 08/06/2019
uid: blazor/state-management
ms.openlocfilehash: b9dd2bb8f070a9a17e15e947f76de78cc517e22e
ms.sourcegitcommit: 2719c70cd15a430479ab4007ff3e197fbf5dfee0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/09/2019
ms.locfileid: "68948414"
---
# <a name="aspnet-core-blazor-state-management"></a>Управление состоянием ASP.NET Core Блазор

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

Блазор на стороне сервера — это платформа приложений с отслеживанием состояния. В большинстве случаев приложение поддерживает текущее подключение к серверу. Состояние пользователя хранится в *канале*в памяти сервера. 

Ниже приведены примеры состояния, удерживаемого для канала пользователя.

* Отображаемый пользовательский&mdash;интерфейс. Иерархия экземпляров компонентов и их последние выходные данные рендеринга.
* Значения всех полей и свойств в экземплярах компонента.
* Данные, хранящиеся в экземплярах службы [внедрения зависимостей (DI)](xref:fundamentals/dependency-injection) , областью действия которых является цепь.

> [!NOTE]
> В этой статье рассматривается сохранение состояния в приложениях Блазор на стороне сервера. Клиентские приложения блазор могут использовать возможности [сохранения состояния на стороне клиента в браузере,](#client-side-in-the-browser) но для этого требуются пользовательские решения или сторонние пакеты, не описанные в этой статье.

## <a name="blazor-circuits"></a>Цепи блазор

Если пользователь испытывает временное снижение сетевого подключения, Блазор пытается повторно подключить пользователя к исходному каналу, чтобы он мог продолжать использовать приложение. Однако повторное подключение пользователя к исходному каналу в памяти сервера не всегда возможно:

* Сервер не может постоянно хранить отключенную цепь. Сервер должен освободить отключенную цепь после истечения времени ожидания или при нехватке памяти для сервера.
* В многосерверных средах развертывания с балансировкой нагрузки любые запросы на обработку сервера могут стать недоступными в любой конкретный момент времени. Отдельные серверы могут завершаться сбоем или автоматически удаляться, если они больше не требуются для обработки общего объема запросов. Исходный сервер может быть недоступен, когда пользователь пытается повторно подключиться.
* Пользователь может закрыть и снова открыть браузер или перезагрузить страницу, что приведет к удалению любого состояния, хранящегося в памяти браузера. Например, теряются значения, заданные через вызовы взаимодействия JavaScript.

Если пользователь не может повторно подключиться к исходному каналу, он получает новый канал с пустым состоянием. Это эквивалентно закрытию и повторному открытию классического приложения.

## <a name="preserve-state-across-circuits"></a>Сохранение состояния между цепями

В некоторых сценариях желательно сохранять состояние между цепями. Приложение может хранить важные данные для пользователя, если:

* Веб-сервер становится недоступным.
* Браузер пользователя вынужден начать новый канал с новым веб-сервером.

Как правило, поддержание состояния между цепями применяется к сценариям, где пользователи активно могут создавать данные, а не просто считывать уже существующие данные.

Чтобы сохранить состояние за пределами одного канала, *не храните данные в памяти сервера*. Приложение должно сохранять данные в другое место хранения. Сохранение состояния не является автоматически&mdash;. необходимо выполнить действия при разработке приложения для реализации сохраняемости данных с отслеживанием состояния.

Сохраняемость данных, как правило, требуется только для высокого значения состояния, затрачиваемого пользователями на создание. В следующих примерах сохранение состояния экономит время или средства в коммерческих действиях:

* Многоэтапная веб &ndash; -форма. это время, требующее от пользователя повторного ввода данных для нескольких завершенных шагов многоэтапного процесса, если их состояние будет потеряно. Пользователь теряет состояние в этом сценарии, если он выходит из многоэтапной формы и снова возвращается в форму.
* Корзина &ndash; для покупок. все коммерческие важные компоненты приложения, представляющие потенциальную прибыль, могут поддерживаться. Пользователь, который теряет свое состояние, и, таким же покупательскую корзину, может приобрести меньше продуктов или услуг, когда они будут возвращены на сайт позже.

Обычно нет необходимости сохранять легко воссозданное состояние, например имя пользователя, введенное в диалоговое окно входа, которое еще не было отправлено.

> [!IMPORTANT]
> Приложение может сохранять только *состояние приложения*. Пользовательские интерфейсы не могут быть сохранены, например экземпляры компонентов и их деревья отрисовки. Компоненты и деревья рендеринга обычно не являются сериализуемыми. Чтобы сохранить нечто похожее на состояние пользовательского интерфейса, например развернутые узлы TreeView, приложение должно иметь пользовательский код для моделирования поведения как сериализуемого состояния приложения.

## <a name="where-to-persist-state"></a>Место сохранения состояния

Существует три общих расположения для сохранения состояния в приложении Блазор на стороне сервера. Каждый подход лучше всего подходит для различных сценариев и имеет разные предостережения:

* [На стороне сервера в базе данных](#server-side-in-a-database)
* [URL-адрес](#url)
* [На стороне клиента в браузере](#client-side-in-the-browser)

### <a name="server-side-in-a-database"></a>На стороне сервера в базе данных

Для постоянного сохранения данных или для любых данных, которые должны охватывать несколько пользователей или устройств, Независимая база данных на стороне сервера почти наверняка является лучшим выбором. Возможны следующие значения.

* Реляционная база данных SQL
* Хранилище "ключ — значение"
* Хранилище больших двоичных объектов
* Хранилище таблиц

После сохранения данных в базе данных пользователь может запустить новый канал в любое время. Данные пользователя сохранены и доступны в любом новом канале.

Дополнительные сведения о вариантах хранения данных Azure см. в [документации по службе хранилища Azure](/azure/storage/) и в [базах данных Azure](https://azure.microsoft.com/product-categories/databases/).

### <a name="url"></a>URL-адрес

Для временных данных, представляющих состояние навигации, моделируют данные как часть URL-адреса. Ниже приведены примеры состояний, которые моделируются в URL-адресе.

* ИДЕНТИФИКАТОР просматриваемой сущности.
* Номер текущей страницы в страничной сетке.

Содержимое адресной строки браузера будет храниться:

* Если пользователь вручную перезагружает страницу.
* Если веб-сервер становится недоступным&mdash;, пользователь вынужден перезагрузить страницу, чтобы подключиться к другому серверу.

Дополнительные сведения об определении шаблонов URL-адресов `@page` с помощью директивы см. в разделе. <xref:blazor/routing>

### <a name="client-side-in-the-browser"></a>На стороне клиента в браузере

Для временных данных, создаваемых пользователем, общим резервным хранилищем является браузер `localStorage` и `sessionStorage` коллекции. Приложению не требуется управлять сохраненным состоянием или очищать его, если канал прерван, что является преимуществом для хранилища на стороне сервера.

> [!NOTE]
> "На стороне клиента" в этом разделе относится к сценариям на стороне клиента в браузере, а не к [модели размещения на стороне клиента блазор](xref:blazor/hosting-models#client-side). `localStorage`и `sessionStorage` могут использоваться в клиентских приложениях блазор, но только путем написания пользовательского кода или использования стороннего пакета.

`localStorage`и `sessionStorage` различаются следующим образом.

* `localStorage`входит в область браузера пользователя. Если пользователь перезагружает страницу или закрывает и снова открывает браузер, состояние сохраняется. Если пользователь открывает несколько вкладок браузера, это состояние совместно используется на вкладках. Данные сохраняются `localStorage` до тех пор, пока не будут явно сняты.
* `sessionStorage`входит в область вкладки браузера пользователя. Если пользователь перезагружает вкладку, состояние сохраняется. Если пользователь закрывает вкладку или браузер, состояние теряется. Если пользователь открывает несколько вкладок браузера, каждая вкладка имеет собственную независимую версию данных.

Как правило `sessionStorage` , безопаснее использовать. `sessionStorage`позволяет избежать риска, когда пользователь открывает несколько вкладок и находит следующее:

* Ошибки в хранилище состояний на вкладках.
* Путаница в работе, когда на вкладке заменяется состояние других вкладок.

`localStorage`является лучшим выбором, если приложение должно сохранять состояние в случае закрытия и повторного открытия браузера.

Предостережения при использовании хранилища браузера:

* Аналогично использованию базы данных на стороне сервера, Загрузка и сохранение данных выполняются асинхронно.
* В отличие от базы данных на стороне сервера, хранилище недоступно во время предварительной отрисовки, так как запрошенная страница не существует в браузере во время подготовки к просмотру.
* Хранение данных в нескольких килобайтах имеет смысл сохранять для приложений Блазор на стороне сервера. Помимо нескольких килобайт, необходимо учитывать последствия производительности, поскольку данные загружаются и сохраняются по сети.
* Пользователи могут просматривать данные или изменять их. ASP.NET Core [Защита данных](xref:security/data-protection/introduction) может снизить риск.

## <a name="third-party-browser-storage-solutions"></a>Сторонние решения для хранения в браузере

Сторонние пакеты NuGet предоставляют интерфейсы API для работы с `localStorage` и. `sessionStorage`

Стоит рассмотреть Выбор пакета, который прозрачно использует [защиту данных](xref:security/data-protection/introduction)ASP.NET Core. ASP.NET Core Data Protection шифрует хранимые данные и уменьшает потенциальный риск незаконного изменения хранимых данных. Если сериализованные данные JSON хранятся в виде обычного текста, пользователи могут просматривать данные с помощью средств разработчика браузера, а также изменять сохраненные данные. Защита данных не всегда является проблемой, так как данные могут быть простыми по своей природе. Например, чтение или изменение сохраненного цвета элемента пользовательского интерфейса не является серьезной угрозой безопасности для пользователя или организации. Не разрешайте пользователям проверять или изменять *конфиденциальные данные*.

## <a name="protected-browser-storage-experimental-package"></a>Экспериментальный пакет хранилища защищенного браузера

Примером пакета NuGet, обеспечивающего [защиту данных](xref:security/data-protection/introduction) для `localStorage` , `sessionStorage` является [Microsoft. AspNetCore. протектедбровсерстораже](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).

> [!WARNING]
> `Microsoft.AspNetCore.ProtectedBrowserStorage`является неподдерживаемым экспериментальным пакетом, который в настоящее время не подходит для использования в рабочей среде.

### <a name="installation"></a>Установка

Чтобы установить пакет `Microsoft.AspNetCore.ProtectedBrowserStorage` , выполните следующие действия.

1. В проекте приложения на стороне сервера Блазор добавьте ссылку на пакет в [Microsoft. AspNetCore. протектедбровсерстораже](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).
1. В HTML верхнего уровня (например, в файле *pages/_Host. cshtml* в шаблоне проекта по умолчанию) добавьте следующий `<script>` тег:

   ```html
   <script src="_content/Microsoft.AspNetCore.ProtectedBrowserStorage/protectedBrowserStorage.js"></script>
   ```

1. В методе вызовите `AddProtectedBrowserStorage` , чтобы `localStorage` добавить `sessionStorage` и службы в коллекцию служб: `Startup.ConfigureServices`

   ```csharp
   services.AddProtectedBrowserStorage();
   ```

### <a name="save-and-load-data-within-a-component"></a>Сохранение и загрузка данных в компоненте

В любом компоненте, требующем загрузки или сохранении данных в хранилище браузера [@inject](xref:blazor/dependency-injection#request-a-service-in-a-component) , используйте для вставки экземпляра одного из следующих компонентов:

* `ProtectedLocalStorage`
* `ProtectedSessionStorage`

Выбор зависит от того, какое резервное хранилище вы хотите использовать. В следующем примере `sessionStorage` используется:

```cshtml
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore
```

Инструкцию можно поместить в файл *_Imports. Razor* , а не в компонент. `@using` Использование файла *_Imports. Razor* делает пространство имен доступным для больших сегментов приложения или всего приложения.

Чтобы сохранить `currentCount` значение `Counter` в компоненте шаблона проекта, измените метод так, чтобы `IncrementCount` он использовал: `ProtectedSessionStore.SetAsync`

```csharp
private async Task IncrementCount()
{
    currentCount++;
    await ProtectedSessionStore.SetAsync("count", currentCount);
}
```

В больших и более реалистичных приложениях хранение отдельных полей является маловероятной ситуацией. Приложения, скорее всего, будут хранить все объекты модели, включающие сложное состояние. `ProtectedSessionStore`автоматически сериализует и десериализует данные JSON.

В предыдущем примере `currentCount` кода данные хранятся как `sessionStorage['count']` в браузере пользователя. Данные не хранятся в виде обычного текста, а защищены с помощью [защиты данных](xref:security/data-protection/introduction)ASP.NET Core. Зашифрованные данные могут отображаться, если `sessionStorage['count']` вычисляются в консоли разработчика браузера.

Чтобы восстановить `currentCount` данные, если пользователь снова возвращается `Counter` в компонент (в том числе если они находятся в совершенно новом канале), используйте `ProtectedSessionStore.GetAsync`:

```csharp
protected override async Task OnInitializedAsync()
{
    currentCount = await ProtectedSessionStore.GetAsync<int>("count");
}
```

Если параметры компонента включают состояние навигации, вызовите `ProtectedSessionStore.GetAsync` и назначьте результат в, а не `OnInitializedAsync`в `OnParametersSetAsync`. `OnInitializedAsync`вызывается только один раз при первом создании экземпляра компонента. `OnInitializedAsync`не вызывается позже, если пользователь переходит на другой URL-адрес, оставшийся на той же странице.

> [!WARNING]
> Примеры в этом разделе работают только в том случае, если на сервере не включено предварительное отображение. При включенной предварительной отрисовке возникает ошибка следующего вида:
>
> > В настоящее время вызовы взаимодействия JavaScript не могут быть выданы. Это связано с тем, что компонент предварительно готовится к просмотру.
>
> Отключите предварительную отрисовку или добавьте дополнительный код для работы с предварительной отрисовкой. Дополнительные сведения о написании кода, который работает с предварительной отрисовкой, см. в разделе Обработка предварительной [визуализации](#handle-prerendering) .

### <a name="handle-the-loading-state"></a>Обработано состояние загрузки

Так как хранилище браузера является асинхронным (доступное через сетевое подключение), всегда существует период времени, по истечении которого данные загружаются и доступны для использования компонентом. Для достижения лучших результатов перед отображением пустых или данных по умолчанию выводится сообщение о состоянии загрузки.

Один из подходов состоит в том, чтобы `null` определить, являются ли данные (по-прежнему загружаются). В компоненте `Counter` по умолчанию счетчик сохраняется `int`в. Добавим`?``int`значение null, добавив вопросительный знак () в тип (): `currentCount`

```csharp
private int? currentCount;
```

Вместо безусловного отображения кнопки счетчика и **увеличения** выберите отображение этих элементов только в том случае, если данные загружены:

```cshtml
@if (currentCount.HasValue)
{
    <p>Current count: <strong>@currentCount</strong></p>

    <button @onclick="IncrementCount">Increment</button>
}
else
{
    <p>Loading...</p>
}
```

### <a name="handle-prerendering"></a>Обработка предварительной визуализации

Во время предварительной подготовки:

* Интерактивное подключение к браузеру пользователя не существует.
* В браузере еще нет страницы, на которой можно запустить код JavaScript.

`localStorage`или `sessionStorage` недоступно во время предварительной подготовки. Если компонент пытается взаимодействовать с хранилищем, возникает ошибка следующего вида:

> В настоящее время вызовы взаимодействия JavaScript не могут быть выданы. Это связано с тем, что компонент предварительно готовится к просмотру.

Одним из способов устранения этой ошибки является отключение предварительной визуализации. Обычно это наилучший вариант, если приложение активно использует хранилище на основе браузера. Предварительная обработка увеличивает сложность и не дает приложению преимущества, так как приложение не может выдать какое `localStorage` - `sessionStorage` либо полезное содержимое, пока или не станет доступным.

Чтобы отключить предварительную отрисовку, выполните следующие действия.

1. Откройте файл *pages/_Host. cshtml* и удалите вызов `Html.RenderComponentAsync`.
1. Откройте файл и замените вызов `endpoints.MapBlazorHub<App>("app")`на `endpoints.MapBlazorHub()`. `Startup.cs` `App`тип корневого компонента. `"app"`— Это селектор CSS, указывающий расположение для корневого компонента.

Предварительная визуализация может быть полезной для других страниц, которые `localStorage` не `sessionStorage`используют или. Чтобы включить предварительную отрисовку, отложите операцию загрузки до тех пор, пока браузер не подключается к каналу. Ниже приведен пример хранения значения счетчика.

```cshtml
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedLocalStorage ProtectedLocalStore
@inject IComponentContext ComponentContext

... rendering code goes here ...

@code {
    private int? currentCount;
    private bool isWaitingForConnection;

    protected override async Task OnInitAsync()
    {
        if (ComponentContext.IsConnected)
        {
            // It looks like the app isn't prerendering, so the data can be
            // immediately loaded from browser storage.
            await LoadStateAsync();
        }
        else
        {
            // Prerendering is in progress, so the app defers the load operation
            // until later.
            isWaitingForConnection = true;
        }
    }

    protected override async Task OnAfterRenderAsync()
    {
        // By this stage, the client has connected back to the server, and
        // browser services are available. If the app didn't load the data earlier,
        // the app should do so now and then trigger a new render.
        if (isWaitingForConnection)
        {
            isWaitingForConnection = false;
            await LoadStateAsync();
            StateHasChanged();
        }
    }

    private async Task LoadStateAsync()
    {
        currentCount = await ProtectedLocalStore.GetAsync<int>("prerenderedCount");
    }

    private async Task IncrementCount()
    {
        currentCount++;
        await ProtectedSessionStore.SetAsync("count", currentCount);
    }
}
```

### <a name="factor-out-the-state-preservation-to-a-common-location"></a>Разнесите сохранение состояния в общее расположение

Если многие компоненты используют хранилище на основе браузера, повторная реализация кода поставщика состояний много раз создает дублирование кода. Одним из вариантов предотвращения дублирования кода является создание *родительского компонента поставщика состояний* , который инкапсулирует логику поставщика состояний. Дочерние компоненты могут работать с сохраненными данными без учета механизма сохранения состояния.

В следующем примере `CounterStateProvider` компонента данные счетчика сохраняются:

```cshtml
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore

@if (hasLoaded)
{
    <CascadingValue Value="@this">
        @ChildContent
    </CascadingValue>
}
else
{
    <p>Loading...</p>
}

@code {
    private bool hasLoaded;

    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public int CurrentCount { get; set; }

    protected override async Task OnInitAsync()
    {
        CurrentCount = await ProtectedSessionStore.GetAsync<int>("count");
        hasLoaded = true;
    }

    public async Task SaveChangesAsync()
    {
        await ProtectedSessionStore.SetAsync("count", CurrentCount);
    }
}
```

`CounterStateProvider` Компонент обрабатывает этап загрузки, не выполняя отрисовку его дочернего содержимого до завершения загрузки.

Чтобы использовать `CounterStateProvider` компонент, заключите экземпляр компонента в оболочку для любого другого компонента, который требует доступа к состоянию счетчика. Чтобы сделать состояние доступным для всех компонентов `CounterStateProvider` в приложении, заключите компонент `Router` в `App` компонент (*app. Razor*):

```cshtml
<CounterStateProvider>
    <Router AppAssembly="typeof(Startup).Assembly">
        ...
    </Router>
</CounterStateProvider>
```

Упакованные компоненты получают и могут изменять состояние сохраненного счетчика. Следующий `Counter` компонент реализует шаблон:

```cshtml
@page "/counter"

<p>Current count: <strong>@CounterStateProvider.CurrentCount</strong></p>

<button @onclick="IncrementCount">Increment</button>

@code {
    [CascadingParameter]
    private CounterStateProvider CounterStateProvider { get; set; }

    private async Task IncrementCount()
    {
        CounterStateProvider.CurrentCount++;
        await CounterStateProvider.SaveChangesAsync();
    }
}
```

Предыдущий компонент не обязательно должен взаимодействовать с `ProtectedBrowserStorage`, а также с этапом загрузки.

Чтобы обработать предварительную отрисовку, как описано выше `CounterStateProvider` , можно внести изменения, чтобы все компоненты, использующие данные счетчика, автоматически работали с предварительной отрисовкой. Дополнительные сведения см. в разделе Обработка предварительной [подготовки](#handle-prerendering) к просмотру.

В общем случае рекомендуется использовать родительский шаблон *компонента поставщика состояний* :

* Для использования состояния во многих других компонентах.
* Если имеется только один объект состояния верхнего уровня для сохранения.

Чтобы сохранить множество различных объектов состояния и использовать разные подмножества объектов в разных местах, лучше избегать обработки загрузки и сохранения состояния глобально.
