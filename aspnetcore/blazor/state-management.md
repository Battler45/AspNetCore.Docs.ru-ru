---
title: Управление состоянием Blazor ASP.NET Core
author: guardrex
description: Узнайте, как сохранить состояние в приложениях Blazor Server.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 12/18/2019
no-loc:
- Blazor
- SignalR
uid: blazor/state-management
ms.openlocfilehash: 990d392b0e1658774256626eb277701e40287b79
ms.sourcegitcommit: eca76bd065eb94386165a0269f1e95092f23fa58
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76726909"
---
# <a name="aspnet-core-opno-locblazor-state-management"></a>Управление состоянием Blazor ASP.NET Core

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

Blazor Server — это платформа приложений с отслеживанием состояния. В большинстве случаев приложение поддерживает текущее подключение к серверу. Состояние пользователя хранится в *канале*в памяти сервера. 

Ниже приведены примеры состояния, удерживаемого для канала пользователя.

* Готовый к просмотру пользовательский интерфейс&mdash;иерархию экземпляров компонента и их последних выходных данных рендеринга.
* Значения всех полей и свойств в экземплярах компонента.
* Данные, хранящиеся в экземплярах службы [внедрения зависимостей (DI)](xref:fundamentals/dependency-injection) , областью действия которых является цепь.

> [!NOTE]
> В этой статье рассматривается сохранение состояния в приложениях Blazor Server. Blazor приложения веб-сборки могут использовать возможности [сохраняемости состояния на стороне клиента в браузере, но при](#client-side-in-the-browser) этом требуются пользовательские решения или сторонние пакеты вне области этой статьи.

## <a name="opno-locblazor-circuits"></a>Blazorные цепи

Если пользователь испытывает временное снижение сетевого подключения, Blazor пытается повторно подключить пользователя к исходному каналу, чтобы они могли продолжать использовать приложение. Однако повторное подключение пользователя к исходному каналу в памяти сервера не всегда возможно:

* Сервер не может постоянно хранить отключенную цепь. Сервер должен освободить отключенную цепь после истечения времени ожидания или при нехватке памяти для сервера.
* В многосерверных средах развертывания с балансировкой нагрузки любые запросы на обработку сервера могут стать недоступными в любой конкретный момент времени. Отдельные серверы могут завершаться сбоем или автоматически удаляться, если они больше не требуются для обработки общего объема запросов. Исходный сервер может быть недоступен, когда пользователь пытается повторно подключиться.
* Пользователь может закрыть и снова открыть браузер или перезагрузить страницу, что приведет к удалению любого состояния, хранящегося в памяти браузера. Например, теряются значения, заданные через вызовы взаимодействия JavaScript.

Если пользователь не может повторно подключиться к исходному каналу, он получает новый канал с пустым состоянием. Это эквивалентно закрытию и повторному открытию классического приложения.

## <a name="preserve-state-across-circuits"></a>Сохранение состояния между цепями

В некоторых сценариях желательно сохранять состояние между цепями. Приложение может хранить важные данные для пользователя, если:

* Веб-сервер становится недоступным.
* Браузер пользователя вынужден начать новый канал с новым веб-сервером.

Как правило, поддержание состояния между цепями применяется к сценариям, где пользователи активно могут создавать данные, а не просто считывать уже существующие данные.

Чтобы сохранить состояние за пределами одного канала, *не храните данные в памяти сервера*. Приложение должно сохранять данные в другое место хранения. Сохраняемость состояния не является автоматически&mdash;необходимо выполнить действия при разработке приложения для реализации сохраняемости данных с отслеживанием состояния.

Сохраняемость данных, как правило, требуется только для высокого значения состояния, затрачиваемого пользователями на создание. В следующих примерах сохранение состояния экономит время или средства в коммерческих действиях:

* Многошаговая веб-форма &ndash; время, требующее от пользователя повторно вводить данные для нескольких завершенных шагов многоэтапного процесса, если их состояние теряется. Пользователь теряет состояние в этом сценарии, если он выходит из многоэтапной формы и снова возвращается в форму.
* Покупательская корзина &ndash; любой коммерческий важный компонент приложения, который представляет потенциальную прибыль. Пользователь, который теряет свое состояние, и, таким же покупательскую корзину, может приобрести меньше продуктов или услуг, когда они будут возвращены на сайт позже.

Обычно нет необходимости сохранять легко воссозданное состояние, например имя пользователя, введенное в диалоговое окно входа, которое еще не было отправлено.

> [!IMPORTANT]
> Приложение может сохранять только *состояние приложения*. Пользовательские интерфейсы не могут быть сохранены, например экземпляры компонентов и их деревья отрисовки. Компоненты и деревья рендеринга обычно не являются сериализуемыми. Чтобы сохранить нечто похожее на состояние пользовательского интерфейса, например развернутые узлы TreeView, приложение должно иметь пользовательский код для моделирования поведения как сериализуемого состояния приложения.

## <a name="where-to-persist-state"></a>Место сохранения состояния

Существует три общих расположения для сохранения состояния в приложении Blazor Server. Каждый подход лучше всего подходит для различных сценариев и имеет разные предостережения:

* [На стороне сервера в базе данных](#server-side-in-a-database)
* [URL](#url)
* [На стороне клиента в браузере](#client-side-in-the-browser)

### <a name="server-side-in-a-database"></a>На стороне сервера в базе данных

Для постоянного сохранения данных или для любых данных, которые должны охватывать несколько пользователей или устройств, Независимая база данных на стороне сервера почти наверняка является лучшим выбором. Возможны следующие значения.

* Реляционная база данных SQL
* Хранилище ключ-значение
* Хранилище больших двоичных объектов
* Хранилище таблиц

После сохранения данных в базе данных пользователь может запустить новый канал в любое время. Данные пользователя сохранены и доступны в любом новом канале.

Дополнительные сведения о вариантах хранения данных Azure см. в [документации по службе хранилища Azure](/azure/storage/) и в [базах данных Azure](https://azure.microsoft.com/product-categories/databases/).

### <a name="url"></a>URL-адрес

Для временных данных, представляющих состояние навигации, моделируют данные как часть URL-адреса. Ниже приведены примеры состояний, которые моделируются в URL-адресе.

* ИДЕНТИФИКАТОР просматриваемой сущности.
* Номер текущей страницы в страничной сетке.

Содержимое адресной строки браузера будет храниться:

* Если пользователь вручную перезагружает страницу.
* Если веб-сервер становится недоступным&mdash;пользователь вынужден перезагрузить страницу, чтобы подключиться к другому серверу.

Сведения об определении шаблонов URL-адресов с помощью директивы `@page` см. в разделе <xref:blazor/routing>.

### <a name="client-side-in-the-browser"></a>На стороне клиента в браузере

Для временных данных, создаваемых пользователем, общим резервным хранилищем являются коллекции `localStorage` и `sessionStorage` браузера. Приложению не требуется управлять сохраненным состоянием или очищать его, если канал прерван, что является преимуществом для хранилища на стороне сервера.

> [!NOTE]
> "На стороне клиента" в этом разделе относится к сценариям на стороне клиента в браузере, а не [Blazor модели размещения](xref:blazor/hosting-models#blazor-webassembly)веб-сборки. `localStorage` и `sessionStorage` можно использовать в Blazor приложениях веб-сборки, но только путем написания пользовательского кода или использования стороннего пакета.

`localStorage` и `sessionStorage` различаются следующим образом.

* `localStorage` ограничивается браузером пользователя. Если пользователь перезагружает страницу или закрывает и снова открывает браузер, состояние сохраняется. Если пользователь открывает несколько вкладок браузера, это состояние совместно используется на вкладках. Данные сохраняются в `localStorage` до тех пор, пока не будет явно сброшен.
* `sessionStorage` ограничивается на вкладке браузера пользователя. Если пользователь перезагружает вкладку, состояние сохраняется. Если пользователь закрывает вкладку или браузер, состояние теряется. Если пользователь открывает несколько вкладок браузера, каждая вкладка имеет собственную независимую версию данных.

Как правило, `sessionStorage` более безопасна для использования. `sessionStorage` позволяет избежать риска, когда пользователь открывает несколько вкладок и обнаруживает следующее:

* Ошибки в хранилище состояний на вкладках.
* Путаница в работе, когда на вкладке заменяется состояние других вкладок.

`localStorage` является лучшим выбором, если приложение должно сохранять состояние в случае закрытия и повторного открытия браузера.

Предостережения при использовании хранилища браузера:

* Аналогично использованию базы данных на стороне сервера, Загрузка и сохранение данных выполняются асинхронно.
* В отличие от базы данных на стороне сервера, хранилище недоступно во время предварительной отрисовки, так как запрошенная страница не существует в браузере во время подготовки к просмотру.
* Хранение данных в нескольких килобайтах имеет смысл сохранять для Blazor серверных приложений. Помимо нескольких килобайт, необходимо учитывать последствия производительности, поскольку данные загружаются и сохраняются по сети.
* Пользователи могут просматривать данные или изменять их. ASP.NET Core [Защита данных](xref:security/data-protection/introduction) может снизить риск.

## <a name="third-party-browser-storage-solutions"></a>Сторонние решения для хранения в браузере

Сторонние пакеты NuGet предоставляют интерфейсы API для работы с `localStorage` и `sessionStorage`.

Стоит рассмотреть Выбор пакета, который прозрачно использует [защиту данных](xref:security/data-protection/introduction)ASP.NET Core. ASP.NET Core Data Protection шифрует хранимые данные и уменьшает потенциальный риск незаконного изменения хранимых данных. Если сериализованные данные JSON хранятся в виде обычного текста, пользователи могут просматривать данные с помощью средств разработчика браузера, а также изменять сохраненные данные. Защита данных не всегда является проблемой, так как данные могут быть простыми по своей природе. Например, чтение или изменение сохраненного цвета элемента пользовательского интерфейса не является серьезной угрозой безопасности для пользователя или организации. Не разрешайте пользователям проверять или изменять *конфиденциальные данные*.

## <a name="protected-browser-storage-experimental-package"></a>Экспериментальный пакет хранилища защищенного браузера

Примером пакета NuGet, обеспечивающего [защиту данных](xref:security/data-protection/introduction) для `localStorage` и `sessionStorage`, является [Microsoft. AspNetCore. протектедбровсерстораже](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).

> [!WARNING]
> `Microsoft.AspNetCore.ProtectedBrowserStorage` является неподдерживаемым экспериментальным пакетом, который в настоящее время не подходит для использования в рабочей среде.

### <a name="installation"></a>Установка

Чтобы установить пакет `Microsoft.AspNetCore.ProtectedBrowserStorage`, выполните следующие действия.

1. В проекте приложения Blazor Server добавьте ссылку на пакет в [Microsoft. AspNetCore. протектедбровсерстораже](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).
1. В HTML верхнего уровня (например, в файле *pages/_Host. cshtml* в шаблоне проекта по умолчанию) добавьте следующий тег `<script>`:

   ```html
   <script src="_content/Microsoft.AspNetCore.ProtectedBrowserStorage/protectedBrowserStorage.js"></script>
   ```

1. В методе `Startup.ConfigureServices` вызовите `AddProtectedBrowserStorage`, чтобы добавить службы `localStorage` и `sessionStorage` в коллекцию служб:

   ```csharp
   services.AddProtectedBrowserStorage();
   ```

### <a name="save-and-load-data-within-a-component"></a>Сохранение и загрузка данных в компоненте

В любом компоненте, требующем загрузки или сохранении данных в хранилище браузера, используйте [`@inject`](xref:blazor/dependency-injection#request-a-service-in-a-component) для вставки экземпляра одного из следующих компонентов:

* `ProtectedLocalStorage`
* `ProtectedSessionStorage`

Выбор зависит от того, какое резервное хранилище вы хотите использовать. В следующем примере используется `sessionStorage`:

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore
```

Инструкцию `@using` можно поместить в файл *_Imports. Razor* , а не в компонент. Использование файла *_Imports. Razor* делает пространство имен доступным для больших сегментов приложения или всего приложения.

Чтобы сохранить значение `_currentCount` в `Counter` компоненте шаблона проекта, измените метод `IncrementCount` для использования `ProtectedSessionStore.SetAsync`:

```csharp
private async Task IncrementCount()
{
    _currentCount++;
    await ProtectedSessionStore.SetAsync("count", _currentCount);
}
```

В больших и более реалистичных приложениях хранение отдельных полей является маловероятной ситуацией. Приложения, скорее всего, будут хранить все объекты модели, включающие сложное состояние. `ProtectedSessionStore` автоматически сериализует и десериализует данные JSON.

В предыдущем примере кода `_currentCount` данные хранятся в виде `sessionStorage['count']` в браузере пользователя. Данные не хранятся в виде обычного текста, а защищены с помощью [защиты данных](xref:security/data-protection/introduction)ASP.NET Core. Зашифрованные данные можно увидеть, если `sessionStorage['count']` вычисляется в консоли разработчика браузера.

Чтобы восстановить данные `_currentCount`, если пользователь снова возвращается в компонент `Counter` (в том числе если они находятся в совершенно новом канале), используйте `ProtectedSessionStore.GetAsync`:

```csharp
protected override async Task OnInitializedAsync()
{
    _currentCount = await ProtectedSessionStore.GetAsync<int>("count");
}
```

Если параметры компонента включают состояние навигации, вызовите `ProtectedSessionStore.GetAsync` и назначьте результат в `OnParametersSetAsync`, а не `OnInitializedAsync`. `OnInitializedAsync` вызывается только один раз при первом создании экземпляра компонента. `OnInitializedAsync` снова вызывается позже, если пользователь переходит на другой URL-адрес, оставшийся на той же странице. Дополнительные сведения см. в разделе <xref:blazor/lifecycle>.

> [!WARNING]
> Примеры в этом разделе работают только в том случае, если на сервере не включено предварительное отображение. При включенной предварительной отрисовке возникает ошибка следующего вида:
>
> > В настоящее время вызовы взаимодействия JavaScript не могут быть выданы. Это связано с тем, что компонент предварительно готовится к просмотру.
>
> Отключите предварительную отрисовку или добавьте дополнительный код для работы с предварительной отрисовкой. Дополнительные сведения о написании кода, который работает с предварительной отрисовкой, см. в разделе Обработка предварительной [визуализации](#handle-prerendering) .

### <a name="handle-the-loading-state"></a>Обработано состояние загрузки

Так как хранилище браузера является асинхронным (доступное через сетевое подключение), всегда существует период времени, по истечении которого данные загружаются и доступны для использования компонентом. Для достижения лучших результатов перед отображением пустых или данных по умолчанию выводится сообщение о состоянии загрузки.

Один из подходов состоит в том, чтобы определить, `null` ли данные (все еще загружаются). В компоненте `Counter` по умолчанию количество хранится в `int`. Внесите `_currentCount` Nullable, добавив вопросительный знак (`?`) к типу (`int`):

```csharp
private int? _currentCount;
```

Вместо безусловного отображения кнопки счетчика и **увеличения** выберите отображение этих элементов только в том случае, если данные загружены:

```razor
@if (_currentCount.HasValue)
{
    <p>Current count: <strong>@_currentCount</strong></p>

    <button @onclick="IncrementCount">Increment</button>
}
else
{
    <p>Loading...</p>
}
```

### <a name="handle-prerendering"></a>Обработка предварительной визуализации

Во время предварительной подготовки:

* Интерактивное подключение к браузеру пользователя не существует.
* В браузере еще нет страницы, на которой можно запустить код JavaScript.

`localStorage` или `sessionStorage` недоступны во время предварительной подготовки к просмотру. Если компонент пытается взаимодействовать с хранилищем, возникает ошибка следующего вида:

> В настоящее время вызовы взаимодействия JavaScript не могут быть выданы. Это связано с тем, что компонент предварительно готовится к просмотру.

Одним из способов устранения этой ошибки является отключение предварительной визуализации. Обычно это наилучший вариант, если приложение активно использует хранилище на основе браузера. Предварительная обработка увеличивает сложность и не дает приложению никаких преимуществ, так как приложение не может выдать какое-либо полезное содержимое, пока не будут доступны `localStorage` или `sessionStorage`.

Чтобы отключить предварительную отрисовку, откройте файл *pages/_Host. cshtml* и измените вызов `render-mode` вспомогательной функции тега `Component` на `Server`.

Предварительная визуализация может быть полезной для других страниц, которые не используют `localStorage` или `sessionStorage`. Чтобы включить предварительную отрисовку, отложите операцию загрузки до тех пор, пока браузер не подключается к каналу. Ниже приведен пример хранения значения счетчика.

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedLocalStorage ProtectedLocalStore

... rendering code goes here ...

@code {
    private int? _currentCount;
    private bool _isConnected = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // When execution reaches this point, the first *interactive* render
            // is complete. The component has an active connection to the browser.
            _isConnected = true;
            await LoadStateAsync();
            StateHasChanged();
        }
    }

    private async Task LoadStateAsync()
    {
        _currentCount = await ProtectedLocalStore.GetAsync<int>("prerenderedCount");
    }

    private async Task IncrementCount()
    {
        _currentCount++;
        await ProtectedSessionStore.SetAsync("count", _currentCount);
    }
}
```

### <a name="factor-out-the-state-preservation-to-a-common-location"></a>Разнесите сохранение состояния в общее расположение

Если многие компоненты используют хранилище на основе браузера, повторная реализация кода поставщика состояний много раз создает дублирование кода. Одним из вариантов предотвращения дублирования кода является создание *родительского компонента поставщика состояний* , который инкапсулирует логику поставщика состояний. Дочерние компоненты могут работать с сохраненными данными без учета механизма сохранения состояния.

В следующем примере компонента `CounterStateProvider` данные счетчика сохраняются:

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore

@if (_hasLoaded)
{
    <CascadingValue Value="@this">
        @ChildContent
    </CascadingValue>
}
else
{
    <p>Loading...</p>
}

@code {
    private bool _hasLoaded;

    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public int CurrentCount { get; set; }

    protected override async Task OnInitializedAsync()
    {
        CurrentCount = await ProtectedSessionStore.GetAsync<int>("count");
        _hasLoaded = true;
    }

    public async Task SaveChangesAsync()
    {
        await ProtectedSessionStore.SetAsync("count", CurrentCount);
    }
}
```

Компонент `CounterStateProvider` обрабатывает этап загрузки, не выполняя отрисовку его дочернего содержимого до завершения загрузки.

Чтобы использовать компонент `CounterStateProvider`, заключите экземпляр компонента в оболочку для любого другого компонента, который требует доступа к состоянию счетчика. Чтобы сделать состояние доступным для всех компонентов в приложении, заключите `CounterStateProvider` компонент вокруг `Router` в компоненте `App` (*app. Razor*):

```razor
<CounterStateProvider>
    <Router AppAssembly="typeof(Startup).Assembly">
        ...
    </Router>
</CounterStateProvider>
```

Упакованные компоненты получают и могут изменять состояние сохраненного счетчика. Следующий компонент `Counter` реализует шаблон:

```razor
@page "/counter"

<p>Current count: <strong>@CounterStateProvider.CurrentCount</strong></p>

<button @onclick="IncrementCount">Increment</button>

@code {
    [CascadingParameter]
    private CounterStateProvider CounterStateProvider { get; set; }

    private async Task IncrementCount()
    {
        CounterStateProvider.CurrentCount++;
        await CounterStateProvider.SaveChangesAsync();
    }
}
```

Предыдущий компонент не требуется для взаимодействия с `ProtectedBrowserStorage`, а также с этапом загрузки.

Для работы с предварительным отображением, как описано выше, `CounterStateProvider` можно исправить, чтобы все компоненты, использующие данные счетчика, автоматически работали с предварительной отрисовкой. Дополнительные сведения см. в разделе Обработка предварительной [подготовки к просмотру](#handle-prerendering) .

В общем случае рекомендуется использовать *родительский шаблон компонента поставщика состояний* :

* Для использования состояния во многих других компонентах.
* Если имеется только один объект состояния верхнего уровня для сохранения.

Чтобы сохранить множество различных объектов состояния и использовать разные подмножества объектов в разных местах, лучше избегать обработки загрузки и сохранения состояния глобально.
