---
title: ASP.NET Core Blazor сложных сценариев
author: guardrex
description: Дополнительные сведения о сложных сценариях в Blazor, в том числе о том, как включить логику Рендертрибуилдер вручную в приложение.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 02/12/2020
no-loc:
- Blazor
- SignalR
uid: blazor/advanced-scenarios
ms.openlocfilehash: 5e0618faa7b1b5e4cc15e30d9c16afaf7ccabaf0
ms.sourcegitcommit: 6645435fc8f5092fc7e923742e85592b56e37ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77453184"
---
# <a name="aspnet-core-blazor-advanced-scenarios"></a>ASP.NET Core Блазор сложные сценарии

[Люк ЛаСаМ](https://github.com/guardrex) и [Даниэль Roth)](https://github.com/danroth27)

## <a name="manual-rendertreebuilder-logic"></a>Логика Рендертрибуилдер вручную

`Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder` предоставляет методы для управления компонентами и элементами, включая создание компонентов вручную в C# коде.

> [!NOTE]
> Использование `RenderTreeBuilder` для создания компонентов является расширенным сценарием. Неправильно сформированный компонент (например, незакрытый тег разметки) может привести к неопределенному поведению.

Рассмотрим следующий компонент `PetDetails`, который можно вручную встроить в другой компонент:

```razor
<h2>Pet Details Component</h2>

<p>@PetDetailsQuote</p>

@code
{
    [Parameter]
    public string PetDetailsQuote { get; set; }
}
```

В следующем примере цикл в методе `CreateComponent` создает три `PetDetails` компонентов. При вызове методов `RenderTreeBuilder` для создания компонентов (`OpenComponent` и `AddAttribute`) порядковые номера представляют собой номера строк исходного кода. Алгоритм разницы Блазор зависит от порядковых номеров, соответствующих разным строкам кода, а не отдельных вызовов вызова. При создании компонента с помощью методов `RenderTreeBuilder` жестко указывайте аргументы для порядковых номеров. **Использование вычисления или счетчика для формирования порядкового номера может привести к снижению производительности.** Дополнительные сведения см. в разделе [порядковые номера относятся к разделу номера строк кода и порядок выполнения](#sequence-numbers-relate-to-code-line-numbers-and-not-execution-order) .

`BuiltContent` компонент:

```razor
@page "/BuiltContent"

<h1>Build a component</h1>

@CustomRender

<button type="button" @onclick="RenderComponent">
    Create three Pet Details components
</button>

@code {
    private RenderFragment CustomRender { get; set; }
    
    private RenderFragment CreateComponent() => builder =>
    {
        for (var i = 0; i < 3; i++) 
        {
            builder.OpenComponent(0, typeof(PetDetails));
            builder.AddAttribute(1, "PetDetailsQuote", "Someone's best friend!");
            builder.CloseComponent();
        }
    };    
    
    private void RenderComponent()
    {
        CustomRender = CreateComponent();
    }
}
```

> [!WARNING]
> Типы в `Microsoft.AspNetCore.Components.RenderTree` позволяют обрабатывать *результаты* операций отрисовки. Это внутренние сведения о реализации Блазор Framework. Эти типы следует считать *нестабильными* и могут быть изменены в будущих выпусках.

### <a name="sequence-numbers-relate-to-code-line-numbers-and-not-execution-order"></a>Порядковые номера связаны с номерами строк кода, а не с порядком выполнения

Файлы компонентов Razor ( *. Razor*) всегда компилируются. Компиляция — это потенциальное преимущество для интерпретации кода, поскольку шаг компиляции можно использовать для вставки сведений, повышающих производительность приложения во время выполнения.

В качестве ключевого примера этих усовершенствований используются *порядковые номера*. Порядковые номера указывают среде выполнения, какие выходные данные поступили из разных и упорядоченных строк кода. Среда выполнения использует эти сведения для создания эффективных различий дерева в линейное время, что является гораздо быстрее, чем обычно возможно для общего алгоритма различения дерева.

Рассмотрим следующий файл компонента Razor ( *. Razor*):

```razor
@if (someFlag)
{
    <text>First</text>
}

Second
```

Предыдущий код компилируется примерно следующим образом:

```csharp
if (someFlag)
{
    builder.AddContent(0, "First");
}

builder.AddContent(1, "Second");
```

Когда код выполняется в первый раз, если `someFlag` `true`, построитель получит следующее:

| Последовательность | Тип      | Данные   |
| :------: | --------- | :----: |
| 0        | Узел Text | Первый  |
| 1        | Узел Text | Секунда |

Представьте, что `someFlag` становится `false`, и разметка снова готовится к просмотру. На этот раз построитель получит:

| Последовательность | Тип       | Данные   |
| :------: | ---------- | :----: |
| 1        | Узел Text  | Секунда |

Когда среда выполнения выполняет поиск различий, она видит, что элемент в последовательности `0` был удален, поэтому он создает следующий тривиальный *сценарий редактирования*:

* Удалите первый текстовый узел.

### <a name="the-problem-with-generating-sequence-numbers-programmatically"></a>Проблема с созданием порядковых номеров программным способом

Вместо этого Представьте себе, что вы написали следующую логику конструктора деревьев визуализации:

```csharp
var seq = 0;

if (someFlag)
{
    builder.AddContent(seq++, "First");
}

builder.AddContent(seq++, "Second");
```

Теперь первые выходные данные:

| Последовательность | Тип      | Данные   |
| :------: | --------- | :----: |
| 0        | Узел Text | Первый  |
| 1        | Узел Text | Секунда |

Этот результат идентичен предыдущему случаю, поэтому отрицательные проблемы не возникают. во второй отрисовке `someFlag` `false`, а выходные данные:

| Последовательность | Тип      | Данные   |
| :------: | --------- | ------ |
| 0        | Узел Text | Секунда |

На этот раз алгоритм diff видит, что были внесены *два* изменения, и алгоритм создает следующий сценарий редактирования:

* Измените значение первого текстового узла на `Second`.
* Удалите второй текстовый узел.

При формировании порядковых номеров теряются все полезные сведения о том, где в исходном коде находятся `if/else` ветви и циклы. Это приводит к **удвоению в два раза больше** , чем раньше.

Это тривиальный пример. В более реалистичных случаях со сложными и глубокими вложенными структурами, особенно с циклами, затраты на производительность обычно выше. Вместо того, чтобы сразу определять, какие блоки или ветви цикла были вставлены или удалены, алгоритм diff должен выполнять рекурсивный глубокий переход к деревьям отрисовки. Это, как правило, приводит к более длительному изменению скриптов, поскольку алгоритм diff сообщает о том, как старые и новые структуры связаны друг с другом.

### <a name="guidance-and-conclusions"></a>Руководство и выводы

* Производительность приложения снижается, если порядковые номера создаются динамически.
* Платформа не может автоматически создавать собственные порядковые номера во время выполнения, поскольку необходимая информация не существует, если она не захвачена во время компиляции.
* Не записывайте длинные блоки `RenderTreeBuilder` логики, реализуемой вручную. Предпочитать файлы *Razor* и позволяют компилятору работать с порядковыми номерами. Если не удается избежать ручного `RenderTreeBuilder` логики, разделите длинные блоки кода на более мелкие части, заключенные в `OpenRegion`/`CloseRegion` вызовы. Каждый регион имеет собственное отдельное пространство порядковых номеров, поэтому вы можете перезапускаться от нуля (или любого другого произвольного числа) внутри каждого региона.
* Если порядковые номера задаются жестко, то для алгоритма diff требуется, чтобы только порядковые номера увеличиваются в значении. Начальное значение и зазоры несущественны. Один из этих вариантов — использовать номер строки кода в качестве порядкового номера или начать с нуля и увеличить на единицу или сотни (или любой другой интервал). 
* Blazor использует порядковые номера, в то время как другие платформы, использующие средства различения дерева, не используют их. Сравнение выполняется гораздо быстрее, если используются порядковые номера, и Blazor имеет преимущество этапа компиляции, который автоматически обрабатывает порядковые номера для разработчиков, занимающихся созданием файлов *Razor* .
