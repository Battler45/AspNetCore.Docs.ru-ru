---
title: Обработку ошибок в ASP.NET Core Блазор Apps
author: guardrex
description: Узнайте, как ASP.NET Core Блазор, как Блазор управляет необработанными исключениями и как разрабатывать приложения, которые обнаруживают и обрабатывают ошибки.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 08/06/2019
uid: blazor/handle-errors
ms.openlocfilehash: 52f55af99881b09c84d9cf88f5845efcb1ea76a1
ms.sourcegitcommit: 776367717e990bdd600cb3c9148ffb905d56862d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/09/2019
ms.locfileid: "68948454"
---
# <a name="handle-errors-in-aspnet-core-blazor-apps"></a>Обработку ошибок в ASP.NET Core Блазор Apps

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

В этой статье описывается, как Блазор управляет необработанными исключениями и разрабатывает приложения, которые обнаруживают и обрабатывают ошибки.

## <a name="how-the-blazor-framework-reacts-to-unhandled-exceptions"></a>Как платформа Блазор реагирует на необработанные исключения

Блазор на стороне сервера — это платформа с отслеживанием состояния. Хотя пользователи взаимодействуют с приложением, они сохраняют подключение к серверу, известному как *канал*. Канал содержит экземпляры активных компонентов, а также многие другие аспекты состояния, например:

* Последние отображаемые выходные данные компонентов.
* Текущий набор делегатов обработки событий, которые могут вызываться событиями на стороне клиента.

Если пользователь открывает приложение на нескольких вкладках браузера, у него есть несколько независимых цепей.

Блазор обрабатывает большинство необработанных исключений как неустранимые для канала, где они происходят. Если канал завершается из-за необработанного исключения, пользователь может продолжить взаимодействие с приложением только путем перезагрузки страницы для создания нового канала. Цепи за пределами того, что прерывается, являются цепями для других пользователей или других вкладок браузера, не затрагиваются. Этот сценарий похож на классическое приложение, которое аварийно&mdash;завершает работу из-за сбоя приложения, но другие приложения не затрагиваются.

Цепь завершается, когда необработанное исключение возникает по следующим причинам:

* Необработанное исключение часто оставляет цепь в неопределенном состоянии.
* Нормальная работа приложения не может быть гарантирована после необработанного исключения.
* В случае продолжения канала в приложении могут появиться уязвимости системы безопасности.

## <a name="manage-unhandled-exceptions-in-developer-code"></a>Управление необработанными исключениями в коде разработчика

Чтобы продолжить работу приложения после возникновения ошибки, приложение должно иметь логику обработки ошибок. В последующих разделах этой статьи описываются потенциальные источники необработанных исключений.

В рабочей среде не следует отображать сообщения об исключениях инфраструктуры или трассировки стека в пользовательском интерфейсе. Отрисовка сообщений об исключениях или трассировок стека может:

* Раскрывать конфиденциальные сведения конечным пользователям.
* Помогите злонамеренному пользователю обнаружить слабые места в приложении, которое может нарушить безопасность приложения, сервера или сети.

## <a name="log-errors-with-a-persistent-provider"></a>Регистрация ошибок с помощью постоянного поставщика

При возникновении необработанного исключения исключение регистрируется <xref:Microsoft.Extensions.Logging.ILogger> в экземплярах, настроенных в контейнере службы. По умолчанию приложения Блазор записывает выходные данные в консоль с помощью поставщика ведения журнала консоли. Рассмотрите возможность входа в более постоянное расположение с поставщиком, который управляет размером журнала и поворотом журнала. Дополнительные сведения см. в разделе <xref:fundamentals/logging/index>.

Во время разработки Блазор обычно отправляет полные сведения об исключениях в консоль браузера для облегчения отладки. В рабочей среде подробные ошибки в консоли браузера по умолчанию отключены, что означает, что ошибки не отправляются клиентам, но все сведения об исключении все еще регистрируются на стороне сервера. Дополнительные сведения см. в разделе <xref:fundamentals/error-handling>.

Необходимо решить, какие инциденты следует заносить в журнал, и уровень серьезности регистрируемых инцидентов. Злонамеренные пользователи могут попытаться вызывать ошибки намеренно. Например, не заносить инцидент в журнал с ошибкой, когда в `ProductId` URL-адресе компонента, отображающего сведения о продукте, указан неизвестный объект. Не все ошибки следует рассматривать как инциденты высокой серьезности для ведения журнала.

## <a name="places-where-errors-may-occur"></a>Места, где могут возникнуть ошибки

Код платформы и приложения может вызывать необработанные исключения в любом из следующих расположений:

* [Создание экземпляра компонента](#component-instantiation)
* [Методы жизненного цикла](#lifecycle-methods)
* [Логика отрисовки](#rendering-logic)
* [Обработчики событий](#event-handlers)
* [Реализация компонента](#component-disposal)
* [Взаимодействие JavaScript](#javascript-interop)
* [Обработчики цепи](#circuit-handlers)
* [Реализация цепи](#circuit-disposal)
* [Предварительная подготовка](#prerendering)

Предыдущие необработанные исключения описаны в следующих разделах этой статьи.

### <a name="component-instantiation"></a>Создание экземпляра компонента

Когда Блазор создает экземпляр компонента:

* Вызывается конструктор компонента.
* Вызываются конструкторы любых неsingletonных служб di, предоставляемых конструктору компонента через [@inject](xref:blazor/dependency-injection#request-a-service-in-a-component) директиву или атрибут [[внедрить]](xref:blazor/dependency-injection#request-a-service-in-a-component) . 

Сбой канала, когда любой выполненный конструктор или метод задания для любого `[Inject]` свойства вызывает необработанное исключение. Исключение является неустранимым, так как платформе не удается создать экземпляр компонента. Если логика конструктора может вызывать исключения, приложение должно выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

### <a name="lifecycle-methods"></a>Методы жизненного цикла

В течение времени существования компонента Блазор вызывает методы жизненного цикла:

* `OnInitialized` / `OnInitializedAsync`
* `OnParametersSet` / `OnParametersSetAsync`
* `ShouldRender` / `ShouldRenderAsync`
* `OnAfterRender` / `OnAfterRenderAsync`

Если какой-либо метод жизненного цикла вызывает исключение синхронно или асинхронно, исключение является неустранимым для канала. Для компонентов, обрабатывающих ошибки в методах жизненного цикла, добавьте логику обработки ошибок.

В следующем примере `OnParametersSetAsync` вызывается метод для получения продукта:

* `ProductRepository.GetProductByIdAsync` Исключение`try-catch` , созданное в методе, обрабатывается оператором.
* При выполнении `catch` блока:
  * `loadFailed`имеет значение `true`, которое используется для вывода сообщения об ошибке пользователю.
  * Ошибка заносится в журнал.

[!code-cshtml[](handle-errors/samples_snapshot/3.x/product-details.razor?highlight=11,27-39)]

### <a name="rendering-logic"></a>Логика отрисовки

Декларативная разметка в `.razor` файле компонента компилируется в метод C# с именем `BuildRenderTree`. Когда компонент подготавливается к `BuildRenderTree` просмотру, выполняет и создает структуру данных, описывающую элементы, текст и дочерние компоненты отображаемого компонента.

Логика отрисовки может вызывать исключение. Пример такого сценария происходит, когда `@someObject.PropertyName` вычисляется, но `@someObject` имеет. `null` Необработанное исключение, созданное логикой отрисовки, является неустранимым для канала.

Чтобы предотвратить исключение пустой ссылки в логике отрисовки, проверьте `null` объект перед обращением к его членам. В следующем примере свойства недоступны `person.Address` , если `person.Address` имеет значение `null`:

[!code-cshtml[](handle-errors/samples_snapshot/3.x/person-example.razor?highlight=1)]

В приведенном выше коде `person` предполагается, что нет `null`. Часто структура кода гарантирует, что объект существует на момент подготовки компонента к просмотру. В таких случаях нет необходимости проверять `null` логику отрисовки. В предыдущем примере может быть `person` гарантированно существовать, так как `person` создается при создании экземпляра компонента.

### <a name="event-handlers"></a>Обработчики событий

Код на стороне клиента активирует вызовы C# кода при создании обработчиков событий с помощью:

* `@onclick`
* `@onchange`
* Другие `@on...` атрибуты
* `@bind`

В этих сценариях код обработчика событий может вызывать необработанное исключение.

Если обработчик событий создает необработанное исключение (например, запрос к базе данных завершается ошибкой), исключение является неустранимым для канала. Если приложение вызывает код, который может завершиться ошибкой по внешним причинам, необходимо выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

Если пользовательский код не выполняет перехват и обработку исключения, платформа регистрирует исключение и завершает цепь.

### <a name="component-disposal"></a>Реализация компонента

Компонент может быть удален из пользовательского интерфейса, например, потому, что пользователь перешел на другую страницу. Когда компонент, реализующий <xref:System.IDisposable?displayProperty=fullName> интерфейс, удаляется из пользовательского интерфейса, платформа вызывает <xref:System.IDisposable.Dispose*> метод компонента. 

Если `Dispose` метод компонента создает необработанное исключение, исключение является неустранимым для канала. Если логика реализации может вызывать исключения, приложение должно выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

Дополнительные сведения об утилизации компонентов см. <xref:blazor/components#component-disposal-with-idisposable>в разделе.

### <a name="javascript-interop"></a>Взаимодействие с JavaScript

`IJSRuntime.InvokeAsync<T>`позволяет коду .NET выполнять асинхронные вызовы среды выполнения JavaScript в браузере пользователя.

Следующие условия применяются к обработке ошибок с помощью `InvokeAsync<T>`:

* Если вызов завершается `InvokeAsync<T>` с ошибкой синхронно, возникает исключение .NET. Вызов функции `InvokeAsync<T>` My завершился неудачей, например, так как передаваемые аргументы не могут быть сериализованы. Код разработчика должен перехватить исключение. Если код приложения в обработчике событий или в методе жизненного цикла компонента не обрабатывает исключение, полученное исключение является неустранимым для канала.
* Если асинхронный вызов `InvokeAsync<T>` завершается неудачно, <xref:System.Threading.Tasks.Task> происходит сбой .NET. Вызов `InvokeAsync<T>` может завершиться ошибкой, например, потому, что код на стороне JavaScript создает исключение или возвращает объект `Promise` , завершенный как `rejected`. Код разработчика должен перехватить исключение. При использовании оператора [await](/dotnet/csharp/language-reference/keywords/await) рекомендуется обернуть вызов метода в инструкцию [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала. В противном случае сбой кода приводит к возникновению необработанного исключения, которое является неустранимым для канала.
* По умолчанию вызовы метода `InvokeAsync<T>` должны завершаться в течение определенной точки или в другом случае истекает время ожидания. По умолчанию используется период ожидания в одну минуту. Время ожидания защищает код от потери сетевого подключения или кода JavaScript, который никогда не отправляет обратно сообщение о завершении. Если время ожидания вызова истекает, результирующий результат `Task` завершается ошибкой. <xref:System.OperationCanceledException> Ловушка и обработка исключения с ведением журнала.

Аналогичным образом код JavaScript может инициировать вызовы методов .NET, указанных [атрибутом [жсинвокабле]](xref:blazor/javascript-interop#invoke-net-methods-from-javascript-functions). Если эти методы .NET создают необработанное исключение:

* Исключение не рассматривается как неустранимое для канала.
* Сторона `Promise` JavaScript отклоняется.

Вы можете использовать код обработки ошибок либо на стороне .NET, либо на стороне JavaScript вызова метода.

Дополнительные сведения см. в разделе <xref:blazor/javascript-interop>.

### <a name="circuit-handlers"></a>Обработчики цепи

Блазор позволяет коду определять *обработчик цепи*, который получает уведомления при изменении состояния канала пользователя. Используются следующие состояния:

* `initialized`
* `connected`
* `disconnected`
* `disposed`

Управление уведомлениями осуществляется путем регистрации службы di, которая наследуется `CircuitHandler` от абстрактного базового класса.

Если методы пользовательского обработчика цепи создают необработанное исключение, исключение является неустранимым для канала. Чтобы допускать исключения в коде обработчика или вызывать методы, заключите код в один или несколько инструкций [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

### <a name="circuit-disposal"></a>Реализация цепи

Когда цепь завершается из-за того, что пользователь отключился и платформа очищает состояние канала, платформа удаляет область DI цепи. При удалении области удаляются все службы DI с областью действия цепи, реализующие <xref:System.IDisposable?displayProperty=fullName>. Если любая служба DI вызывает необработанное исключение во время удаления, платформа регистрирует исключение.

### <a name="prerendering"></a>Предварительная подготовка

Компоненты блазор можно предварительно отобразить с помощью `Html.RenderComponentAsync` , чтобы их визуализированная разметка HTML возвращалась как часть исходного HTTP-запроса пользователя. Это работает следующим образом.

* Создание нового канала, содержащего все предварительно отображенные компоненты, которые являются частью одной страницы.
* Создание исходного HTML-кода.
* Обработка канала как `disconnected` до тех пор, пока браузер пользователя не установит подключение SignalR к тому же серверу, чтобы возобновить интерактивность канала.

Если какой-либо компонент создает необработанное исключение во время предварительной отрисовки, например во время метода жизненного цикла или в логике отрисовки:

* Исключение является неустранимым для канала.
* Исключение вызывается из стека вызовов из `Html.RenderComponentAsync` вызова. Таким образом, весь HTTP-запрос завершается ошибкой, если только исключение явно не перехвачено кодом разработчика.

В нормальных обстоятельствах при сбое предварительной визуализации продолжение сборки и визуализации компонента не имеет смысла, так как не удается подготовить рабочий компонент к просмотру.

Чтобы допускать ошибки, которые могут возникнуть во время предварительной подготовки, логика обработки ошибок должна размещаться внутри компонента, который может вызывать исключения. Используйте операторы [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала. Вместо заключения в оболочку вызова `RenderComponentAsync` `try-catch` в операторе разместите логику обработки ошибок `RenderComponentAsync`в компоненте, подготовленном к просмотру.

## <a name="advanced-scenarios"></a>Расширенные сценарии

### <a name="recursive-rendering"></a>Рекурсивная визуализация

Компоненты могут быть вложенными рекурсивно. Это полезно для представления рекурсивных структур данных. Например, `TreeNode` компонент может визуализировать больше `TreeNode` компонентов для каждого из дочерних узлов узла.

При рекурсивной отрисовке Избегайте шаблонов программирования, которые приводят к бесконечной рекурсии:

* Не следует рекурсивно подготавливать структуру данных, содержащую цикл. Например, не следует визуализировать узел дерева, дочерние элементы которого содержат сам себя.
* Не создавайте цепочку макетов, содержащих цикл. Например, не создавайте макет, макет которого сам является.
* Не разрешайте пользователю нарушать инварианты рекурсии (правила) с помощью ввода вредоносных данных или вызовов взаимодействия JavaScript.

Бесконечные циклы во время подготовки к просмотру:

* Приводит к тому, что процесс подготовки к просмотру будет выполняться бессрочно.
* Эквивалентно созданию незавершенного цикла.

В этих сценариях происходит зависание цепи, и поток обычно пытается выполнить следующие действия.

* Потребляет столько процессорных ресурсов, сколько разрешено операционной системой, неопределенное время.
* Использование неограниченного объема памяти сервера. Использование неограниченного объема памяти эквивалентно сценарию, в котором незавершенный цикл добавляет записи в коллекцию при каждой итерации.

Чтобы избежать бесконечного шаблона рекурсии, убедитесь, что рекурсивный код отрисовки содержит подходящие условия остановки.

### <a name="custom-render-tree-logic"></a>Логика пользовательского дерева отрисовки

Большинство компонентов блазор реализуются как файлы *Razor* и компилируются для создания логики, которая работает `RenderTreeBuilder` с для отрисовки выходных данных. Разработчик может вручную реализовать `RenderTreeBuilder` логику с помощью процедурного C# кода. Дополнительные сведения см. в разделе <xref:blazor/components#manual-rendertreebuilder-logic>.

> [!WARNING]
> Использование логики построителя дерева ручного просмотра считается расширенным и небезопасным сценарием, не рекомендуемым для разработки общих компонентов.

При `RenderTreeBuilder` написании кода разработчик должен гарантировать правильность кода. Например, разработчик должен убедиться в том, что:

* `OpenElement` Вызовы и `CloseElement` правильно сбалансированы.
* Атрибуты добавляются только в нужные места.

Неправильная логика конструктора ручного отображения дерева может вызвать произвольное неопределенное поведение, включая сбои, зависания сервера и уязвимости системы безопасности.

Рассматривайте логику построителя дерева вручную на том же уровне сложности и с тем же уровнем *опасности* , что и при написании кода сборки или инструкций MSIL вручную.
