---
title: Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly
author: guardrex
description: Сведения о создании на основе Blazor прогрессивных веб-приложений, то есть веб-приложений, которые используют функции современного браузера и реализуют поведение, свойственное классическим приложениям.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083563"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="504a3-103">Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly</span><span class="sxs-lookup"><span data-stu-id="504a3-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="504a3-104">Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)</span><span class="sxs-lookup"><span data-stu-id="504a3-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="504a3-105">Прогрессивное веб-приложение — это веб-приложение, которое использует API и функциональные возможности современного браузера, реализуя свойственное классическим приложениям поведение.</span><span class="sxs-lookup"><span data-stu-id="504a3-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="504a3-106">К этим возможностям можно отнести следующие:</span><span class="sxs-lookup"><span data-stu-id="504a3-106">These capabilities can include:</span></span>

* <span data-ttu-id="504a3-107">работа в автономном режиме и мгновенная загрузка вне зависимости от скорости сети;</span><span class="sxs-lookup"><span data-stu-id="504a3-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="504a3-108">возможность запуска в отдельном окне приложения, а не только в окне браузера;</span><span class="sxs-lookup"><span data-stu-id="504a3-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="504a3-109">запуск из меню "Пуск", меню закрепления или с начального экрана основной операционной системы (ОС);</span><span class="sxs-lookup"><span data-stu-id="504a3-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="504a3-110">получение push-уведомлений от внутреннего сервера, даже если пользователь не работает с приложением;</span><span class="sxs-lookup"><span data-stu-id="504a3-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="504a3-111">автоматическое обновление в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-111">Automatically updating in the background</span></span>

<span data-ttu-id="504a3-112">На начальном этапе пользователь может открывать и использовать приложение в своем веб-браузере аналогично любому другому одностраничному приложению, а затем установить его в своей ОС и включить push-уведомления.</span><span class="sxs-lookup"><span data-stu-id="504a3-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="504a3-113">Именно поэтому такие приложения называются *прогрессивными*.</span><span class="sxs-lookup"><span data-stu-id="504a3-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="504a3-114"> WebAssembly — это полноценная стандартизированная клиентская платформа веб-приложений, которая поддерживает API любых браузеров, в том числе API прогрессивных веб-приложений, необходимые для реализации перечисленных выше возможностей.</span><span class="sxs-lookup"><span data-stu-id="504a3-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="504a3-115">Как и любая другая клиентская веб-технология, она позволяет работать в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="504a3-116">Шаблон прогрессивного веб-приложения</span><span class="sxs-lookup"><span data-stu-id="504a3-116">PWA template</span></span>

<span data-ttu-id="504a3-117">При создании нового приложения Blazor WebAssembly предлагается возможность добавить функции прогрессивного веб-приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="504a3-118">В Visual Studio этот параметр задается с помощью флажка в диалоговом окне создания проекта:</span><span class="sxs-lookup"><span data-stu-id="504a3-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="504a3-120">Если вы создаете проект из командной строки, для этой цели можно использовать флаг `--pwa`.</span><span class="sxs-lookup"><span data-stu-id="504a3-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="504a3-121">Например, примененная к объекту директива</span><span class="sxs-lookup"><span data-stu-id="504a3-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="504a3-122">В обоих случаях вы при необходимости можете одновременно с этим использовать параметр "Размещенный проект ASP.NET Core", но делать это не обязательно.</span><span class="sxs-lookup"><span data-stu-id="504a3-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="504a3-123">Доступность функций прогрессивного веб-приложения не зависит от модели размещения.</span><span class="sxs-lookup"><span data-stu-id="504a3-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="504a3-124">Установка и манифест приложения</span><span class="sxs-lookup"><span data-stu-id="504a3-124">Installation and app manifest</span></span>

<span data-ttu-id="504a3-125">При посещении приложения, созданного с применением параметра шаблона прогрессивного веб-приложения, пользователи могут установить его в меню "Пуск", меню закрепления или на начальном экране своей операционной системы.</span><span class="sxs-lookup"><span data-stu-id="504a3-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="504a3-126">Порядок применения этого параметра зависит от того, какой браузер используется.</span><span class="sxs-lookup"><span data-stu-id="504a3-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="504a3-127">Например в классических версиях браузеров на основе Chromium, таких как Edge или Chrome, в строке URL-адреса появляется кнопка *Добавить*:</span><span class="sxs-lookup"><span data-stu-id="504a3-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="504a3-129">В iOS посетители могут установить прогрессивное веб-приложение с помощью кнопки *Поделиться* в браузере Safari, а также используя параметр *Добавить на главный экран*.</span><span class="sxs-lookup"><span data-stu-id="504a3-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="504a3-130">В браузере Chrome для Android для этой цели следует коснуться кнопки *Меню* в правом верхнем углу окна, а затем выбрать команду *Добавить на главный экран*.</span><span class="sxs-lookup"><span data-stu-id="504a3-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="504a3-131">После установки приложение будет открываться в отдельном окне без адресной строки.</span><span class="sxs-lookup"><span data-stu-id="504a3-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="504a3-133">Чтобы настроить заголовок окна, цветовую схему, значок или другие сведения, используйте файл `manifest.json` в каталоге *wwwroot* проекта.</span><span class="sxs-lookup"><span data-stu-id="504a3-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="504a3-134">Схема этого файла соответствует веб-стандартам.</span><span class="sxs-lookup"><span data-stu-id="504a3-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="504a3-135">Подробную документацию см. на странице https://developer.mozilla.org/docs/Web/Manifest.</span><span class="sxs-lookup"><span data-stu-id="504a3-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="504a3-136">Поддержка автономной работы</span><span class="sxs-lookup"><span data-stu-id="504a3-136">Offline support</span></span>

<span data-ttu-id="504a3-137">По умолчанию приложения, созданные с помощью шаблона прогрессивного веб-приложения, поддерживают работу в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="504a3-138">Для этого пользователь должен сначала посетить приложение при наличии подключения к сети, после чего браузер автоматически скачает и кэширует все ресурсы, необходимые для его работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="504a3-139">Поддержка работы в автономном режиме доступна только для *опубликованных* приложений.</span><span class="sxs-lookup"><span data-stu-id="504a3-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="504a3-140">На этапе разработки она не реализуется.</span><span class="sxs-lookup"><span data-stu-id="504a3-140">It is not enabled during development.</span></span> <span data-ttu-id="504a3-141">Это обусловлено возможными помехами для типового цикла разработки, предусматривающего внесение изменений и их тестирование.</span><span class="sxs-lookup"><span data-stu-id="504a3-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="504a3-142">Если вы планируете предоставлять прогрессивное веб-приложение с поддержкой автономного режима, следует обратить внимание на [несколько важных предупреждений и предостережений](#caveats-for-offline-pwas).</span><span class="sxs-lookup"><span data-stu-id="504a3-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="504a3-143">Они присущи всем поддерживающим автономную работу прогрессивным веб-приложениям и не являются специфичными для Blazor.</span><span class="sxs-lookup"><span data-stu-id="504a3-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="504a3-144">Прежде чем планировать работу своего приложения, поддерживающего автономный режим, внимательно ознакомьтесь с этими предупреждениями и убедитесь, что они вам понятны.</span><span class="sxs-lookup"><span data-stu-id="504a3-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="504a3-145">Чтобы ознакомиться с принципами поддержки автономного режима, сначала [опубликуйте приложение](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app) и разместите его на узле, поддерживающем протокол HTTPS.</span><span class="sxs-lookup"><span data-stu-id="504a3-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="504a3-146">При посещении приложения у вас должна быть возможность открыть средства разработки браузера и убедиться, что для узла зарегистрирована *рабочая роль службы*:</span><span class="sxs-lookup"><span data-stu-id="504a3-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="504a3-148">Кроме того, при перезагрузке страницы на вкладке *Сеть* вы увидите, что все ресурсы, необходимые для ее загрузки, извлекаются из *рабочей роли службы* или *кэша памяти*:</span><span class="sxs-lookup"><span data-stu-id="504a3-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="504a3-150">Это свидетельствует о том, что для загрузки приложения браузеру не требуется доступ к сети.</span><span class="sxs-lookup"><span data-stu-id="504a3-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="504a3-151">Чтобы убедиться в этом, вы можете завершить работу веб-сервера или настроить имитацию автономного режима в браузере:</span><span class="sxs-lookup"><span data-stu-id="504a3-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="504a3-153">Таким образом, даже при отсутствии доступа к веб-серверу вы сможете перезагружать страницу и увидите, что ваше приложение по-прежнему загружается и работает.</span><span class="sxs-lookup"><span data-stu-id="504a3-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="504a3-154">Аналогичным образом, даже при имитации крайне медленного сетевого подключения ваша страница будет по-прежнему загружаться мгновенно, не обращаясь для этого к сетевым ресурсам.</span><span class="sxs-lookup"><span data-stu-id="504a3-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="504a3-155">Рабочая роль службы</span><span class="sxs-lookup"><span data-stu-id="504a3-155">Service worker</span></span>

<span data-ttu-id="504a3-156">Для поддержки работы в автономном режиме используется рабочая роль службы.</span><span class="sxs-lookup"><span data-stu-id="504a3-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="504a3-157">Это веб-стандарт, который применяется не только в отношении Blazor.</span><span class="sxs-lookup"><span data-stu-id="504a3-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="504a3-158">Документация, посвященная рабочим ролям службы, представлена на странице https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span><span class="sxs-lookup"><span data-stu-id="504a3-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="504a3-159">Дополнительные сведения об общих принципах использования рабочих ролей службы см. в [великолепной статье](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle), посвященной описанию их жизненного цикла.</span><span class="sxs-lookup"><span data-stu-id="504a3-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

<span data-ttu-id="504a3-160">Шаблон прогрессивного веб-приложения Blazor создает два файла рабочей роли службы:</span><span class="sxs-lookup"><span data-stu-id="504a3-160">Blazor's PWA template produces two service worker files:</span></span>

* <span data-ttu-id="504a3-161">*wwwroot/service-worker.js* — используется во время разработки.</span><span class="sxs-lookup"><span data-stu-id="504a3-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="504a3-162">*wwwroot/service-worker.published.js* — используется после публикации приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="504a3-163">Если вы хотите использовать общую логику для этих двух файлов, рекомендуется добавить содержащий ее третий файл JavaScript и использовать [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) для загрузки такой логики в оба файла.</span><span class="sxs-lookup"><span data-stu-id="504a3-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="504a3-164">Стратегия первичного обращения к кэшу</span><span class="sxs-lookup"><span data-stu-id="504a3-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="504a3-165">Встроенная рабочая роль службы *service-worker.published.js* выполняет разрешение запросов с применением стратегии *первичного обращения к кэшу*.</span><span class="sxs-lookup"><span data-stu-id="504a3-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="504a3-166">В соответствии с этой стратегией даже при наличии доступа к сети или нового содержимого на сервере во всех возможных случаях отдается предпочтение возвращаемому из кэша содержимому.</span><span class="sxs-lookup"><span data-stu-id="504a3-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="504a3-167">Это полезно по двум причинам.</span><span class="sxs-lookup"><span data-stu-id="504a3-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="504a3-168">**Во-первых, за счет этого повышается надежность.**</span><span class="sxs-lookup"><span data-stu-id="504a3-168">**It ensures reliability.**</span></span> <span data-ttu-id="504a3-169">Состояние доступа к сети сложно определить однозначно,</span><span class="sxs-lookup"><span data-stu-id="504a3-169">Network access is not a boolean state.</span></span> <span data-ttu-id="504a3-170">поскольку пользователь не всегда просто находится в подключенном или автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="504a3-171">В реальности, даже при наличии подключения его скорость может быть настолько мала, что ожидание загрузки содержимого может быть нецелесообразно.</span><span class="sxs-lookup"><span data-stu-id="504a3-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="504a3-172">Кроме того, для некоторых URL-адресов из сети могут возвращаться недопустимые результаты, как например в случае с порталом перехвата Wi-Fi, который блокирует или перенаправляет определенные запросы.</span><span class="sxs-lookup"><span data-stu-id="504a3-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="504a3-173">Именно поэтому API `navigator.onLine` браузера не может считаться надежным источником, на который следует полагаться в приложении.</span><span class="sxs-lookup"><span data-stu-id="504a3-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="504a3-174">**Во-вторых, это позволяет гарантировать корректность.**</span><span class="sxs-lookup"><span data-stu-id="504a3-174">**It ensures correctness.**</span></span> <span data-ttu-id="504a3-175">При создании кэша автономных ресурсов рабочая роль службы хэширует содержимое, чтобы гарантировать получение полного и согласованного моментального снимка ресурсов по состоянию на один конкретный момент времени.</span><span class="sxs-lookup"><span data-stu-id="504a3-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="504a3-176">В дальнейшем этот кэш используется в качестве атомарной единицы.</span><span class="sxs-lookup"><span data-stu-id="504a3-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="504a3-177">Таким образом, запрашивать более новые версии ресурсы из сети нецелесообразно, поскольку все данные, которые вам нужны, уже хранятся в кэше.</span><span class="sxs-lookup"><span data-stu-id="504a3-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="504a3-178">Любые другие данные могут стать причиной несогласованности и несовместимости, например при попытке использовать версии сборок .NET, которые не компилировались вместе.</span><span class="sxs-lookup"><span data-stu-id="504a3-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="504a3-179">Обновления в фоновом режиме</span><span class="sxs-lookup"><span data-stu-id="504a3-179">Background updates</span></span>

<span data-ttu-id="504a3-180">Для наглядности прогрессивное веб-приложение с предпочтительным автономным режимом работы можно рассматривать как устанавливаемое мобильное приложение.</span><span class="sxs-lookup"><span data-stu-id="504a3-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="504a3-181">Оно всегда запускается немедленно независимо от наличия сетевого подключения, однако при этом логика установленного приложения извлекается из моментального снимка на определенный момент времени, который может содержать устаревшие данные.</span><span class="sxs-lookup"><span data-stu-id="504a3-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="504a3-182">На основе шаблона прогрессивного веб-приложения Blazor создаются приложения, которые пытаются автоматически выполнить обновление в фоновом режиме при наличии работающего сетевого подключения каждый раз, когда приложение посещает пользователь.</span><span class="sxs-lookup"><span data-stu-id="504a3-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="504a3-183">Этот процесс реализуется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="504a3-183">The way this works is as follows:</span></span>

* <span data-ttu-id="504a3-184">Во время компиляции проект создает *манифест ресурсов рабочей роли службы*.</span><span class="sxs-lookup"><span data-stu-id="504a3-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="504a3-185">По умолчанию этому файлу присваивается имя *service-worker-assets.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="504a3-186">В нем перечислены все статические ресурсы, которые необходимы для работы приложения в автономном режиме, например сборки .NET, файлы JavaScript, каскадные таблицы стилей и прочие элементы, в том числе хэши содержимого.</span><span class="sxs-lookup"><span data-stu-id="504a3-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="504a3-187">Рабочая роль службы загружает этот список и использует его для определения ресурсов, которые требуется кэшировать.</span><span class="sxs-lookup"><span data-stu-id="504a3-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="504a3-188">Каждый раз, когда пользователь посещает приложение, браузер в фоновом режиме повторно запрашивает файлы *service-worker.js* и *service-worker-assets.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="504a3-189">Если сервер возвращает любой из этих файлов с измененным содержимым (определяется по результатам побайтового сравнения с существующей установленной рабочей ролью службы), рабочая роль службы пытается установить собственную новую версию.</span><span class="sxs-lookup"><span data-stu-id="504a3-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="504a3-190">При установке собственной новой версии рабочая роль службы создает новый отдельный кэш для автономных ресурсов и начинает заполнять его ресурсами, перечисленными в файле *service-worker-assets.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="504a3-191">Эта логика реализуется в функции `onInstall` в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="504a3-192">Если процесс завершается успешно (т. е. все ресурсы загружены без ошибок и все хэши содержимого совпадают), новая рабочая роль службы переходит в состояние "Ожидание активации".</span><span class="sxs-lookup"><span data-stu-id="504a3-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="504a3-193">После того как пользователь закроет приложение (т. е. все вкладки или окна, в которых оно отображается) новая рабочая роль службы получает статус активной и будет использоваться при последующем посещении приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="504a3-194">Старая рабочая роль службы и ее кэш при этом удаляются.</span><span class="sxs-lookup"><span data-stu-id="504a3-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="504a3-195">Если процесс завершается неудачно, новый экземпляр рабочей роли службы отклоняется.</span><span class="sxs-lookup"><span data-stu-id="504a3-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="504a3-196">При следующем посещении пользователя будет предпринята попытка выполнить процесс обновления еще раз в расчете на более высокое качество сетевого подключения и возможность выполнения необходимых запросов.</span><span class="sxs-lookup"><span data-stu-id="504a3-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="504a3-197">Все аспекты этого процесса можно настроить, используя логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="504a3-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="504a3-198">Все перечисленные выше варианты описывают возможные способы использовать шаблон прогрессивного веб-приложения и не являются специфичными для Blazor.</span><span class="sxs-lookup"><span data-stu-id="504a3-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="504a3-199">Дополнительные сведения см. в [документации по рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.).</span><span class="sxs-lookup"><span data-stu-id="504a3-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="504a3-200">Принципы разрешения запросов</span><span class="sxs-lookup"><span data-stu-id="504a3-200">How requests are resolved</span></span>

<span data-ttu-id="504a3-201">Как описывается выше, по умолчанию рабочая роль службы применяет стратегию *первичного обращения к кэшу*, то есть пытается по возможности всегда использовать кэшированное содержимое.</span><span class="sxs-lookup"><span data-stu-id="504a3-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="504a3-202">Если для отдельного URL-адреса кэшированное содержимое отсутствует (например, в случае запроса данных из серверного API), рабочая роль службы использует обычные сетевые запросы, которые выполняются успешно только при наличии доступа к серверу.</span><span class="sxs-lookup"><span data-stu-id="504a3-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="504a3-203">Эта логика реализуется в функции `onFetch` в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="504a3-204">Если ваши компоненты Blazor запрашивают данные из серверных API и вам требуется удобный пользовательский интерфейс для обработки сбоев, связанных с отсутствием доступа к сети, соответствующую логику необходимо реализовать в самих компонентах.</span><span class="sxs-lookup"><span data-stu-id="504a3-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="504a3-205">Например, используйте `try/catch` для запросов `HttpClient`.</span><span class="sxs-lookup"><span data-stu-id="504a3-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="504a3-206">Поддержка страниц, подготавливаемых к просмотру на сервере</span><span class="sxs-lookup"><span data-stu-id="504a3-206">Support server-rendered pages</span></span>

<span data-ttu-id="504a3-207">Рассмотрим, что происходит при первом переходе пользователя к URL-адресу, например к `/counter` или по любой другой прямой ссылке в приложении.</span><span class="sxs-lookup"><span data-stu-id="504a3-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="504a3-208">В таких случаях вам не требуется возвращать кэшированное содержимое как `/counter`, а вместо этого нужно загрузить в браузер содержимое, кэшированное как `/index.html`, для запуска приложения Blazor WebAssembly.</span><span class="sxs-lookup"><span data-stu-id="504a3-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="504a3-209">Такие начальные запросы называются *запросами навигации* (в отличие от *запросов подресурсов* для получения изображений, каскадных таблиц стилей и т. д. или *запросов на получение или XHR* для получения данных API).</span><span class="sxs-lookup"><span data-stu-id="504a3-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="504a3-210">По умолчанию рабочая роль службы использует для обработки запросов навигации специальную логику.</span><span class="sxs-lookup"><span data-stu-id="504a3-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="504a3-211">При их разрешении для `/index.html` возвращается кэшированное содержимое независимо от того, какой URL-адрес запрашивается.</span><span class="sxs-lookup"><span data-stu-id="504a3-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="504a3-212">Эта логика реализуется в функции `onFetch` в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="504a3-213">Если для некоторых URL-адресов в вашем приложении должен возвращаться подготавливаемый к просмотру на сервере код HTML (то есть для обслуживания `/index.html` не должен использоваться кэш), вам потребуется изменить логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="504a3-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="504a3-214">Например, если все URL-адреса, содержащие `/Identity/`, требуется обрабатывать как обычные сетевые запросы к серверу, следует изменить логику функции `onFetch`в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="504a3-215">Найдите следующий код.</span><span class="sxs-lookup"><span data-stu-id="504a3-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="504a3-216">Измените код следующим образом:</span><span class="sxs-lookup"><span data-stu-id="504a3-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="504a3-217">Если этого не сделать, то независимо от наличия сетевого подключения рабочая роль службы будет перехватывать запросы к таким URL-адресам и разрешать их с помощью `/index.html`.</span><span class="sxs-lookup"><span data-stu-id="504a3-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="504a3-218">Управление кэшированием ресурсов</span><span class="sxs-lookup"><span data-stu-id="504a3-218">Control asset caching</span></span>

<span data-ttu-id="504a3-219">Если в вашем проекте определено свойство MSBuild под названием `ServiceWorkerAssetsManifest`, средства сборки Blazor создадут манифест ресурса рабочей роли службы с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="504a3-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="504a3-220">По умолчанию шаблон прогрессивного веб-приложения создает файл проекта со следующим содержимым:</span><span class="sxs-lookup"><span data-stu-id="504a3-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="504a3-221">Этот файл помещается в выходной каталог *wwwroot*, откуда браузер может извлекать его посредством запроса `/service-worker-assets.js`.</span><span class="sxs-lookup"><span data-stu-id="504a3-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="504a3-222">Чтобы просмотреть содержимое файла *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js*, откройте его в текстовом редакторе.</span><span class="sxs-lookup"><span data-stu-id="504a3-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="504a3-223">Не вносите изменения в этот файл, поскольку он создается заново для каждой сборки.</span><span class="sxs-lookup"><span data-stu-id="504a3-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="504a3-224">По умолчанию этот манифест содержит следующие данные:</span><span class="sxs-lookup"><span data-stu-id="504a3-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="504a3-225">Все управляемые Blazor ресурсы, в том числе сборки .NET и файлы среды выполнения .NET WebAssembly, необходимые для работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="504a3-226">Все ресурсы, которые будут опубликованы в каталоге *wwwroot*, например изображения, каскадные таблицы стилей и файлы JavaScript.</span><span class="sxs-lookup"><span data-stu-id="504a3-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="504a3-227">К ним также относятся статические веб-ресурсы, предоставляемые в составе внешних проектов и пакетов NuGet.</span><span class="sxs-lookup"><span data-stu-id="504a3-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="504a3-228">Чтобы управлять получением и кэшированием этих ресурсов в рабочей роли службы, измените логику функции `onInstall` в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="504a3-229">По умолчанию получаются и кэшируются файлы с типичными для веб-файлов расширениями, такими как *.html*, *.css*, *.js*, *.wasm* и другие, а также специфичные для Blazor WebAssembly файлы ( *.dll*, *.pdb*).</span><span class="sxs-lookup"><span data-stu-id="504a3-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="504a3-230">Чтобы включить другие ресурсы, отсутствующие в каталоге *wwwroot*, вы можете определить дополнительные записи ItemGroup в MSBuild.</span><span class="sxs-lookup"><span data-stu-id="504a3-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="504a3-231">Например, добавьте следующее в файл проекта:</span><span class="sxs-lookup"><span data-stu-id="504a3-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="504a3-232">В метаданных `AssetUrl` указывается относительный URL-адрес, который браузер должен использовать при получении ресурса в кэш.</span><span class="sxs-lookup"><span data-stu-id="504a3-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="504a3-233">При этом имя оригинального исходного файла на диске может не учитываться.</span><span class="sxs-lookup"><span data-stu-id="504a3-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="504a3-234">Если добавить `ServiceWorkerAssetsManifestItem`, публикация файла в каталог *wwwroot* не произойдет автоматически.</span><span class="sxs-lookup"><span data-stu-id="504a3-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="504a3-235">Таким образом, вы самостоятельно управляете публикацией выходных данных.</span><span class="sxs-lookup"><span data-stu-id="504a3-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="504a3-236">В результате добавления `ServiceWorkerAssetsManifestItem` в манифесте ресурса рабочей роли службы лишь появляется дополнительная запись.</span><span class="sxs-lookup"><span data-stu-id="504a3-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="504a3-237">Push-уведомления</span><span class="sxs-lookup"><span data-stu-id="504a3-237">Push notifications</span></span>

<span data-ttu-id="504a3-238">Как и любые аналоги, прогрессивные веб-приложения Blazor WebAssembly поддерживают получение push-уведомлений от внутреннего сервера.</span><span class="sxs-lookup"><span data-stu-id="504a3-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="504a3-239">Сервер может отправлять такие уведомления в любое время, даже если приложение не используется (например, если другой пользователь выполняет действие, о котором требуется оповестить).</span><span class="sxs-lookup"><span data-stu-id="504a3-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="504a3-240">Механизм отправки push-уведомлений не зависит от Blazor WebAssembly, поскольку он реализуется на внутреннем сервере, который может использовать любую технологию.</span><span class="sxs-lookup"><span data-stu-id="504a3-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="504a3-241">Для отправки push-уведомлений с сервера ASP.NET Core рекомендуется [использовать методику, аналогичную описываемой в рамках семинара по проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span><span class="sxs-lookup"><span data-stu-id="504a3-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="504a3-242">Механизм приема и отображения push-уведомлений на стороне клиента также реализуется независимо от Blazor WebAssembly в рабочей роли службы, которая представляет собой файл JavaScript.</span><span class="sxs-lookup"><span data-stu-id="504a3-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="504a3-243">Хороший пример также можно найти в [семинаре, посвященном проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span><span class="sxs-lookup"><span data-stu-id="504a3-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="504a3-244">Предупреждения относительно прогрессивных веб-приложений с поддержкой автономной работы</span><span class="sxs-lookup"><span data-stu-id="504a3-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="504a3-245">Поддержка работы в автономном режиме требуется не для всех приложений.</span><span class="sxs-lookup"><span data-stu-id="504a3-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="504a3-246">С ее реализацией сопряжены определенные сложности, решение которых не всегда целесообразно.</span><span class="sxs-lookup"><span data-stu-id="504a3-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="504a3-247">Поддержка автономной работы как правило требуется лишь в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="504a3-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="504a3-248">Браузер использует преимущественно локальное основное хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="504a3-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="504a3-249">В качестве примера можно привести разработку пользовательского интерфейса для устройства [Интернета вещей](https://en.wikipedia.org/wiki/Internet_of_things), которое хранит данные в `localStorage` или [индексированной базе данных](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span><span class="sxs-lookup"><span data-stu-id="504a3-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="504a3-250">Вы тратите много усилий на получение и кэширование данных серверного API для каждого пользователя, что позволяет им работать с такими данными в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="504a3-251">Для поддержки редактирования вам также потребуется создать систему, которая будет отслеживать изменения и синхронизировать их с серверной частью.</span><span class="sxs-lookup"><span data-stu-id="504a3-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="504a3-252">Вам необходимо гарантировать мгновенную загрузку приложения независимо от состояния сетевого подключения.</span><span class="sxs-lookup"><span data-stu-id="504a3-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="504a3-253">Вам требуется реализовать соответствующий пользовательский интерфейс для работы с запросами к серверному API и корректного разрешения ситуаций, когда они завершаются сбоем из-за отсутствия доступа к сети.</span><span class="sxs-lookup"><span data-stu-id="504a3-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="504a3-254">Кроме того, поддержка работы в автономном режиме для прогрессивных веб-приложений сопряжена с рядом дополнительных сложностей.</span><span class="sxs-lookup"><span data-stu-id="504a3-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="504a3-255">Разработчикам необходимо внимательно изучить приведенные ниже предостережения.</span><span class="sxs-lookup"><span data-stu-id="504a3-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="504a3-256">Работа в автономном режиме поддерживается только для опубликованных приложений</span><span class="sxs-lookup"><span data-stu-id="504a3-256">Offline support only when published</span></span>

<span data-ttu-id="504a3-257">Шаблон прогрессивного веб-приложения Blazor обеспечивает поддержку автономной работы только после публикации приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-257">Blazor's PWA template enables offline support only when published.</span></span> <span data-ttu-id="504a3-258">Это связано с тем, что в процессе разработки каждое изменение как правило должно сразу отражаться в браузере, не дожидаясь обновления в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="504a3-259">Поэтому при создании приложения, поддерживающего автономную работу, не достаточно протестировать его в режиме разработки.</span><span class="sxs-lookup"><span data-stu-id="504a3-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="504a3-260">Вам придется проверить приложение в опубликованном состоянии, чтобы понять, как оно будет вести себя при различных состояниях сети.</span><span class="sxs-lookup"><span data-stu-id="504a3-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="504a3-261">Обновление выполняется только после выхода пользователя из приложения</span><span class="sxs-lookup"><span data-stu-id="504a3-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="504a3-262">Обновления будут выполняться только после того, как пользователь выйдет из приложения на всех вкладках.</span><span class="sxs-lookup"><span data-stu-id="504a3-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="504a3-263">Как поясняется в разделе [Обновления в фоновом режиме](#background-updates), после развертывания и обновления приложения браузер получит обновленные файлы рабочей роли службы и запустит процесс обновления.</span><span class="sxs-lookup"><span data-stu-id="504a3-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="504a3-264">Однако далеко не все разработчики знают, что даже после завершения процесса обновления оно вступит в силу **только после того**, как пользователь выйдет из приложения на всех вкладках.</span><span class="sxs-lookup"><span data-stu-id="504a3-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="504a3-265">Даже если ваше приложение отображается только в одной вкладке, простого ее обновления будет **не достаточно**.</span><span class="sxs-lookup"><span data-stu-id="504a3-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="504a3-266">Пока пользователь не закроет приложение полностью, новая рабочая роль службы будет оставаться в состоянии "Ожидание активации".</span><span class="sxs-lookup"><span data-stu-id="504a3-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="504a3-267">**Такое поведение присуще всем веб-платформам и не является специфичным для Blazor.**</span><span class="sxs-lookup"><span data-stu-id="504a3-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="504a3-268">Соответственно, многие разработчики сталкиваются с проблемами при попытке протестировать обновления рабочей роли службы или кэшированных автономно ресурсов.</span><span class="sxs-lookup"><span data-stu-id="504a3-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="504a3-269">Открыв средства разработчика в браузере, вы можете увидеть нечто подобное:</span><span class="sxs-lookup"><span data-stu-id="504a3-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![изображение](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="504a3-271">Рабочая роль будет находиться в состоянии ожидания до тех пор, пока список "клиентов" (то есть вкладок или окон, в которых отображается приложение) не опустеет.</span><span class="sxs-lookup"><span data-stu-id="504a3-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="504a3-272">Такое поведение позволяет гарантировать согласованность, то есть получение всех ресурсов из одного атомарного кэша.</span><span class="sxs-lookup"><span data-stu-id="504a3-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="504a3-273">При тестировании изменений может быть удобно воспользоваться ссылкой "skipWaiting", которая позволяет пропустить этап ожидания (см. снимок экрана ниже), и затем перезагрузить страницу.</span><span class="sxs-lookup"><span data-stu-id="504a3-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="504a3-274">При желании вы можете автоматизировать этот процесс для всех пользователей, реализовав в коде рабочей роли службы [пропуск этапа "ожидания" с немедленной активацией обновления](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span><span class="sxs-lookup"><span data-stu-id="504a3-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="504a3-275">Тем не менее, в этом случае согласованное получение ресурсов из одного и того же экземпляра кэша не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="504a3-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="504a3-276">Пользователи могут запускать любую ранее существовавшую версию приложения</span><span class="sxs-lookup"><span data-stu-id="504a3-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="504a3-277">Как правило, разработчики веб-приложения ожидают, что пользователи будут работать только с его последней развернутой версией, поскольку это характерно для традиционной модели распространения.</span><span class="sxs-lookup"><span data-stu-id="504a3-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="504a3-278">Тем не менее, прогрессивное веб-приложение с предпочтительным автономным режимом работы в этом отношении больше похоже на собственное мобильное приложение, пользователи которого далеко не всегда работают с последней версией.</span><span class="sxs-lookup"><span data-stu-id="504a3-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="504a3-279">Как описывается в разделе [Обновления в фоновом режиме](#background-updates), после развертывания обновления для приложения **все его текущие пользователи будут работать с предыдущей версией как минимум во время ближайшего посещения** (это связано с тем, что обновление происходит в фоновом режиме только после того, как пользователь выйдет из приложения).</span><span class="sxs-lookup"><span data-stu-id="504a3-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="504a3-280">Кроме того, в этом случае предыдущей используемой версией не обязательно будет та, которую вы развернули в прошлый раз. В зависимости от того, когда пользователь последний раз выполнял обновление, это может быть *любая* ранее существовавшая версия.</span><span class="sxs-lookup"><span data-stu-id="504a3-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="504a3-281">Таким образом, если внешние и внутренние компоненты приложения должны использовать согласованную схему для работы с запросами к API, это может привести к возникновению проблем.</span><span class="sxs-lookup"><span data-stu-id="504a3-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="504a3-282">Соответственно, развертывать изменения схемы API, не предусматривающие обратную совместимость, можно только после того, как вы убедитесь, что все пользователи выполнили обновление. Также в таких случаях можно явно запретить использование несовместимых старых версий приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="504a3-283">Такое поведение характерно для собственных мобильных приложений.</span><span class="sxs-lookup"><span data-stu-id="504a3-283">This is just like a native mobile app.</span></span> <span data-ttu-id="504a3-284">При развертывании существенных изменений в серверных API пользователи, не выполнившие обновление, столкнутся со сбоями в работе приложения.</span><span class="sxs-lookup"><span data-stu-id="504a3-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="504a3-285">Соответственно, по возможности не следует развертывать существенные изменения в серверных API.</span><span class="sxs-lookup"><span data-stu-id="504a3-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="504a3-286">Если это все же необходимо, рекомендуется использовать [стандартные API рабочей роли службы, такие как `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration), для определения актуальности версии приложения и блокировки его старых версий.</span><span class="sxs-lookup"><span data-stu-id="504a3-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="504a3-287">Возникают помехи в работе подготавливаемых к просмотру на сервере страниц</span><span class="sxs-lookup"><span data-stu-id="504a3-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="504a3-288">[Как описывается выше](#support-server-rendered-pages), чтобы обойти поведение рабочей роли службы и предотвратить возврат содержимого `/index.html` для всех запросов навигации, необходимо изменить логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="504a3-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="504a3-289">По умолчанию кэшируется все содержимое манифеста ресурса рабочей роли службы</span><span class="sxs-lookup"><span data-stu-id="504a3-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="504a3-290">[Как описывается выше](#control-asset-caching), файл *service-worker-assets.js* создается в процессе сборки и содержит список всех ресурсов, которые должна получать и кэшировать рабочая роль службы.</span><span class="sxs-lookup"><span data-stu-id="504a3-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="504a3-291">Поскольку в этот список по умолчанию включается все содержимое, размещаемое в каталоге *wwwroot* (в том числе и поступающее из внешних пакетов и проектов), необходимо тщательно следить за тем, что именно будет находиться в этом каталоге.</span><span class="sxs-lookup"><span data-stu-id="504a3-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="504a3-292">Например, если каталог *wwwroot* содержит несколько миллионов изображений, рабочая роль службы попытается получить и кэшировать их все, что приведет к перегрузке сети и, скорее всего, закончится сбоем.</span><span class="sxs-lookup"><span data-stu-id="504a3-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="504a3-293">Вы можете реализовать произвольную логику, ограничивающую получение и кэширование содержимого манифеста, внеся соответствующие изменения в функцию `onInstall` в файле *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="504a3-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="504a3-294">Взаимодействие с технологиями проверки подлинности</span><span class="sxs-lookup"><span data-stu-id="504a3-294">Interaction with authentication</span></span>

<span data-ttu-id="504a3-295">Шаблоны прогрессивного веб-приложения можно использовать совместно с технологиями проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="504a3-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="504a3-296">Прогрессивные веб-приложения с поддержкой автономной работы также могут обеспечивать проверку подлинности при наличии у пользователя подключения к сети.</span><span class="sxs-lookup"><span data-stu-id="504a3-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="504a3-297">Тем не менее, в случае отсутствия сетевого подключения пользователь не сможет пройти проверку подлинности или получить маркеры доступа.</span><span class="sxs-lookup"><span data-stu-id="504a3-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="504a3-298">Соответственно, при попытке перейти на страницу входа по умолчанию будет отображаться сообщение об ошибке сети.</span><span class="sxs-lookup"><span data-stu-id="504a3-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="504a3-299">Это значит, что вам необходимо организовать работу пользователя в автономном режиме таким образом, чтобы при отсутствии сетевого подключения не требовались маркеры доступа или проверка подлинности, либо были предусмотрены способы минимизировать последствия сбоев в таких случаях.</span><span class="sxs-lookup"><span data-stu-id="504a3-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="504a3-300">Если реализовать это в приложении невозможно, следует задуматься, действительно ли в нем необходима поддержка работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="504a3-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
