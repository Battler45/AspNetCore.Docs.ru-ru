---
title: Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly
author: guardrex
description: Сведения о создании на основе Blazor прогрессивных веб-приложений, то есть веб-приложений, которые используют функции современного браузера и реализуют поведение, свойственное классическим приложениям.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083563"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a>Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

Прогрессивное веб-приложение — это веб-приложение, которое использует API и функциональные возможности современного браузера, реализуя свойственное классическим приложениям поведение. К этим возможностям можно отнести следующие:

* работа в автономном режиме и мгновенная загрузка вне зависимости от скорости сети;
* возможность запуска в отдельном окне приложения, а не только в окне браузера;
* запуск из меню "Пуск", меню закрепления или с начального экрана основной операционной системы (ОС);
* получение push-уведомлений от внутреннего сервера, даже если пользователь не работает с приложением;
* автоматическое обновление в фоновом режиме.

На начальном этапе пользователь может открывать и использовать приложение в своем веб-браузере аналогично любому другому одностраничному приложению, а затем установить его в своей ОС и включить push-уведомления. Именно поэтому такие приложения называются *прогрессивными*.

Blazor WebAssembly — это полноценная стандартизированная клиентская платформа веб-приложений, которая поддерживает API любых браузеров, в том числе API прогрессивных веб-приложений, необходимые для реализации перечисленных выше возможностей. Как и любая другая клиентская веб-технология, она позволяет работать в автономном режиме.

## <a name="pwa-template"></a>Шаблон прогрессивного веб-приложения

При создании нового приложения Blazor WebAssembly предлагается возможность добавить функции прогрессивного веб-приложения. В Visual Studio этот параметр задается с помощью флажка в диалоговом окне создания проекта:

![изображение](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

Если вы создаете проект из командной строки, для этой цели можно использовать флаг `--pwa`. Например, примененная к объекту директива

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

В обоих случаях вы при необходимости можете одновременно с этим использовать параметр "Размещенный проект ASP.NET Core", но делать это не обязательно. Доступность функций прогрессивного веб-приложения не зависит от модели размещения.

## <a name="installation-and-app-manifest"></a>Установка и манифест приложения

При посещении приложения, созданного с применением параметра шаблона прогрессивного веб-приложения, пользователи могут установить его в меню "Пуск", меню закрепления или на начальном экране своей операционной системы.

Порядок применения этого параметра зависит от того, какой браузер используется. Например в классических версиях браузеров на основе Chromium, таких как Edge или Chrome, в строке URL-адреса появляется кнопка *Добавить*:

![изображение](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

В iOS посетители могут установить прогрессивное веб-приложение с помощью кнопки *Поделиться* в браузере Safari, а также используя параметр *Добавить на главный экран*. В браузере Chrome для Android для этой цели следует коснуться кнопки *Меню* в правом верхнем углу окна, а затем выбрать команду *Добавить на главный экран*.

После установки приложение будет открываться в отдельном окне без адресной строки.

![изображение](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

Чтобы настроить заголовок окна, цветовую схему, значок или другие сведения, используйте файл `manifest.json` в каталоге *wwwroot* проекта. Схема этого файла соответствует веб-стандартам. Подробную документацию см. на странице https://developer.mozilla.org/docs/Web/Manifest.

## <a name="offline-support"></a>Поддержка автономной работы

По умолчанию приложения, созданные с помощью шаблона прогрессивного веб-приложения, поддерживают работу в автономном режиме. Для этого пользователь должен сначала посетить приложение при наличии подключения к сети, после чего браузер автоматически скачает и кэширует все ресурсы, необходимые для его работы в автономном режиме.

> [!IMPORTANT]
> Поддержка работы в автономном режиме доступна только для *опубликованных* приложений. На этапе разработки она не реализуется. Это обусловлено возможными помехами для типового цикла разработки, предусматривающего внесение изменений и их тестирование.

> [!WARNING]
> Если вы планируете предоставлять прогрессивное веб-приложение с поддержкой автономного режима, следует обратить внимание на [несколько важных предупреждений и предостережений](#caveats-for-offline-pwas). Они присущи всем поддерживающим автономную работу прогрессивным веб-приложениям и не являются специфичными для Blazor. Прежде чем планировать работу своего приложения, поддерживающего автономный режим, внимательно ознакомьтесь с этими предупреждениями и убедитесь, что они вам понятны.

Чтобы ознакомиться с принципами поддержки автономного режима, сначала [опубликуйте приложение](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app) и разместите его на узле, поддерживающем протокол HTTPS. При посещении приложения у вас должна быть возможность открыть средства разработки браузера и убедиться, что для узла зарегистрирована *рабочая роль службы*:

![изображение](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

Кроме того, при перезагрузке страницы на вкладке *Сеть* вы увидите, что все ресурсы, необходимые для ее загрузки, извлекаются из *рабочей роли службы* или *кэша памяти*:

![изображение](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

Это свидетельствует о том, что для загрузки приложения браузеру не требуется доступ к сети. Чтобы убедиться в этом, вы можете завершить работу веб-сервера или настроить имитацию автономного режима в браузере:

![изображение](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

Таким образом, даже при отсутствии доступа к веб-серверу вы сможете перезагружать страницу и увидите, что ваше приложение по-прежнему загружается и работает. Аналогичным образом, даже при имитации крайне медленного сетевого подключения ваша страница будет по-прежнему загружаться мгновенно, не обращаясь для этого к сетевым ресурсам.

### <a name="service-worker"></a>Рабочая роль службы

Для поддержки работы в автономном режиме используется рабочая роль службы. Это веб-стандарт, который применяется не только в отношении Blazor. Документация, посвященная рабочим ролям службы, представлена на странице https://developer.mozilla.org/docs/Web/API/Service_Worker_API. Дополнительные сведения об общих принципах использования рабочих ролей службы см. в [великолепной статье](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle), посвященной описанию их жизненного цикла.

Шаблон прогрессивного веб-приложения Blazor создает два файла рабочей роли службы:

* *wwwroot/service-worker.js* — используется во время разработки.
* *wwwroot/service-worker.published.js* — используется после публикации приложения.

Если вы хотите использовать общую логику для этих двух файлов, рекомендуется добавить содержащий ее третий файл JavaScript и использовать [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) для загрузки такой логики в оба файла.

#### <a name="cache-first-fetch-strategy"></a>Стратегия первичного обращения к кэшу

Встроенная рабочая роль службы *service-worker.published.js* выполняет разрешение запросов с применением стратегии *первичного обращения к кэшу*. В соответствии с этой стратегией даже при наличии доступа к сети или нового содержимого на сервере во всех возможных случаях отдается предпочтение возвращаемому из кэша содержимому.

Это полезно по двум причинам.

* **Во-первых, за счет этого повышается надежность.** Состояние доступа к сети сложно определить однозначно, поскольку пользователь не всегда просто находится в подключенном или автономном режиме. В реальности, даже при наличии подключения его скорость может быть настолько мала, что ожидание загрузки содержимого может быть нецелесообразно. Кроме того, для некоторых URL-адресов из сети могут возвращаться недопустимые результаты, как например в случае с порталом перехвата Wi-Fi, который блокирует или перенаправляет определенные запросы. Именно поэтому API `navigator.onLine` браузера не может считаться надежным источником, на который следует полагаться в приложении.
* **Во-вторых, это позволяет гарантировать корректность.** При создании кэша автономных ресурсов рабочая роль службы хэширует содержимое, чтобы гарантировать получение полного и согласованного моментального снимка ресурсов по состоянию на один конкретный момент времени. В дальнейшем этот кэш используется в качестве атомарной единицы. Таким образом, запрашивать более новые версии ресурсы из сети нецелесообразно, поскольку все данные, которые вам нужны, уже хранятся в кэше. Любые другие данные могут стать причиной несогласованности и несовместимости, например при попытке использовать версии сборок .NET, которые не компилировались вместе.

#### <a name="background-updates"></a>Обновления в фоновом режиме

Для наглядности прогрессивное веб-приложение с предпочтительным автономным режимом работы можно рассматривать как устанавливаемое мобильное приложение. Оно всегда запускается немедленно независимо от наличия сетевого подключения, однако при этом логика установленного приложения извлекается из моментального снимка на определенный момент времени, который может содержать устаревшие данные.

На основе шаблона прогрессивного веб-приложения Blazor создаются приложения, которые пытаются автоматически выполнить обновление в фоновом режиме при наличии работающего сетевого подключения каждый раз, когда приложение посещает пользователь. Этот процесс реализуется следующим образом:

* Во время компиляции проект создает *манифест ресурсов рабочей роли службы*. По умолчанию этому файлу присваивается имя *service-worker-assets.js*. В нем перечислены все статические ресурсы, которые необходимы для работы приложения в автономном режиме, например сборки .NET, файлы JavaScript, каскадные таблицы стилей и прочие элементы, в том числе хэши содержимого. Рабочая роль службы загружает этот список и использует его для определения ресурсов, которые требуется кэшировать.
* Каждый раз, когда пользователь посещает приложение, браузер в фоновом режиме повторно запрашивает файлы *service-worker.js* и *service-worker-assets.js*. Если сервер возвращает любой из этих файлов с измененным содержимым (определяется по результатам побайтового сравнения с существующей установленной рабочей ролью службы), рабочая роль службы пытается установить собственную новую версию.
* При установке собственной новой версии рабочая роль службы создает новый отдельный кэш для автономных ресурсов и начинает заполнять его ресурсами, перечисленными в файле *service-worker-assets.js*. Эта логика реализуется в функции `onInstall` в файле *service-worker.published.js*.
* Если процесс завершается успешно (т. е. все ресурсы загружены без ошибок и все хэши содержимого совпадают), новая рабочая роль службы переходит в состояние "Ожидание активации". После того как пользователь закроет приложение (т. е. все вкладки или окна, в которых оно отображается) новая рабочая роль службы получает статус активной и будет использоваться при последующем посещении приложения. Старая рабочая роль службы и ее кэш при этом удаляются.
* Если процесс завершается неудачно, новый экземпляр рабочей роли службы отклоняется. При следующем посещении пользователя будет предпринята попытка выполнить процесс обновления еще раз в расчете на более высокое качество сетевого подключения и возможность выполнения необходимых запросов.

Все аспекты этого процесса можно настроить, используя логику рабочей роли службы. Все перечисленные выше варианты описывают возможные способы использовать шаблон прогрессивного веб-приложения и не являются специфичными для Blazor. Дополнительные сведения см. в [документации по рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.).

#### <a name="how-requests-are-resolved"></a>Принципы разрешения запросов

Как описывается выше, по умолчанию рабочая роль службы применяет стратегию *первичного обращения к кэшу*, то есть пытается по возможности всегда использовать кэшированное содержимое. Если для отдельного URL-адреса кэшированное содержимое отсутствует (например, в случае запроса данных из серверного API), рабочая роль службы использует обычные сетевые запросы, которые выполняются успешно только при наличии доступа к серверу. Эта логика реализуется в функции `onFetch` в файле *service-worker.published.js*.

Если ваши компоненты Blazor запрашивают данные из серверных API и вам требуется удобный пользовательский интерфейс для обработки сбоев, связанных с отсутствием доступа к сети, соответствующую логику необходимо реализовать в самих компонентах. Например, используйте `try/catch` для запросов `HttpClient`.

#### <a name="support-server-rendered-pages"></a>Поддержка страниц, подготавливаемых к просмотру на сервере

Рассмотрим, что происходит при первом переходе пользователя к URL-адресу, например к `/counter` или по любой другой прямой ссылке в приложении. В таких случаях вам не требуется возвращать кэшированное содержимое как `/counter`, а вместо этого нужно загрузить в браузер содержимое, кэшированное как `/index.html`, для запуска приложения Blazor WebAssembly. Такие начальные запросы называются *запросами навигации* (в отличие от *запросов подресурсов* для получения изображений, каскадных таблиц стилей и т. д. или *запросов на получение или XHR* для получения данных API).

По умолчанию рабочая роль службы использует для обработки запросов навигации специальную логику. При их разрешении для `/index.html` возвращается кэшированное содержимое независимо от того, какой URL-адрес запрашивается. Эта логика реализуется в функции `onFetch` в файле *service-worker.published.js*.

Если для некоторых URL-адресов в вашем приложении должен возвращаться подготавливаемый к просмотру на сервере код HTML (то есть для обслуживания `/index.html` не должен использоваться кэш), вам потребуется изменить логику рабочей роли службы. Например, если все URL-адреса, содержащие `/Identity/`, требуется обрабатывать как обычные сетевые запросы к серверу, следует изменить логику функции `onFetch`в файле *service-worker.published.js*. Найдите следующий код.

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

Измените код следующим образом:

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

Если этого не сделать, то независимо от наличия сетевого подключения рабочая роль службы будет перехватывать запросы к таким URL-адресам и разрешать их с помощью `/index.html`.

#### <a name="control-asset-caching"></a>Управление кэшированием ресурсов

Если в вашем проекте определено свойство MSBuild под названием `ServiceWorkerAssetsManifest`, средства сборки Blazor создадут манифест ресурса рабочей роли службы с указанным именем. По умолчанию шаблон прогрессивного веб-приложения создает файл проекта со следующим содержимым:

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

Этот файл помещается в выходной каталог *wwwroot*, откуда браузер может извлекать его посредством запроса `/service-worker-assets.js`. Чтобы просмотреть содержимое файла *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js*, откройте его в текстовом редакторе. Не вносите изменения в этот файл, поскольку он создается заново для каждой сборки.

По умолчанию этот манифест содержит следующие данные:

* Все управляемые Blazor ресурсы, в том числе сборки .NET и файлы среды выполнения .NET WebAssembly, необходимые для работы в автономном режиме.
* Все ресурсы, которые будут опубликованы в каталоге *wwwroot*, например изображения, каскадные таблицы стилей и файлы JavaScript. К ним также относятся статические веб-ресурсы, предоставляемые в составе внешних проектов и пакетов NuGet.

Чтобы управлять получением и кэшированием этих ресурсов в рабочей роли службы, измените логику функции `onInstall` в файле *service-worker.published.js*. По умолчанию получаются и кэшируются файлы с типичными для веб-файлов расширениями, такими как *.html*, *.css*, *.js*, *.wasm* и другие, а также специфичные для Blazor WebAssembly файлы ( *.dll*, *.pdb*).

Чтобы включить другие ресурсы, отсутствующие в каталоге *wwwroot*, вы можете определить дополнительные записи ItemGroup в MSBuild. Например, добавьте следующее в файл проекта:

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

В метаданных `AssetUrl` указывается относительный URL-адрес, который браузер должен использовать при получении ресурса в кэш. При этом имя оригинального исходного файла на диске может не учитываться.

> [!IMPORTANT]
> Если добавить `ServiceWorkerAssetsManifestItem`, публикация файла в каталог *wwwroot* не произойдет автоматически. Таким образом, вы самостоятельно управляете публикацией выходных данных. В результате добавления `ServiceWorkerAssetsManifestItem` в манифесте ресурса рабочей роли службы лишь появляется дополнительная запись.

## <a name="push-notifications"></a>Push-уведомления

Как и любые аналоги, прогрессивные веб-приложения Blazor WebAssembly поддерживают получение push-уведомлений от внутреннего сервера. Сервер может отправлять такие уведомления в любое время, даже если приложение не используется (например, если другой пользователь выполняет действие, о котором требуется оповестить).

Механизм отправки push-уведомлений не зависит от Blazor WebAssembly, поскольку он реализуется на внутреннем сервере, который может использовать любую технологию. Для отправки push-уведомлений с сервера ASP.NET Core рекомендуется [использовать методику, аналогичную описываемой в рамках семинара по проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).

Механизм приема и отображения push-уведомлений на стороне клиента также реализуется независимо от Blazor WebAssembly в рабочей роли службы, которая представляет собой файл JavaScript. Хороший пример также можно найти в [семинаре, посвященном проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).

## <a name="caveats-for-offline-pwas"></a>Предупреждения относительно прогрессивных веб-приложений с поддержкой автономной работы

Поддержка работы в автономном режиме требуется не для всех приложений. С ее реализацией сопряжены определенные сложности, решение которых не всегда целесообразно.

Поддержка автономной работы как правило требуется лишь в следующих случаях:

* Браузер использует преимущественно локальное основное хранилище данных. В качестве примера можно привести разработку пользовательского интерфейса для устройства [Интернета вещей](https://en.wikipedia.org/wiki/Internet_of_things), которое хранит данные в `localStorage` или [индексированной базе данных](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).

* Вы тратите много усилий на получение и кэширование данных серверного API для каждого пользователя, что позволяет им работать с такими данными в автономном режиме. Для поддержки редактирования вам также потребуется создать систему, которая будет отслеживать изменения и синхронизировать их с серверной частью.

* Вам необходимо гарантировать мгновенную загрузку приложения независимо от состояния сетевого подключения. Вам требуется реализовать соответствующий пользовательский интерфейс для работы с запросами к серверному API и корректного разрешения ситуаций, когда они завершаются сбоем из-за отсутствия доступа к сети.

Кроме того, поддержка работы в автономном режиме для прогрессивных веб-приложений сопряжена с рядом дополнительных сложностей. Разработчикам необходимо внимательно изучить приведенные ниже предостережения.

### <a name="offline-support-only-when-published"></a>Работа в автономном режиме поддерживается только для опубликованных приложений

Шаблон прогрессивного веб-приложения Blazor обеспечивает поддержку автономной работы только после публикации приложения. Это связано с тем, что в процессе разработки каждое изменение как правило должно сразу отражаться в браузере, не дожидаясь обновления в фоновом режиме.

Поэтому при создании приложения, поддерживающего автономную работу, не достаточно протестировать его в режиме разработки. Вам придется проверить приложение в опубликованном состоянии, чтобы понять, как оно будет вести себя при различных состояниях сети.

### <a name="update-completion-after-user-navigation-away-from-app"></a>Обновление выполняется только после выхода пользователя из приложения

Обновления будут выполняться только после того, как пользователь выйдет из приложения на всех вкладках. Как поясняется в разделе [Обновления в фоновом режиме](#background-updates), после развертывания и обновления приложения браузер получит обновленные файлы рабочей роли службы и запустит процесс обновления.

Однако далеко не все разработчики знают, что даже после завершения процесса обновления оно вступит в силу **только после того**, как пользователь выйдет из приложения на всех вкладках. Даже если ваше приложение отображается только в одной вкладке, простого ее обновления будет **не достаточно**. Пока пользователь не закроет приложение полностью, новая рабочая роль службы будет оставаться в состоянии "Ожидание активации". **Такое поведение присуще всем веб-платформам и не является специфичным для Blazor.**

Соответственно, многие разработчики сталкиваются с проблемами при попытке протестировать обновления рабочей роли службы или кэшированных автономно ресурсов. Открыв средства разработчика в браузере, вы можете увидеть нечто подобное:

![изображение](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

Рабочая роль будет находиться в состоянии ожидания до тех пор, пока список "клиентов" (то есть вкладок или окон, в которых отображается приложение) не опустеет. Такое поведение позволяет гарантировать согласованность, то есть получение всех ресурсов из одного атомарного кэша.

При тестировании изменений может быть удобно воспользоваться ссылкой "skipWaiting", которая позволяет пропустить этап ожидания (см. снимок экрана ниже), и затем перезагрузить страницу. При желании вы можете автоматизировать этот процесс для всех пользователей, реализовав в коде рабочей роли службы [пропуск этапа "ожидания" с немедленной активацией обновления](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase). Тем не менее, в этом случае согласованное получение ресурсов из одного и того же экземпляра кэша не гарантируется.

### <a name="users-may-run-any-historical-version-of-the-app"></a>Пользователи могут запускать любую ранее существовавшую версию приложения

Как правило, разработчики веб-приложения ожидают, что пользователи будут работать только с его последней развернутой версией, поскольку это характерно для традиционной модели распространения. Тем не менее, прогрессивное веб-приложение с предпочтительным автономным режимом работы в этом отношении больше похоже на собственное мобильное приложение, пользователи которого далеко не всегда работают с последней версией.

Как описывается в разделе [Обновления в фоновом режиме](#background-updates), после развертывания обновления для приложения **все его текущие пользователи будут работать с предыдущей версией как минимум во время ближайшего посещения** (это связано с тем, что обновление происходит в фоновом режиме только после того, как пользователь выйдет из приложения). Кроме того, в этом случае предыдущей используемой версией не обязательно будет та, которую вы развернули в прошлый раз. В зависимости от того, когда пользователь последний раз выполнял обновление, это может быть *любая* ранее существовавшая версия.

Таким образом, если внешние и внутренние компоненты приложения должны использовать согласованную схему для работы с запросами к API, это может привести к возникновению проблем. Соответственно, развертывать изменения схемы API, не предусматривающие обратную совместимость, можно только после того, как вы убедитесь, что все пользователи выполнили обновление. Также в таких случаях можно явно запретить использование несовместимых старых версий приложения. Такое поведение характерно для собственных мобильных приложений. При развертывании существенных изменений в серверных API пользователи, не выполнившие обновление, столкнутся со сбоями в работе приложения.

Соответственно, по возможности не следует развертывать существенные изменения в серверных API. Если это все же необходимо, рекомендуется использовать [стандартные API рабочей роли службы, такие как `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration), для определения актуальности версии приложения и блокировки его старых версий.

### <a name="interference-with-server-rendered-pages"></a>Возникают помехи в работе подготавливаемых к просмотру на сервере страниц

[Как описывается выше](#support-server-rendered-pages), чтобы обойти поведение рабочей роли службы и предотвратить возврат содержимого `/index.html` для всех запросов навигации, необходимо изменить логику рабочей роли службы.

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a>По умолчанию кэшируется все содержимое манифеста ресурса рабочей роли службы

[Как описывается выше](#control-asset-caching), файл *service-worker-assets.js* создается в процессе сборки и содержит список всех ресурсов, которые должна получать и кэшировать рабочая роль службы.

Поскольку в этот список по умолчанию включается все содержимое, размещаемое в каталоге *wwwroot* (в том числе и поступающее из внешних пакетов и проектов), необходимо тщательно следить за тем, что именно будет находиться в этом каталоге. Например, если каталог *wwwroot* содержит несколько миллионов изображений, рабочая роль службы попытается получить и кэшировать их все, что приведет к перегрузке сети и, скорее всего, закончится сбоем.

Вы можете реализовать произвольную логику, ограничивающую получение и кэширование содержимого манифеста, внеся соответствующие изменения в функцию `onInstall` в файле *service-worker.published.js*.

### <a name="interaction-with-authentication"></a>Взаимодействие с технологиями проверки подлинности

Шаблоны прогрессивного веб-приложения можно использовать совместно с технологиями проверки подлинности. Прогрессивные веб-приложения с поддержкой автономной работы также могут обеспечивать проверку подлинности при наличии у пользователя подключения к сети.

Тем не менее, в случае отсутствия сетевого подключения пользователь не сможет пройти проверку подлинности или получить маркеры доступа. Соответственно, при попытке перейти на страницу входа по умолчанию будет отображаться сообщение об ошибке сети.

Это значит, что вам необходимо организовать работу пользователя в автономном режиме таким образом, чтобы при отсутствии сетевого подключения не требовались маркеры доступа или проверка подлинности, либо были предусмотрены способы минимизировать последствия сбоев в таких случаях. Если реализовать это в приложении невозможно, следует задуматься, действительно ли в нем необходима поддержка работы в автономном режиме.
