---
title: Управление версиями gRPC Services
author: jamesnk
description: Узнайте, как выполнять версию gRPC Services.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 01/09/2020
uid: grpc/versioning
ms.openlocfilehash: 9bd76009ba28a1abef25a98686afea6753d4a8f4
ms.sourcegitcommit: 7dfe6cc8408ac6a4549c29ca57b0c67ec4baa8de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/09/2020
ms.locfileid: "75828520"
---
# <a name="versioning-grpc-services"></a>Управление версиями gRPC Services

[Джеймс Ньютона-короля](https://twitter.com/jamesnk)

Новые функции, добавленные в приложение, могут требовать изменения gRPC служб, предоставляемых клиентами, иногда с непредвиденными и критическими путями. При изменении gRPC Services:

* Следует учитывать, как изменения влияют на клиентов.
* Должна быть реализована стратегия управления версиями для поддержки изменений.

## <a name="backwards-compatibility"></a>Обратная совместимость

Протокол gRPC предназначен для поддержки служб, которые изменяются со временем. Как правило, дополнения к службам и методам gRPC не являются критическими. Некритические изменения позволяют существующим клиентам продолжать работу без изменений. Изменение или удаление служб gRPC является критическими изменениями. Когда gRPC Services применяет критические изменения, клиенты, использующие эту службу, необходимо обновить и повторно развернуть.

Внесение некритических изменений в службу имеет ряд преимуществ.

* Существующие клиенты продолжают работать.
* Устраняется работа с уведомлением критических изменений клиентов и их обновлением.
* Только одна версия службы должна быть документирована и поддерживаться.

### <a name="non-breaking-changes"></a>Некритические изменения

Эти изменения не нарушают уровень протокола gRPC и двоичный уровень .NET.

* **Добавление новой службы**
* **Добавление нового метода в службу**
* **Добавление поля в сообщение запроса** — поля, добавленные в сообщение запроса, десериализуется со [значением по умолчанию](https://developers.google.com/protocol-buffers/docs/proto3#default) на сервере, если оно не задано. Чтобы не добиваться критического изменения, служба должна быть выполнена, если новое поле не задается старыми клиентами.
* **Добавление поля к ответному** сообщению — поля, добавленные в ответное сообщение, десериализуется в коллекцию [неизвестных полей](https://developers.google.com/protocol-buffers/docs/proto3#unknowns) сообщения на стороне клиента.
* **Добавление значения в enum** -enum сериализуется как числовое значение. Новые значения перечисления десериализованы на клиенте в значение enum без имени перечисления. Чтобы не добиваться критического изменения, более старые клиенты должны правильно работать при получении нового значения перечисления.

### <a name="binary-breaking-changes"></a>Двоичные критические изменения

Следующие изменения не нарушаются на уровне протокола gRPC, но клиент должен быть обновлен, если он обновляется до последней версии контракта *.* -типа или клиентской сборки .NET. Двоичная совместимость важна, если вы планируете публиковать библиотеку gRPC в NuGet.

* **Удаление значений полей** из удаленного поля десериализуется в [неизвестные поля](https://developers.google.com/protocol-buffers/docs/proto3#unknowns)сообщения. Это не является критическим изменением протокола gRPC, но клиент должен быть обновлен, если он обновляется до последней версии контракта. Важно, чтобы номер удаленного поля случайно не использовался в будущем. Чтобы убедиться, что это не происходит, укажите удаленные номера полей и имена в сообщении с помощью [зарезервированного](https://developers.google.com/protocol-buffers/docs/proto3#reserved) ключевого слова protobuf.
* **Переименование сообщений сообщений** обычно не отправляется по сети, поэтому это не gRPC изменения протокола. Клиент необходимо будет обновить, если он обновится до последней версии контракта. Одна из **ситуаций, в которой имена сообщений** отправляются в сети, состоит [из полей, в которых имя](https://developers.google.com/protocol-buffers/docs/proto3#any) сообщения используется для распознавания типа сообщений.
* **Изменение csharp_namespace** изменения `csharp_namespace` изменит пространство имен созданных типов .NET. Это не является критическим изменением протокола gRPC, но клиент должен быть обновлен, если он обновляется до последней версии контракта.

### <a name="protocol-breaking-changes"></a>Критические изменения протокола

Ниже перечислены изменения протокола и двоичных критических изменений.

* При **переименовании поля** (с protobuf содержимым) имена полей используются только в созданном коде. Номер поля используется для поиска полей в сети. Переименование поля не является критическим изменением протокола для protobuf. Однако если сервер использует содержимое JSON, то переименование поля является критическим изменением.
* **Изменение типа данных поля** . изменение типа данных поля на [несовместимый тип](https://developers.google.com/protocol-buffers/docs/proto3#updating) приведет к ошибкам при десериализации сообщения. Даже если новый тип данных совместим, скорее всего, клиент должен быть обновлен для поддержки нового типа, если он обновляется до последнего контракта.
* **Изменение номера поля** — с помощью полезных данных protobuf номер поля используется для поиска полей в сети.
* **Переименование пакета, службы или метода** — gRPC использует имя пакета, имя службы и имя метода для создания URL-адреса. Клиент получает *НЕреализованное* состояние с сервера.
* **Удаление службы или метода** — клиент получает *нереализованное* состояние с сервера при вызове удаленного метода.

### <a name="behavior-breaking-changes"></a>Критические изменения в поведении

При внесении некритических изменений необходимо также определить, могут ли старые клиенты продолжать работу с новым поведением службы. Например, Добавление нового поля в сообщение запроса:

* Не является критическим изменением протокола.
* Возврат состояния ошибки на сервере, если новое поле не задано, приводит к критическому изменению старых клиентов.

Совместимость поведения определяется кодом конкретного приложения.

## <a name="version-number-services"></a>Службы номеров версий

Службы должны стремиться обеспечить обратную совместимость со старыми клиентами. В конечном итоге изменения в приложении могут потребовать критических изменений. Критические клиенты и принудительная их обновление вместе со службой не являются хорошим интерфейсом пользователя. Для обеспечения обратной совместимости при внесении критических изменений необходимо опубликовать несколько версий службы.

gRPC поддерживает необязательный описатель [пакета](https://developers.google.com/protocol-buffers/docs/proto3#packages) , который работает во многом подобно пространству имен .NET. На самом деле `package` будет использоваться в качестве пространства имен .NET для создаваемых типов .NET, если `option csharp_namespace` не задан в файле с *расширением* имени. Пакет можно использовать для указания номера версии службы и ее сообщений:

[!code-protobuf[](versioning/sample/greet.v1.proto?highlight=3)]

Имя пакета объединяется с именем службы для поиска адреса службы. Адрес службы позволяет размещать несколько версий службы параллельно:

* `greet.v1.Greeter`
* `greet.v2.Greeter`

Реализации версии службы регистрируются в *Startup.CS*:

```csharp
app.UseEndpoints(endpoints =>
{
    // Implements greet.v1.Greeter
    endpoints.MapGrpcService<GreeterServiceV1>();

    // Implements greet.v2.Greeter
    endpoints.MapGrpcService<GreeterServiceV2>();
});
```

Включение номера версии в имя пакета дает возможность публиковать версию *v2* службы с критическими изменениями, продолжая поддерживать более старые клиенты, которые вызывают версию *v1* . После обновления клиентов для использования службы *v2* можно удалить старую версию. При планировании публикации нескольких версий службы:

* Избегайте критических изменений, если это оправданно.
* Не обновляйте номер версии, если не внесены критические изменения.
* Обновляйте номер версии при внесении критических изменений.

Публикация нескольких версий службы дублирует ее. Чтобы уменьшить дублирование, рассмотрите возможность перемещения бизнес-логики из реализаций службы в централизованное расположение, которое может быть повторно использовано старыми и новыми реализациями:

[!code-csharp[](versioning/sample/GreeterServiceV1.cs?highlight=10,19)]

Службы и сообщения, созданные с разными именами пакетов, являются **разными типами .NET**. Для перемещения бизнес-логики в централизованное расположение требуется сопоставление сообщений общим типам.
