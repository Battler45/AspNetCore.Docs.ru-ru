---
title: Сравнение служб gRPC, с API HTTP
author: jamesnk
description: Узнайте, как gRPC сравнение с API-интерфейсы HTTP и у него есть рекомендуем сценарии.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 03/31/2019
uid: grpc/comparison
ms.openlocfilehash: 655c921788deb30f3c0f3b47f4440dc8701c0f59
ms.sourcegitcommit: ccbb84ae307a5bc527441d3d509c20b5c1edde05
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2019
ms.locfileid: "65874939"
---
# <a name="comparing-grpc-services-with-http-apis"></a>Сравнение служб gRPC, с API HTTP

По [Джеймс метода Ньютона King](https://twitter.com/jamesnk)

В этой статье объясняется, как [служб gRPC](https://grpc.io/docs/guides/) сравнения с API-интерфейсы HTTP (включая ASP.NET Core [веб-API](xref:web-api/index)). Технология, используемая для предоставления API для вашего приложения является важной выбором и gRPC предоставляет уникальные преимущества, по сравнению с API-интерфейсы HTTP. В этой статье обсуждаются сильные и слабые стороны gRPC и рекомендует сценарии использования gRPC по сравнению с другими технологиями.

#### <a name="overview"></a>Обзор

|    Функция             |    gRPC                                                 |    API-интерфейсы HTTP с помощью JSON                       |
|------------------------|---------------------------------------------------------|----------------------------------------------|
|    Контракт            |    Требуется (`*.proto`)                                 |    Необязательно (OpenAPI)                        |
|    Transport           |    HTTP/2                                               |    HTTP                                      |
|    Payload             |    [Protobuf (небольшой, двоичный файл)](#performance)             |    JSON (большой, удобным для чтения)              |
|    Prescriptiveness    |    [Спецификации Strict](#strict-specification)        |    Свободные. Допустим любой HTTP                  |
|    Потоковые операторы           |    [Клиента, сервера, двунаправленным письмом](#streaming)         |    Клиент, сервер                            |
|    Поддержка браузеров     |    [Нет (требуется веб grpc)](#limited-browser-support)   |    Да                                       |
|    Безопасность            |    Транспорта (HTTPS)                                    |    Транспорта (HTTPS)                         |
|    Создание кода клиента     |    [Да](#code-generation)                              |    OpenAPI и сторонние инструменты             |

## <a name="grpc-strengths"></a>сильные стороны gRPC

### <a name="performance"></a>Производительность

gRPC сообщения сериализуются с помощью [Protobuf](https://developers.google.com/protocol-buffers/docs/overview), эффективно двоичном формате. Protobuf очень быстро сериализует на сервере и клиенте. Protobuf сериализации результатов в полезных данных небольших сообщений, важно в сценариях ограниченной пропускной способностью, например мобильных приложений.

gRPC предназначен для HTTP/2, основной редакцией HTTP, который предоставляет значительные преимущества в производительности по протоколу HTTP 1.x:

* Сжатие и двоичный кадрирования. Протокол HTTP/2 — компактную и эффективную, как в отправки и получения.
* Мультиплексирование нескольких вызовов HTTP/2 через одно подключение TCP. Мультиплексирование устраняет [блокировки head строки](https://en.wikipedia.org/wiki/Head-of-line_blocking).

### <a name="code-generation"></a>Создание кода

Все платформы gRPC предоставлять первоклассную поддержку для создания кода. Файл core для разработки gRPC [ `*.proto` файл](https://developers.google.com/protocol-buffers/docs/proto3), который определяет контракт gRPC служб и сообщений. Из этой платформы gRPC файл кода создает базовый класс службы, сообщения и полный клиент.

Отправляя `*.proto` файл между сервером и клиентом, сообщения и клиентский код может быть создан из конечных до конца. Создание кода клиента устраняет дублирование сообщений на стороне клиента и сервера и создает для вас клиент со строгой типизацией. Не нужно писать клиент экономит время разработки значительные в приложениях со многими службами.

### <a name="strict-specification"></a>Спецификации Strict

Формальная спецификация для API HTTP с помощью JSON не существует. Разработчики споры по поводу лучший формат URL-адресов, HTTP-команды и коды ответов.

[GRPC спецификации](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) собой четкие указания о формате служба gRPC должна соответствовать. gRPC устраняет спор и экономит время разработчика, поскольку gPRC остается согласованным на всех платформах и реализации.

### <a name="streaming"></a>Потоковые операторы

HTTP/2 обеспечивает основу для потоки продолжительного, в режиме реального времени передачи данных. gRPC обеспечивает первоклассную поддержку для потоковой передачи через HTTP/2.

GRPC служб, поддерживающих все сочетания потоковой передачи:

* Унарный (без потоковой передачи)
* Сервер-клиент потоковой передачи
* Клиент сервера потоковой передачи
* Двунаправленный потоковой передачи

### <a name="deadlinetimeouts-and-cancellation"></a>Крайний срок или время ожидания и отмену

gRPC позволяет клиентам определить, как долго они могут ожидает завершения удаленного вызова Процедуры. [Крайний срок](https://grpc.io/blog/deadlines) отправляется на сервер и сервер можно решить, какое действие следует предпринять, если оно превышает крайнего срока. Например сервер может привести к отмене незавершенных запросов gRPC/HTTP/база данных по истечении времени ожидания.

Распространение, крайнего срока и отмену с помощью дочерних gRPC вызовы помогает обеспечивать пределы использования ресурсов.

## <a name="grpc-recommended-scenarios"></a>gRPC, рекомендуемые сценарии

gRPC идеально подходит для следующих сценариев:

* **Микрослужбы** &ndash; gRPC предназначен для низкой задержкой и высокой пропускной способности связи. gRPC отлично подходит для микрослужбы упрощенных где важна эффективность.
* **Передача данных в режиме реального времени** &ndash; gRPC имеет отличную поддержку для потоковой передачи двунаправленным письмом. gRPC службы можно отправляют сообщения режиме реального времени без опроса.
* **Полиглот сред** &ndash; gRPC инструментарий поддерживает все языки популярных разработки, делая gRPC хорошо подходит для сред нескольких языков.
* **Сетевых сред ограниченного** &ndash; gRPC сообщения сериализуются с Protobuf, облегченная формате. GRPC сообщения всегда меньше, чем эквивалентное сообщение JSON.

## <a name="grpc-weaknesses"></a>слабые стороны gRPC

### <a name="limited-browser-support"></a>Поддержка ограниченного браузера

Вы не сможете напрямую вызвать службу gRPC из браузера уже сегодня. gRPC интенсивно использует возможности HTTP/2, и браузер не обеспечивает уровень контроля, необходимые на веб-запросов для поддержки клиента gRPC. Например браузеры не допускают вызывающего объекта, чтобы потребовать использования HTTP/2, либо предоставляют доступ к базовой кадров HTTP/2.

[Веб gRPC](https://grpc.io/docs/tutorials/basic/web.html) — это дополнительные технология от группы gRPC, обеспечивает поддержку только gRPC в браузере. Веб gRPC состоит из двух частей: клиент JavaScript, который поддерживает всех современных браузерах и gRPC-веб-прокси на сервере. GRPC веб-клиент вызывает прокси-сервера и прокси-сервер будет пересылать на gRPC запросы к серверу gRPC.

Не все функции gRPC поддерживаемых веб gRPC. Клиент и потоковой передачи двустороннего не поддерживается, и имеется ограниченная поддержка потоковой передачи на сервер.

### <a name="not-human-readable"></a>Не удобным для чтения

HTTP API-запросы отправляются в виде текста и могут читать и создан пользователю.

gRPC сообщения должны кодироваться с Protobuf, по умолчанию. Хотя Protobuf эффективен для отправки и получения, двоичный формат не человека для чтения. Protobuf требуется описание интерфейса сообщения, указанный в `*.proto` файл для правильной десериализации. Дополнительные средства работы является обязательным для анализа полезных данных Protobuf по сети и для составления запросов вручную.

Такие функции, как [отражения server](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md) и [средство командной строки gRPC](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md) существует для помощи с двоичные сообщения Protobuf. Кроме того, Protobuf сообщения поддержки [преобразования в JSON и обратно](https://developers.google.com/protocol-buffers/docs/proto3#json). Встроенное преобразование JSON предоставляет эффективный способ преобразования Protobuf сообщений и обратно удобочитаемой форме, при отладке.

## <a name="alternative-framework-scenarios"></a>Сценарии альтернативные framework

Другие платформы предпочтительнее gRPC в следующих сценариях:

* **Браузер API-интерфейсы доступны** &ndash; gRPC не полностью поддерживается в браузере. Веб gRPC может предложить поддержки обозревателя, но имеет ограничения и вводит прокси-сервера.
* **Рассылка взаимодействий в реальном времени** &ndash; gRPC поддерживает взаимодействий в реальном времени с помощью потоковой передачи, но не существует понятие широковещательная передача сообщения о зарегистрированных подключениях. Например в сценарии комнаты чата, где новые сообщения должны отправляться всем клиентам в комнаты для разговоров, каждый вызов gRPC является обязательным по отдельности потоковой передачи нового сообщения клиенту. [SignalR](xref:signalr/introduction) — это платформа, полезные для этого сценария. SignalR использует концепцию постоянные подключения, а также встроенную поддержку для широковещательной рассылки сообщений.
* **Межпроцессному взаимодействию** &ndash; процесса должна быть размещена серверу HTTP/2 для приема входящих вызовов gRPC. Для Windows, межпроцессному взаимодействию [каналы](/dotnet/standard/io/pipe-operations) является динамичные и простые средства связи.

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:tutorials/grpc/grpc-start>
* <xref:grpc/index>
* <xref:grpc/basics>
* <xref:grpc/migration>
