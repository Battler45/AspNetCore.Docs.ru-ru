---
title: Сравнение служб gRPC с API-интерфейсами HTTP
author: jamesnk
description: Узнайте, как gRPC сравнивается с API-интерфейсами HTTP и их рекомендуемыми сценариями.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 09/25/2019
uid: grpc/comparison
ms.openlocfilehash: 935078d890998fe6af366e3f6a7bf21f53c20cf7
ms.sourcegitcommit: a7813a776809a5029c94aa503ee71994f156231f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/25/2019
ms.locfileid: "71267717"
---
# <a name="compare-grpc-services-with-http-apis"></a>Сравнение служб gRPC с API-интерфейсами HTTP

[Джеймс Ньютона-короля](https://twitter.com/jamesnk)

В этой статье объясняется, как [службы gRPC Services](https://grpc.io/docs/guides/) сравниваются с API HTTP (включая ASP.NET Core [веб-API](xref:web-api/index)). Технология, используемая для предоставления API для вашего приложения, является важным выбором, и gRPC предлагает уникальные преимущества по сравнению с API-интерфейсами HTTP. В этой статье обсуждаются сильные и слабые стороны gRPC и приводятся рекомендации по использованию gRPC по сравнению с другими технологиями.

## <a name="high-level-comparison"></a>Высокоуровневое сравнение

В следующей таблице представлено высокоуровневое сравнение функций API gRPC и HTTP с помощью JSON.

| Функция          | gRPC                                               | API HTTP с JSON           |
| ---------------- | -------------------------------------------------- | ----------------------------- |
| Контракт         | Обязательный ( *.* \)                                | Необязательно (OpenAPI)            |
| Transport        | HTTP/2                                             | HTTP                          |
| Payload          | [Protobuf (малый, двоичный)](#performance)           | JSON (большой, удобочитаемый)  |
| прескриптивенесс | [Спецификация с максимальным уровнем](#strict-specification)      | Закреплен. Допустимы все HTTP-протоколы.      |
| Потоковые операторы        | [Клиент, сервер, двунаправленное](#streaming)       | Клиент, сервер                |
| Поддержка браузера  | [Нет (требуется GRPC-Web)](#limited-browser-support) | Да                           |
| Безопасность         | Транспорт (HTTPS)                                  | Транспорт (HTTPS)             |
| Создание кода клиента | [Да](#code-generation)                      | OpenAPI + сторонние средства |

## <a name="grpc-strengths"></a>сильные стороны gRPC

### <a name="performance"></a>Производительность

сообщения gRPC сериализуются с помощью [protobuf](https://developers.google.com/protocol-buffers/docs/overview), эффективный двоичный формат сообщения. Protobuf очень быстро сериализует сервер и клиент. Protobufная сериализация приводит к небольшому объему полезных данных сообщения, важному в сценариях с ограниченной пропускной способностью, например

gRPC предназначен для протокола HTTP/2, основной редакцией HTTP, которая обеспечивает значительное повышение производительности по сравнению с HTTP 1. x:

* Двоичная кадрирование и сжатие. Протокол HTTP/2 является компактным и эффективным при отправке и получении.
* Мультиплексирование нескольких вызовов HTTP/2 через одно TCP-соединение. Мультиплексирование устраняет [блокировку строк](https://en.wikipedia.org/wiki/Head-of-line_blocking).

### <a name="code-generation"></a>Создание кода

Все платформы gRPC предоставляют поддержку первого класса для создания кода. Основной файл для разработки gRPC — это файл с [ *расширением.* ](https://developers.google.com/protocol-buffers/docs/proto3), который определяет контракт служб gRPC и сообщений. Из этого файла gRPC Frameworks будут создавать базовый класс службы, сообщения и полный клиент.

Совместное использование файла с *расширением.* \ "сервер и клиент" позволяет создавать сообщения и клиентский код от начала до конца. Создание кода клиента устраняет дублирование сообщений на клиенте и сервере, а также создает клиент со строгой типизацией. Отсутствие необходимости писать клиент экономит значительное время разработки в приложениях со многими службами.

### <a name="strict-specification"></a>Спецификация с максимальным уровнем

Формальное описание API HTTP с JSON не существует. Разработчики спорируют наилучший формат URL-адресов, глаголов HTTP и кодов ответов.

[Спецификация gRPC](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) — это описательные сведения о формате, который должна выполнять служба gRPC. gRPC исключает споры и экономит время разработчика, поскольку Гпрк согласованы между платформами и реализациями.

### <a name="streaming"></a>Потоковые операторы

HTTP/2 предоставляет основу для долгосрочных потоков связи в режиме реального времени. gRPC предоставляет поддержку в первую очередь для потоковой передачи через HTTP/2.

Служба gRPC поддерживает все сочетания потоков:

* Унарный (без потоковой передачи)
* Потоковая передача от сервера к клиенту
* Потоковая передача от клиента к серверу
* Двунаправленная потоковая передача

### <a name="deadlinetimeouts-and-cancellation"></a>Крайний срок, время ожидания и Отмена

gRPC позволяет клиентам указать, как долго они хотят ожидать завершения RPC. [Крайний срок](https://grpc.io/blog/deadlines) отправляется на сервер, и сервер может решить, какое действие следует предпринять, если оно превышает крайний срок. Например, сервер может отменять выполняющиеся запросы gRPC/HTTP/Database по истечении времени ожидания.

Распространение крайнего срока и отмены через дочерние вызовы gRPC помогает применять ограничения использования ресурсов.

## <a name="grpc-recommended-scenarios"></a>Рекомендуемые сценарии gRPC

gRPC хорошо подходит для следующих сценариев:

* **Микрослужбы** &ndash; gRPC предназначен для низкой задержки и передачи данных с высокой пропускной способностью. gRPC отлично подходит для облегченных микрослужб, в которых важна эффективность.
* **Обмен данными между точками в режиме реального времени** &ndash; gRPC обладает отличной поддержкой двунаправленной потоковой передачи. службы gRPC Services могут отправлять сообщения в режиме реального времени без опроса.
* **Polyglot среды** &ndash; средства gRPC поддерживают все популярные языки разработки, делая gRPC хорошим выбором для многоязыковых сред.
* **Среды с ограниченным** доступом к сети &ndash; сообщения gRPC сериализуются с помощью protobuf, облегченного формата сообщений. Сообщение gRPC всегда меньше, чем эквивалентное сообщение JSON.

## <a name="grpc-weaknesses"></a>слабые стороны gRPC

### <a name="limited-browser-support"></a>Ограниченная поддержка браузеров

Сейчас невозможно напрямую вызвать службу gRPC из браузера. gRPC сильно использует функции HTTP/2, и ни один браузер не предоставляет необходимый уровень контроля над веб-запросами для поддержки клиента gRPC. Например, браузеры не позволяют вызывающему объекту требовать использования HTTP/2 или предоставить доступ к базовым кадрам HTTP/2.

[gRPC-Web](https://grpc.io/docs/tutorials/basic/web.html) — это дополнительная технология от команды gRPC, которая предоставляет ограниченную поддержку gRPC в браузере. gRPC-Web состоит из двух частей: клиента JavaScript, поддерживающего все современные браузеры, и gRPC-Web proxy на сервере. GRPC-Client вызывает прокси-сервер, и прокси-сервер пересылает запросы gRPC на сервер gRPC.

GRPC-Web поддерживает не все возможности gRPC. Клиентская и двунаправленная потоковая передача не поддерживается, и существует ограниченная поддержка потоковой передачи сервера.

### <a name="not-human-readable"></a>Не читается человеком

Запросы API HTTP отправляются в виде текста и могут быть прочитаны и созданы людьми.

по умолчанию сообщения gRPC кодируются с помощью protobuf. Хотя protobuf является эффективным для отправки и получения, его двоичный формат не читается человеком. Protobuf требует, чтобы описание интерфейса сообщения, указанное в файле *.* , было правильно десериализовано. Дополнительные средства необходимы для анализа полезных данных protobuf на канале передачи и создания запросов вручную.

Существуют такие функции, как [отражение сервера](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md) и [средство командной строки gRPC](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md) , которые помогают с двоичными сообщениями protobuf. Кроме того, сообщения protobuf поддерживают [Преобразование в JSON и обратно](https://developers.google.com/protocol-buffers/docs/proto3#json). Встроенное преобразование JSON обеспечивает эффективный способ преобразования protobuf сообщений в удобочитаемую форму и из нее при отладке.

## <a name="alternative-framework-scenarios"></a>Альтернативные сценарии платформы

Другие платформы рекомендуется использовать вместо gRPC в следующих сценариях:

* **API, доступные в браузере** &ndash; gRPC не полностью поддерживается в браузере. gRPC — Web может предлагать поддержку браузеров, но он имеет ограничения и вводит серверный прокси.
* **Трансляция обмена данными в режиме реального времени** &ndash; gRPC поддерживает обмен данными в режиме реального времени через потоковую передачу, но концепция широковещательной рассылки сообщения в зарегистрированные подключения не существует. Например, в сценарии комнаты чатов, где новые сообщения разговора должны отправляться всем клиентам в комнате разговора, каждый вызов gRPC требуется для индивидуального потоковой передачи новых сообщений разговора клиенту. [SignalR](xref:signalr/introduction) является полезной платформой для этого сценария. SignalR имеет концепцию постоянных подключений и встроенную поддержку широковещательных сообщений.
* **Взаимодействие между процессами** &ndash; Для приема входящих вызовов gRPC процесс должен содержать сервер HTTP/2. Многопроцессные [каналы](/dotnet/standard/io/pipe-operations) связи для Windows — это быстрый, упрощенный способ связи.

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:tutorials/grpc/grpc-start>
* <xref:grpc/index>
* <xref:grpc/basics>
* <xref:grpc/migration>
