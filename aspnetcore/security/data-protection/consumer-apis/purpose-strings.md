---
title: Строки назначения в ASP.NET Core
author: rick-anderson
description: Узнайте, как строки назначения используются в ASP.NET Core интерфейсах API защиты данных.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 4c85423f8de7e4b784ae1bb304a884541df251b6
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78654004"
---
# <a name="purpose-strings-in-aspnet-core"></a>Строки назначения в ASP.NET Core

<a name="data-protection-consumer-apis-purposes"></a>

Компоненты, использующие `IDataProtectionProvider`, должны передавать в метод `CreateProtector` параметр с уникальными *целями* . *Параметр* цели является неотъемлемой частью безопасности системы защиты данных, так как он обеспечивает изоляцию между криптографическими клиентами, даже если корневые криптографические ключи одинаковы.

Когда потребитель указывает назначение, строка назначения используется вместе с корневыми криптографическими ключами для получения криптографических подразделов, уникальных для этого потребителя. Это изолирует потребителя от всех других криптографических потребителей в приложении: никакие другие компоненты не могут считывать свои полезные данные и не могут считывать полезные данные какого-либо другого компонента. Эта изоляция также позволяет визуализировать все категории атак на компонент.

![Пример схемы назначения](purpose-strings/_static/purposes.png)

На приведенной выше схеме `IDataProtector` экземпляры A и B **не могут** считывать полезные данные друг друга, только их собственные.

Строка назначения не обязательно должна быть секретной. Он должен быть уникальным в том смысле, что ни один из других некорректно настроенных компонентов никогда не предоставит ту же строку назначения.

>[!TIP]
> Использование пространства имен и имени типа компонента, использующего API-интерфейсы защиты данных, является хорошим правилом для Thumb, так как на практике эти сведения никогда не будут конфликтовать.
>
>Компонент, разработанный Contoso, который отвечает за токены носителя минтинг, может использовать contoso. Security. Беарертокен в качестве строки назначения. Или еще лучше — в качестве строки назначения может использоваться contoso. Security. Беарертокен. v1. Добавление номера версии позволяет будущей версии использовать contoso. Security. Беарертокен. v2 в качестве цели, и разные версии будут полностью изолированы друг от друга, как только найдутся полезные данные.

Поскольку параметр целей для `CreateProtector` является массивом строк, приведенный выше способ был бы указан как `[ "Contoso.Security.BearerToken", "v1" ]`. Это позволяет устанавливать иерархию целей и откроет возможность использования многоядерных сценариев с системой защиты данных.

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> Компоненты не должны разрешать ввод ненадежных пользователей в качестве единственного источника входных данных для цепочки целей.
>
>Например, рассмотрим компонент contoso. Messaging. Секуремессаже, который отвечает за хранение безопасных сообщений. Если компоненту безопасного обмена сообщениям необходимо вызвать `CreateProtector([ username ])`, злоумышленник может создать учетную запись с именем пользователя Contoso. Security. Беарертокен, чтобы получить компонент для вызова `CreateProtector([ "Contoso.Security.BearerToken" ])`, что непреднамеренно приводит к тому, что защищенная система обмена сообщениями Mint полезные данные, которые могут восприниматься как маркеры проверки подлинности.
>
>Более лучшей цепочкой для компонента обмена сообщениями будет `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, что обеспечивает надлежащую изоляцию.

Изоляция, предоставляемая и поведением `IDataProtectionProvider`, `IDataProtector`и целей, выглядит следующим образом.

* Для данного объекта `IDataProtectionProvider` метод `CreateProtector` создаст объект `IDataProtector`, который однозначно привязан к объекту `IDataProtectionProvider`, создавшему этот объект, и параметру, который был передан в метод.

* Параметр цели не может иметь значение null. (Если в качестве массива указано значение, это означает, что массив не должен иметь нулевую длину, а все элементы массива должны иметь значение, отличное от NULL.) Назначение пустой строки технически разрешено, но не рекомендуется.

* Аргументы двух целей эквивалентны, только если они содержат одни и те же строки (с использованием сравнения порядков) в том же порядке. Аргумент с одним целям эквивалентен одному одноэлементному массиву целей.

* Два `IDataProtector`ных объекта эквивалентны только в том случае, если они создаются из эквивалентных `IDataProtectionProvider` объектов с параметрами эквивалентных целей.

* Для данного объекта `IDataProtector` вызов `Unprotect(protectedData)` вернет исходный `unprotectedData` только в том случае, если `protectedData := Protect(unprotectedData)` для эквивалентного `IDataProtector` объекта.

> [!NOTE]
> Мы не будем учитывать случай, когда некоторый компонент намеренно выбрал строку назначения, которая может конфликтовать с другим компонентом. Такой компонент, по сути, считается вредоносным, и эта система не предназначена для предоставления гарантий безопасности в случае, если вредоносный код уже выполняется в рабочем процессе.
