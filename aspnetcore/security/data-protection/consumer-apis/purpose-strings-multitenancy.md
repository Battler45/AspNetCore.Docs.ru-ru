---
title: Иерархия целей и мультитенантность в ASP.NET Core
author: rick-anderson
description: Сведения об иерархии строк назначения и использовании многофакторной связи, так как она относится к ASP.NET Core интерфейсам API защиты данных.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 1133d40e7b325d58b3f70e7387494dae36ff8ac9
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78654022"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a>Иерархия целей и мультитенантность в ASP.NET Core

Поскольку `IDataProtector` также неявно является `IDataProtectionProvider`, цели могут быть объединены в цепочку. В этом смысле `provider.CreateProtector([ "purpose1", "purpose2" ])` эквивалентен `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.

Это позволяет некоторым интересным иерархическим связям через систему защиты данных. В предыдущем примере для [contoso. Messaging. секуремессаже](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)компонент секуремессаже может вызвать `provider.CreateProtector("Contoso.Messaging.SecureMessage")` раз перед передним планом и кэшировать результат в закрытое поле `_myProvider`. Последующие предохранители можно создать с помощью вызовов `_myProvider.CreateProtector("User: username")`, и эти предохранители будут использоваться для защиты отдельных сообщений.

Это также можно сделать зеркально. Рассмотрим единое логическое приложение, в котором размещается несколько клиентов (это кажется разумным), и каждый клиент может быть настроен с помощью собственной системы проверки подлинности и управления состоянием. У приложения-шаблона есть один главный поставщик, который вызывает `provider.CreateProtector("Tenant 1")` и `provider.CreateProtector("Tenant 2")`, чтобы предоставить каждому клиенту собственный изолированный сегмент системы защиты данных. Клиенты могут получить собственные индивидуальные предохранители, основываясь на их собственных нуждах, но независимо от того, насколько сложно они попытаются, не могут создавать предохранители, которые конфликтуют с любым другим клиентом в системе. Графическое представление представлено ниже.

![Многопользовательские цели](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> Предполагается, что приложение-клиент управляет тем, какие интерфейсы API доступны отдельным клиентам, и что клиенты не могут выполнять произвольный код на сервере. Если клиент может выполнять произвольный код, он может выполнить закрытое отражение, чтобы разбить гарантии изоляции, или просто прочитать материал главного ключа напрямую и получить все необходимые им подразделы.

Система защиты данных в действительности использует сортировку по умолчанию в стандартной конфигурации. По умолчанию материал основного ключа хранится в папке профиля пользователя учетной записи рабочего процесса (или в реестре для удостоверений пула приложений IIS). Но на самом деле довольно часто используется одна учетная запись для запуска нескольких приложений, и поэтому все эти приложения будут совместно использовать главный материал для ключа. Для решения этой проблемы система защиты данных автоматически вставляет уникальный идентификатор приложения в качестве первого элемента в цепочке общего назначения. Это неявное назначение позволяет [изолировать отдельные приложения](xref:security/data-protection/configuration/overview#per-application-isolation) друг от друга, эффективно рассматривая каждое приложение как уникальный клиент в системе, и процесс создания предохранителя будет аналогичен приведенному выше изображению.
