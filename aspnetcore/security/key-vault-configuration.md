---
title: Поставщик конфигурации Azure Key Vault в ASP.NET Core
author: guardrex
description: Узнайте, как использовать поставщик конфигурации Azure Key Vault для настройки приложения с помощью пар "имя-значение", загружаемых во время выполнения.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.custom: mvc
ms.date: 08/01/2019
uid: security/key-vault-configuration
ms.openlocfilehash: 0d0b6e20a1901d4a2630ce263b5fd0cd7bcca8fe
ms.sourcegitcommit: 4fe3ae892f54dc540859bff78741a28c2daa9a38
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2019
ms.locfileid: "68776654"
---
# <a name="azure-key-vault-configuration-provider-in-aspnet-core"></a>Поставщик конфигурации Azure Key Vault в ASP.NET Core

[Люк ЛаСаМ](https://github.com/guardrex) и [Эндрю Стантон-медперсонала](https://github.com/anurse)

В этом документе объясняется, как использовать поставщик конфигурации [Microsoft Azure Key Vault](https://azure.microsoft.com/services/key-vault/) для загрузки значений конфигурации приложения из Azure Key Vault секреты. Azure Key Vault — это облачная служба, которая помогает защитить криптографические ключи и секреты, используемые приложениями и службами. Распространенные сценарии использования Azure Key Vault с приложениями ASP.NET Core:

* Управление доступом к конфиденциальным данным конфигурации.
* Соблюдайте требования для FIPS 140-2 уровня 2 проверенных аппаратных модулей безопасности (HSM) при хранении данных конфигурации.

Этот сценарий доступен для приложений, предназначенных для ASP.NET Core 2,1 или более поздней версии.

[Просмотреть или скачать образец кода](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/security/key-vault-configuration/sample) ([как скачивать](xref:index#how-to-download-a-sample))

## <a name="packages"></a>Пакеты

Чтобы использовать поставщик конфигурации Azure Key Vault, добавьте ссылку на пакет в пакет [Microsoft. Extensions. Configuration. AzureKeyVault](https://www.nuget.org/packages/Microsoft.Extensions.Configuration.AzureKeyVault/) .

Чтобы использовать [управляемые удостоверения для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview) , добавьте ссылку на пакет [Microsoft. Azure. Services. AppAuthentication](https://www.nuget.org/packages/Microsoft.Azure.Services.AppAuthentication/) .

> [!NOTE]
> На момент написания статьи последний стабильный выпуск `Microsoft.Azure.Services.AppAuthentication`, версия `1.0.3`, обеспечивает поддержку [управляемых системой удостоверений](/azure/active-directory/managed-identities-azure-resources/overview#how-does-the-managed-identities-for-azure-resources-work). Поддержка *управляемых удостоверений, назначаемых пользователем* , доступна в `1.2.0-preview2` пакете. В этом разделе демонстрируется использование управляемых системой удостоверений, а в предоставленном примере приложения используется `1.0.3` версия `Microsoft.Azure.Services.AppAuthentication` пакета.

## <a name="sample-app"></a>Пример приложения

Пример приложения выполняется в одном из двух режимов, определяемых `#define` инструкцией в верхней части файла *Program.CS* :

* `Certificate`&ndash; Демонстрирует использование идентификатора клиента Azure Key Vault и сертификата X. 509 для доступа к секретам, хранящимся в Azure Key Vault. Эту версию примера можно запустить из любого расположения, развернуть в службе приложений Azure или на любом узле, способном обслуживать ASP.NET Coreное приложение.
* `Managed`Демонстрируется использование [управляемых удостоверений для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview) для проверки подлинности приложения в Azure Key Vault с проверкой подлинности Azure AD без учетных данных, хранящихся в коде или конфигурации приложения. &ndash; При использовании управляемых удостоверений для проверки подлинности не требуется идентификатор и пароль приложения Azure AD (секрет клиента). `Managed` Версия примера должна быть развернута в Azure. Следуйте указаниям в разделе [Использование управляемых удостоверений для ресурсов Azure](#use-managed-identities-for-azure-resources) .

Дополнительные сведения о настройке примера приложения с помощью директив препроцессора (`#define`) см. в разделе. <xref:index#preprocessor-directives-in-sample-code>

## <a name="secret-storage-in-the-development-environment"></a>Секретное хранилище в среде разработки

Локальное задание секретов с помощью [средства диспетчера секретов](xref:security/app-secrets). Когда пример приложения выполняется на локальном компьютере в среде разработки, секреты загружаются из локального хранилища диспетчера секретов.

Для средства диспетчера секретов требуется `<UserSecretsId>` свойство в файле проекта приложения. Задайте для свойства значение (`{GUID}`) любой уникальный GUID:

```xml
<PropertyGroup>
  <UserSecretsId>{GUID}</UserSecretsId>
</PropertyGroup>
```

Секреты создаются как пары "имя-значение". Иерархические значения (разделы конфигурации) используют `:` (двоеточие) в качестве разделителя в ASP.NET Core именах ключей [конфигурации](xref:fundamentals/configuration/index) .

Диспетчер секретов используется из командной оболочки, открытой в корне содержимого проекта, где `{SECRET NAME}` — это имя, а `{SECRET VALUE}` — значение.

```console
dotnet user-secrets set "{SECRET NAME}" "{SECRET VALUE}"
```

Выполните следующие команды в командной оболочке из корневого каталога содержимого проекта, чтобы задать секреты для примера приложения:

```console
dotnet user-secrets set "SecretName" "secret_value_1_dev"
dotnet user-secrets set "Section:SecretName" "secret_value_2_dev"
```

Если эти секреты хранятся в Azure Key Vault в [хранилище секретов в рабочей среде с Azure Key Vaultным](#secret-storage-in-the-production-environment-with-azure-key-vault) разделом, `_dev` суффикс изменяется на. `_prod` Суффикс предоставляет визуальную подсказку в выходных данных приложения, указывающую источник значений конфигурации.

## <a name="secret-storage-in-the-production-environment-with-azure-key-vault"></a>Секретное хранилище в рабочей среде с Azure Key Vault

Инструкции, предоставленные в [кратком руководстве: Чтобы создать Azure Key Vault и сохранить секреты, используемые в](/azure/key-vault/quick-create-cli) примере приложения, укажите и получите секрет из Azure Key Vault с помощью Azure CLI раздела. Дополнительные сведения см. в разделе.

1. Откройте Azure Cloud Shell одним из следующих способов в [портал Azure](https://portal.azure.com/):

   * Выберите **проверить** в правом верхнем углу блока кода. Используйте строку поиска "Azure CLI" в текстовом поле.
   * Откройте Cloud Shell в браузере с помощью кнопки **запустить Cloud Shell** .
   * Нажмите кнопку **Cloud Shell** в меню в правом верхнем углу портал Azure.

   Дополнительные сведения см. в статьях [интерфейс командной строки Azure (CLI)](/cli/azure/) и [общие сведения о Azure Cloud Shell](/azure/cloud-shell/overview).

1. Если вы еще не прошли проверку подлинности, выполните `az login` вход с помощью команды.

1. Создайте группу ресурсов с помощью следующей команды, где `{RESOURCE GROUP NAME}` — это имя группы ресурсов для новой группы ресурсов, а `{LOCATION}` — регион Azure (центр обработки данных):

   ```console
   az group create --name "{RESOURCE GROUP NAME}" --location {LOCATION}
   ```

1. Создайте хранилище ключей в группе ресурсов с помощью следующей команды, где `{KEY VAULT NAME}` — это имя нового хранилища ключей, а `{LOCATION}` — регион Azure (центр обработки данных):

   ```console
   az keyvault create --name "{KEY VAULT NAME}" --resource-group "{RESOURCE GROUP NAME}" --location {LOCATION}
   ```

1. Создайте секреты в хранилище ключей в виде пар "имя-значение".

   Azure Key Vault имена секретов ограничены буквенно-цифровыми символами и тире. Иерархические значения (разделы конфигурации) `--` используют (два тире) в качестве разделителя. Двоеточия, которые обычно используются для разделения раздела из подраздела в [ASP.NET Core конфигурации](xref:fundamentals/configuration/index), не допускаются в именах секретов хранилища ключей. Поэтому при загрузке секретов в конфигурацию приложения используются два дефиса и они переключаются на двоеточие.

   Следующие секреты предназначены для использования с примером приложения. Эти значения включают `_prod` суффикс, чтобы отличить `_dev` значения суффиксов, загруженных в среде разработки, от секретов пользователя. Замените `{KEY VAULT NAME}` на имя хранилища ключей, созданного на предыдущем шаге:

   ```console
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "SecretName" --value "secret_value_1_prod"
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "Section--SecretName" --value "secret_value_2_prod"
   ```

## <a name="use-application-id-and-x509-certificate-for-non-azure-hosted-apps"></a>Использование идентификатора приложения и сертификата X. 509 для приложений, не размещенных в Azure

Настройте Azure AD, Azure Key Vault и приложение для использования идентификатора Azure Active Directory приложения и сертификата X. 509 для проверки подлинности в хранилище ключей, **Если приложение размещено за пределами Azure**. Дополнительные сведения см. в статье [о ключах, секретах и сертификатах](/azure/key-vault/about-keys-secrets-and-certificates).

> [!NOTE]
> Хотя использование идентификатора приложения и сертификата X. 509 поддерживается для приложений, размещенных в Azure, мы рекомендуем использовать [управляемые удостоверения для ресурсов Azure](#use-managed-identities-for-azure-resources) при размещении приложения в Azure. Для управляемых удостоверений не требуется хранить сертификат в приложении или в среде разработки.

В примере приложения используется идентификатор приложения и сертификат X. 509, если `#define` инструкция в верхней части `Certificate`файла *Program.CS* имеет значение.

1. Создайте архивный сертификат PKCS # 12 (*PFX*-файл). Для создания сертификатов можно использовать [MakeCert в Windows](/windows/desktop/seccrypto/makecert) и [OpenSSL](https://www.openssl.org/).
1. Установите сертификат в личное хранилище сертификатов текущего пользователя. Пометка ключа как экспортируемого необязательна. Запишите отпечаток сертификата, который будет использоваться далее в этом процессе.
1. Экспортируйте архивный сертификат PKCS # 12 (*PFX*) как сертификат в формате DER (*CER*).
1. Зарегистрируйте приложение в Azure AD (**Регистрация приложений**).
1. Отправьте сертификат в кодировке DER (*CER*) в Azure AD:
   1. Выберите приложение в Azure AD.
   1. Перейдите к разделу **сертификаты & секреты**.
   1. Выберите **отправить сертификат** , чтобы отправить сертификат, который содержит открытый ключ. Сертификат *. cer*, *. pem*или *. CRT* является приемлемым.
1. Сохраните имя хранилища ключей, идентификатор приложения и отпечаток сертификата в файле *appSettings. JSON* приложения.
1. Перейдите к **разделу хранилища ключей** в портал Azure.
1. Выберите хранилище ключей, созданное в [хранилище секретов в рабочей среде с помощью Azure Key Vault](#secret-storage-in-the-production-environment-with-azure-key-vault) разделе.
1. Выберите **политики доступа**.
1. Выберите **Добавить новый**.
1. Щелкните **выбрать субъект** и выберите зарегистрированное приложение по имени. Нажмите кнопку **выбрать** .
1. Откройте **разрешения** для секрета и предоставьте приложению разрешения **Get** и **List** .
1. Нажмите кнопку **ОК**.
1. Нажмите кнопку **Сохранить**.
1. Разверните приложение.

Пример приложения получает значения конфигурации из `IConfigurationRoot` с тем же именем, что и имя секрета: `Certificate`

* Значения, отличные от иерархических: Значение для `SecretName` получено с помощью `config["SecretName"]`.
* Иерархические значения (разделы): Используйте `:` нотацию (двоеточие) `GetSection` или метод расширения. Используйте любой из этих подходов для получения значения конфигурации:
  * `config["Section:SecretName"]`
  * `config.GetSection("Section")["SecretName"]`

Сертификат X. 509 управляется ОС. Приложение вызывает `AddAzureKeyVault` со значениями, предоставленными файлом *appSettings. JSON* :

[!code-csharp[](key-vault-configuration/sample/Program.cs?name=snippet1&highlight=20-23)]

Примеры значений:

* Имя хранилища ключей:`contosovault`
* Идентификатор приложения:`627e911e-43cc-61d4-992e-12db9c81b413`
* Отпечаток сертификата:`fe14593dd66b2406c5269d742d04b6e1ab03adb1`

*appsettings.json*:

[!code-json[](key-vault-configuration/sample/appsettings.json)]

При запуске приложения на веб-странице отображаются загруженные значения секрета. В среде разработки значения секрета загружаются с `_dev` суффиксом. В рабочей среде значения загружаются с `_prod` суффиксом.

## <a name="use-managed-identities-for-azure-resources"></a>Использование управляемых удостоверений для ресурсов Azure

**Приложение, развернутое в Azure** , может использовать преимущества [управляемых удостоверений для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview), что позволяет приложению проходить проверку подлинности в Azure Key Vault с помощью проверки подлинности Azure AD без учетных данных (идентификатор приложения и пароль/секрет клиента). хранится в приложении.

Пример приложения использует управляемые удостоверения для ресурсов Azure, `#define` когда инструкция в верхней части `Managed`файла *Program.CS* имеет значение.

Введите имя хранилища в файл *appSettings. JSON* приложения. В примере приложения не требуется идентификатор приложения и пароль (секрет клиента), если задана `Managed` версия, поэтому эти записи конфигурации можно игнорировать. Приложение развертывается в Azure, а Azure выполняет проверку подлинности приложения для доступа к Azure Key Vault только с использованием имени хранилища, хранящегося в файле *appSettings. JSON* .

Разверните пример приложения в службе приложений Azure.

Приложение, развернутое в службе приложений Azure, автоматически регистрируется в Azure AD при создании службы. Получите идентификатор объекта из развертывания для использования в следующей команде. Идентификатор объекта отображается в портал Azure на панели удостоверений службы приложений.

Используя Azure CLI и идентификатор объекта приложения, укажите приложение с `list` разрешениями и `get` для доступа к хранилищу ключей:

```console
az keyvault set-policy --name '{KEY VAULT NAME}' --object-id {OBJECT ID} --secret-permissions get list
```

**Перезапустите приложение** с помощью Azure CLI, PowerShell или портал Azure.

Пример приложения:

* Создает экземпляр `AzureServiceTokenProvider` класса без строки подключения. Если строка подключения не указана, поставщик пытается получить маркер доступа из управляемых удостоверений для ресурсов Azure.
* Новый `KeyVaultClient` объект создается `AzureServiceTokenProvider` с помощью обратного вызова токена экземпляра.
* Экземпляр используется с `IKeyVaultSecretManager` реализацией по умолчанию, которая загружает все секретные значения и заменяет двойные`--`тире () на двоеточие (`:`) в именах ключей. `KeyVaultClient`

[!code-csharp[](key-vault-configuration/sample/Program.cs?name=snippet2&highlight=13-21)]

При запуске приложения на веб-странице отображаются загруженные значения секрета. В среде разработки значения секрета имеют `_dev` суффикс, так как они предоставляются секретами пользователя. В рабочей среде значения загружаются с `_prod` суффиксом, так как они предоставляются Azure Key Vault.

Если появится `Access denied` сообщение об ошибке, убедитесь, что приложение зарегистрировано в Azure AD и предоставил доступ к хранилищу ключей. Убедитесь, что вы перезапустите службу в Azure.

## <a name="use-a-key-name-prefix"></a>Использование префикса имени ключа

`AddAzureKeyVault`предоставляет перегрузку, которая принимает реализацию `IKeyVaultSecretManager`, которая позволяет управлять преобразованием секретов хранилища ключей в конфигурационные ключи. Например, можно реализовать интерфейс для загрузки секретных значений на основе значения префикса, которое вы задают при запуске приложения. Это позволяет, например, загружать секреты на основе версии приложения.

> [!WARNING]
> Не используйте префиксы в секретах хранилища ключей, чтобы размещать секреты для нескольких приложений в одном хранилище ключей или для размещения секретов среды (например, для *разработки* и *рабочих* секретов) в одном хранилище. Мы рекомендуем использовать отдельные хранилища ключей для различных приложений и сред разработки и рабочей среды, чтобы изолировать среды приложений для обеспечения наивысшего уровня безопасности.

В следующем примере в хранилище ключей устанавливается секрет (и используется средство диспетчера секретов для среды разработки) `5000-AppSecret` (точки не допускаются в именах секретов хранилища ключей). Этот секрет представляет секрет приложения для версии 5.0.0.0 приложения. Для другой версии приложения 5.1.0.0 секрет добавляется в хранилище ключей (и с помощью средства диспетчера секретов) для `5100-AppSecret`. Каждая версия приложения загружает значение секрета в своей конфигурации в виде `AppSecret`, отключая версию при загрузке секрета.

`AddAzureKeyVault`вызывается с настраиваемым `IKeyVaultSecretManager`:

[!code-csharp[](key-vault-configuration/sample_snapshot/Program.cs?highlight=30-34)]

`IKeyVaultSecretManager` Реализация реагирует на префиксы версий секретов, чтобы загрузить правильный секрет в конфигурацию:

[!code-csharp[](key-vault-configuration/sample_snapshot/Startup.cs?name=snippet1)]

`Load` Метод вызывается алгоритмом поставщика, который выполняет перебор секретов хранилища для поиска тех, у которых есть префикс версии. При обнаружении префикса версии с `Load`алгоритм `GetKey` использует метод, чтобы вернуть имя конфигурации для имени секрета. Он отделяет префикс версии от имени секрета и возвращает оставшуюся часть имени секрета для загрузки в пары "имя-значение" конфигурации приложения.

При реализации этого подхода:

1. Версия приложения, указанная в файле проекта приложения. В следующем примере для `5.0.0.0`версии приложения задано значение:

   ```xml
   <PropertyGroup>
     <Version>5.0.0.0</Version>
   </PropertyGroup>
   ```

1. Убедитесь, что `<UserSecretsId>` свойство имеется в файле проекта приложения, где `{GUID}` является идентификатором GUID, предоставляемым пользователем:

   ```xml
   <PropertyGroup>
     <UserSecretsId>{GUID}</UserSecretsId>
   </PropertyGroup>
   ```

   Сохраните следующие секреты локально с помощью [средства диспетчера секретов](xref:security/app-secrets):

   ```console
   dotnet user-secrets set "5000-AppSecret" "5.0.0.0_secret_value_dev"
   dotnet user-secrets set "5100-AppSecret" "5.1.0.0_secret_value_dev"
   ```

1. Секреты сохраняются в Azure Key Vault с помощью следующих Azure CLI команд:

   ```console
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "5000-AppSecret" --value "5.0.0.0_secret_value_prod"
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "5100-AppSecret" --value "5.1.0.0_secret_value_prod"
   ```

1. При запуске приложения загружаются секреты хранилища ключей. Строковый секрет для `5000-AppSecret` совпадает с версией приложения, указанной в файле проекта приложения (`5.0.0.0`).

1. Версия `5000` (с тире) удаляется из имени ключа. Во всем приложении при чтении конфигурации с ключом `AppSecret` загружается секретное значение.

1. Если версия приложения изменена в файле проекта на `5.1.0.0` , а приложение запускается снова, `5.1.0.0_secret_value_dev` возвращается значение секрета в среде разработки и `5.1.0.0_secret_value_prod` в рабочем окружении.

> [!NOTE]
> Можно также предоставить собственную `KeyVaultClient` реализацию для. `AddAzureKeyVault` Настраиваемый клиент позволяет совместно использовать один экземпляр клиента в приложении.

## <a name="bind-an-array-to-a-class"></a>Привязка массива к классу

Поставщик может считывать значения конфигурации в массив для привязки к массиву POCO.

При чтении из источника конфигурации, позволяющего ключам содержать разделители в виде двоеточия (`:`), используется числовой сегмент ключа для различения ключей, составляющих массив ( `:1:``:0:`,,. `:{n}:`). Дополнительные сведения см. в [разделе Конфигурация. Привязка массива к классу](xref:fundamentals/configuration/index#bind-an-array-to-a-class).

Ключи Azure Key Vault не могут использовать двоеточие в качестве разделителя. Подход, описанный в этом разделе, использует двойные тире (`--`) в качестве разделителя для иерархических значений (разделов). Ключи массивов хранятся в Azure Key Vault с двойными тире и числовыми сегментами ключей &hellip; (`--0--`, `--1--`, `--{n}--`).

Изучите следующую конфигурацию поставщика ведения журнала [Serilog](https://serilog.net/) , предоставляемую файлом JSON. В `WriteTo` массиве определены два объектных литерала, отражающих два *приемника*Serilog, которые описывают назначения для вывода журнала:

```json
"Serilog": {
  "WriteTo": [
    {
      "Name": "AzureTableStorage",
      "Args": {
        "storageTableName": "logs",
        "connectionString": "DefaultEnd...ountKey=Eby8...GMGw=="
      }
    },
    {
      "Name": "AzureDocumentDB",
      "Args": {
        "endpointUrl": "https://contoso.documents.azure.com:443",
        "authorizationKey": "Eby8...GMGw=="
      }
    }
  ]
}
```

Конфигурация, показанная в предыдущем JSON-файле, хранится в Azure Key Vault с использованием нотации двойного тире (`--`) и числовых сегментов.

| Ключ | Значение |
| --- | ----- |
| `Serilog--WriteTo--0--Name` | `AzureTableStorage` |
| `Serilog--WriteTo--0--Args--storageTableName` | `logs` |
| `Serilog--WriteTo--0--Args--connectionString` | `DefaultEnd...ountKey=Eby8...GMGw==` |
| `Serilog--WriteTo--1--Name` | `AzureDocumentDB` |
| `Serilog--WriteTo--1--Args--endpointUrl` | `https://contoso.documents.azure.com:443` |
| `Serilog--WriteTo--1--Args--authorizationKey` | `Eby8...GMGw==` |

## <a name="reload-secrets"></a>Перезагрузка секретов

Секреты кэшируются до `IConfigurationRoot.Reload()` вызова метода. Срок действия истек, отключен и обновленные секреты в хранилище ключей не учитываются приложением до тех пор, `Reload` пока не будет выполнено.

```csharp
Configuration.Reload();
```

## <a name="disabled-and-expired-secrets"></a>Отключенные секреты и секреты с истекшим сроком действия

`KeyVaultClientException` При отключенных и истекших секретах во время выполнения создается исключение. Чтобы предотвратить создание приложения, укажите конфигурацию с помощью другого поставщика конфигурации или обновите закрытый или истекший секрет.

## <a name="troubleshoot"></a>Устранение неполадок

Если приложению не удается загрузить конфигурацию с помощью поставщика, в [инфраструктуру ведения журнала ASP.NET Core](xref:fundamentals/logging/index)записывается сообщение об ошибке. При следующих условиях загрузка конфигурации будет запрещена:

* Приложение или сертификат неправильно настроены в Azure Active Directory.
* Хранилище ключей не существует в Azure Key Vault.
* Приложение не имеет прав доступа к хранилищу ключей.
* Политика доступа не включает `Get` и `List` не имеет разрешений.
* В хранилище ключей данные конфигурации (пара "имя-значение") неправильно именованы, отсутствуют, отключены или устарели.
* Приложение имеет неправильное имя хранилища ключей (`KeyVaultName`), идентификатор приложения Azure AD (`AzureADApplicationId`) или отпечаток сертификата Azure AD`AzureADCertThumbprint`().
* Неверный ключ конфигурации (имя) в приложении для загружаемого значения.

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:fundamentals/configuration/index>
* [Microsoft Azure: Key Vault](https://azure.microsoft.com/services/key-vault/)
* [Microsoft Azure: Документация по Key Vault](/azure/key-vault/)
* [Создание и перенос ключей, защищенных АППАРАТным модулем безопасности, для Azure Key Vault](/azure/key-vault/key-vault-hsm-protected-keys)
* [Класс KeyVaultClient](/dotnet/api/microsoft.azure.keyvault.keyvaultclient)
* [Краткое руководство. Установка и получение секрета из Azure Key Vault с помощью веб-приложения .NET](/azure/key-vault/quick-create-net)
* [Учебник. Использование Azure Key Vault с виртуальной машиной Azure Windows в .NET](/azure/key-vault/tutorial-net-windows-virtual-machine)
