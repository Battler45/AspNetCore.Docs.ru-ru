---
title: Общие сведения об аутентификации для одностраничных приложений на ASP.NET Core
author: ''
description: Использование удостоверения с одной страницы приложению, размещенному внутри приложения ASP.NET Core.
ms.author: ''
ms.date: 03/05/2018
uid: security/authentication/identity/spa
ms.openlocfilehash: cf04ec1ff0ae9afea066fd1864ab0a7956ace32c
ms.sourcegitcommit: 036d4b03fd86ca5bb378198e29ecf2704257f7b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2019
ms.locfileid: "57346788"
---
# <a name="authentication-and-authorization-for-spas"></a>Проверка подлинности и авторизация для одностраничных приложений

В ASP.NET 3.0 мы представляем поддержка проверки подлинности в одностраничных приложений с помощью нашей новой поддержки для авторизации API. Эта поддержка основана на комбинации удостоверения ASP.NET Core для проверки подлинности и хранения пользователей и сервера удостоверений для реализации Open ID Connect.

Мы добавили новый параметр проверки подлинности в нашем Angular и React шаблонов, аналогично параметру проверки подлинности в наших шаблонов страниц mvc и razor с разрешенными значениями «None» и «Личная».

## <a name="create-an-angular-app-with-api-authorization-support"></a>Создание приложения Angular с поддержки проверки подлинности API

Чтобы создать новое приложение Angular с поддержкой проверки подлинности и авторизация пользователей, откройте командную строку и выполните следующую команду:

```console
dotnet new angular -o <output_directory_name> -au Individual
```

Приведенная выше команда создает приложения ASP.NET Core с помощью *ClientApp* каталог, содержащий приложения Angular.

## <a name="create-a-react-app-with-api-authorization-support"></a>Создание приложения React с поддержки проверки подлинности API

Чтобы создать новое приложение React с поддержкой проверки подлинности и авторизация пользователей, откройте командную строку и выполните следующую команду:

```console
dotnet new react -o <output_directory_name> -au Individual
```

Приведенная выше команда создает приложения ASP.NET Core с помощью *ClientApp* каталога, содержащего приложение React.

## <a name="general-description-of-the-aspnet-core-components-of-the-app"></a>Общее описание компонентов приложения ASP.NET Core

Существует несколько дополнений в проект мы включают поддержку проверки подлинности:

### <a name="startup-class"></a>Класс Startup

Если взглянуть на код в классе Startup ниже Мы ценим следующие включения:
* Внутри `public void ConfigureServices(IServiceCollection services)`:
  * Удостоверение с помощью пользовательского интерфейса по умолчанию.
    ```csharp
    services.AddDbContext<ApplicationDbContext>(options =>
      options.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));

    services.AddDefaultIdentity<ApplicationUser>()
      .AddDefaultUI(UIFramework.Bootstrap4)
      .AddEntityFrameworkStores<ApplicationDbContext>();
    ```
  * Сервер удостоверений с дополнительным методом вспомогательный AddApiAuthorization этой настройки некоторые по умолчанию соглашения об ASP.NET на основе сервера удостоверений.
    ```csharp
    services.AddIdentityServer()
      .AddApiAuthorization<ApplicationUser, ApplicationDbContext>();
    ```
  * Проверка подлинности с помощью AddIdentityServerJwt вспомогательный метод, предназначенный для настройки приложения для проверки токенов Jwt, полученных сервером удостоверений. 
    ```csharp
    services.AddAuthentication()
      .AddIdentityServerJwt();
    ```
* Внутри `public void Configure(IApplicationBuilder app)`:
  * Промежуточного по проверки подлинности, который отвечает за проверку учетных данных во входящем запросе и настройке пользователя на контекст запроса.
    ```csharp
    app.UseAuthentication();
    ```
  * Промежуточный слой сервер удостоверений, который предоставляет конечные точки Openid Connect.
    ```csharp
    app.UseIdentityServer();
    ```

### <a name="addapiauthorization"></a>AddApiAuthorization 
Этот вспомогательный метод настраивает сервер удостоверений для использования наших поддерживаемой конфигурации. Сервер удостоверений — это мощный и расширяемый платформа для обработки приложений проблемы безопасности, но в то же время, которое предоставляет массу сложности, нам не нужно знать о для наиболее распространенных сценариев, поэтому мы выбираем набор соглашений и параметры конфигурации, мы рассмотрим являются хорошей отправной точкой. После проверки подлинности потребностей всю мощь Identity Server все еще доступна вам вы можете настроить его в соответствии с потребностями.

### <a name="addidentityserverjwt"></a>AddIdentityServerJwt
Этот вспомогательный метод настраивает схему политики для приложения в качестве обработчика проверки подлинности по умолчанию. Эта политика настроена для обработки всех запросов, которые отправляются на любой вложенный путь в пространстве URL-адрес удостоверений identity «/ удостоверения» и сообщить JwtBearerHandler обработки всех запросов.
Этот метод регистрирует Addionally `<<ApplicationName>>API` Api ресурса с сервера удостоверений с областью по умолчанию `<<ApplicationName>>API` и настраивает промежуточного слоя маркеров носителей JWT для проверки токенов, выданных сервером удостоверений для приложения.

### <a name="sampledatacontroller"></a>SampleDataController
Если взглянуть на файл Controllers\SampleDataController.cs можно наблюдать `[Authorize]` атрибут, примененный к классу, который указывает, что пользователь должен быть авторизован исходя из политики по умолчанию для доступа к ресурсу. Политика авторизации по умолчанию происходит с настроить для использования схему проверки подлинности по умолчанию, который настраивается с `AddIdentityServerJwt` схему политики, который мы упоминали выше, что делает обработчик JwtBearer задаются такие вспомогательный метод обработчика по умолчанию для запросы к приложению.

### <a name="applicationdbcontext"></a>ApplicationDbContext
Если взглянуть на файл в Data\ApplicationDbContext.cs мы сможем увидеть одинаковым DbContext, мы используем в удостоверении, за исключением расширяет ApiAuthorizationDbContext (более производный класс от IdentityDbContext) для включения схемы для идентификации сервера.
Если требуется полный контроль над схему базы данных можно просто наследовать от одного из доступных классов DbContext удостоверений и настройка контекста для включения схемы удостоверение путем вызова `builder.ConfigurePersistedGrantContext(_operationalStoreOptions.Value)` на `OnModelCreating` метод.

### <a name="oidcconfigurationcontroller"></a>OidcConfigurationController
Если взглянуть на файл Controllers\OidcConfigurationController.cs, мы видим, конечная точка вставать сотрудников для обслуживания OIDC параметры, необходимые клиенту для использования.

### <a name="appsettingsjson"></a>appsettings.json
Если взглянуть на файл appsettings.json в корневой папке проекта, мы видим, новый `IdentityServer` раздел, описывающий список настройки клиентов, и мы видим, что имеется один клиент. Имя клиента соответствует имени приложения и сопоставить по соглашению с параметр ClientId oAuth. Профиль указывает тип создаваемого приложения, мы настраиваем и используется внутренне для обозначения дисков, которые упрощают процесс настройки для сервера. Существует несколько профилей, доступных как описано в разделе ниже.

```json
"IdentityServer": {
  "Clients": {
    "angularindividualpreview3final": {
      "Profile": "IdentityServerSPA"
    }
  }
}
```

### <a name="appsettingsdevelopmentjson"></a>appSettings. Development.JSON
Если взглянуть на appsettings. Development.JSON файл в корневой папке проекта, можно увидеть новый `IdentityServer` раздел, описывающий ключ, мы используем для подписи маркеров. При развертывании в рабочей среде ключа необходимо подготовить и развернуть вместе с приложением, как описано ниже.

```json
  "IdentityServer": {
    "Key": {
      "Type": "Development"
    }
  }
}
```

## <a name="general-description-of-the-angular-application"></a>Общее описание приложения Angular
Поддержка проверки подлинности и авторизации API в шаблоне Angular живет в свой собственный модуль Angular. В разделе ClientApp\src\api авторизации и он состоит из следующих элементов:
* 3 компонента:
  * Компонент имени входа: Обрабатывает поток входа для приложения.
  * Компонент выхода: Обрабатывает поток выхода для приложения.
  * Компонент меню входа: Мини-приложение, отображающая текущего прошедшего проверку подлинности пользователя со ссылками для управления профиль пользователя и выход или ссылки на вход или зарегистрируйтесь, если пользователь не прошел проверку подлинности.
* Условие маршрута `AuthorizeGuard` , можно добавить маршруты и пользователь должен пройти проверку подлинности перед посещением маршрута.
* Перехватчик http `AuthorizeInterceptor` маркер доступа, присоединяет к исходящим запросам HTTP, предназначенных для API, когда пользователь проходит проверку подлинности.
* Услуга `AuthorizeService` , обрабатывает подробности более низкого уровня процесса проверки подлинности и предоставляет информацию об аутентифицированном пользователе к остальной части приложения для использования.
* Angular модуль, который определяет маршруты, связанные с частями приложения проверки подлинности и предоставляет компонент меню для имени входа, перехватчик, условие и службы для потребления от остальной части приложения.

## <a name="general-description-of-the-react-application"></a>Общее описание приложение React
Поддержка проверки подлинности и авторизации API находится шаблон React в ClientApp\src\components\api authorization\ и он состоит из следующих элементов:
* 4 компонентами:
  * Компонент имени входа: Обрабатывает поток входа для приложения.
  * Компонент выхода: Обрабатывает поток выхода для приложения.
  * Компонент меню входа: Мини-приложение, отображающая текущего прошедшего проверку подлинности пользователя со ссылками для управления профиль пользователя и выход или ссылки на вход или зарегистрируйтесь, если пользователь не прошел проверку подлинности.
  * AuthorizeRoute: Компонент маршрутизации, пользователь должен пройти проверку подлинности перед отображением компонента, указанного в параметре компонента.
  * Экспортированное `authService` экземпляр класса `AuthorizeService` , обрабатывает подробности более низкого уровня процесса проверки подлинности и предоставляет информацию об аутентифицированном пользователе к остальной части приложения для использования.

Теперь, когда мы видели основные компоненты решения, мы можем создавать особый вид в отдельных сценариях приложения:

## <a name="requiring-authorization-on-a-new-api"></a>Требуется выполнять авторизацию на новый интерфейс API
Система настроена по умолчанию, чтобы сделать тривиальным, чтобы требовать авторизации для новых интерфейсов API. Чтобы сделать это, просто создайте новый контроллер и добавьте `[Authorize]` атрибут в класс контроллера или к любому действию контроллера.

## <a name="protecting-a-client-side-route-angular"></a>Защита маршрут на стороне клиента (Angular)
Защита маршрут на стороне клиента можно сделать, добавив условие авторизовать в список условий, который будет выполняться при настройке маршрута. В качестве примера можно увидеть настройку выборки данных маршрута в модуле angular основного приложения:

```ts
RouterModule.forRoot([
  // ...
  { path: 'fetch-data', component: FetchDataComponent, canActivate: [AuthorizeGuard] },
])
```

Важно отметить, что защита маршрут не защищает фактической конечной точки (по-прежнему требуется `[Authorize]` атрибут, примененный к нему), но, что он только запрещает пользователю переход к маршрута на стороне клиента, если он не прошел проверку подлинности.

## <a name="authenticate-api-requests-angular"></a>Проверка подлинности запросов API (Angular)

Проверка подлинности запросов к API, размещенных вдоль стороны, что приложение выполняется автоматически при помощи перехватчик клиента HTTP, определяется приложением.

## <a name="protect-a-client-side-route-react"></a>Защитить клиентские маршрут (React)

Защита маршрут на стороне клиента выполняется с помощью компонента AuthorizeRoute вместо обычного маршрута компонента. В качестве примера можно увидеть настройку выборки данных маршрута в компоненте приложения:

```jsx
<AuthorizeRoute path='/fetch-data' component={FetchData} />
```

Важно отметить, что защита маршрут не защищает фактической конечной точки (по-прежнему требуется `[Authorize]` атрибут, примененный к нему), но, что он только запрещает пользователю переход к маршрута на стороне клиента, если он не прошел проверку подлинности.

## <a name="authenticate-api-requests-react"></a>Проверка подлинности запросов API (React)

Проверка подлинности запросов с помощью react выполняется путем импорта `authService` экземпляра из `AuthorizeService` получения маркера доступа из authService и подключив его к запросу, как показано ниже. В компонентах react обычно это делается в метод жизненного цикла componentDidMount либо в виде результата из взаимодействия пользователей.

### <a name="import-the-authservice-into-your-component"></a>Импортировать authService в компоненте

```js
import authService from './api-authorization/AuthorizeService'
```

### <a name="retrieve-and-attach-the-access-token-to-the-response"></a>Получить и присоединить маркер доступа в ответ

```js
async populateWeatherData() {
  const token = await authService.getAccessToken();
  const response = await fetch('api/SampleData/WeatherForecasts', {
    headers: !token ? {} : { 'Authorization': `Bearer ${token}` }
  });
  const data = await response.json();
  this.setState({ forecasts: data, loading: false });
}
```

## <a name="deploy-into-production"></a>Развертывание в рабочей среде

Чтобы развернуть приложение в рабочей среде, нам нужно подготовить несколько ресурсов:
* Предоставляет базу для хранения идентификаторов учетных записей пользователей и сервера удостоверений.
* Рабочий сертификат для подписи маркеров.
  * Требования к этому сертификату; Это может быть, самозаверяющий сертификат или сертификат, предоставленными через Центр сертификации.
  * Его можно формировать с помощью стандартных средств, таких как powershell или openssl.
  * Он может быть установлен в хранилище сертификатов на целевых компьютерах или развернут как PFX-файл с надежным паролем.

### <a name="example-deploy-into-azure-websites"></a>Пример Развертывание в веб-сайты Azure

В этом разделе мы собираемся развернуть приложение на веб-сайты Azure с помощью сертификата, хранящегося в хранилище сертификатов. Нам нужно изменить приложения, чтобы загрузить сертификат из хранилища сертификатов. Чтобы сделать это, наш план службы приложений должен иметь по крайней мере на уровень "стандартный", если мы настроим в более позднем этапе. В этом примере нам просто нужно изменить раздел IdentityServer на файл appsettings.json, включают основные сведения:
```json
  "IdentityServer": {
    "Key": {
      "Type": "Store",
      "StoreName": "My",
      "StoreLocation": "CurrentUser",
      "Name": "CN=MyApplication"
    }
  }
}
```
* Свойство name на сертификат соответствует различающееся субъекта для сертификата.
* Расположение хранилища представляет расположение для загрузки сертификата из (CurrentUrser или LocalMachine).
* Имя хранилища представляет имя хранилища сертификатов, где хранится сертификат, в данном случае, на который указывает хранилище пользователя.

Чтобы развернуть веб-сайтах Azure, развернуть приложение, описанные в [развертывание приложения в Azure](xref:tutorials/publish-to-azure-webapp-using-vs#deploy-the-app-to-azure) создать необходимые ресурсы Azure и развернуть приложение в рабочей среде.

После этого приложение развертывается в Azure, но еще не полностью работает как мы по-прежнему должен быть настроен сертификат, используемый приложением. Чтобы сделать это, необходимо иметь отпечаток для сертификата, мы собираемся использовать и выполните действия, описанные в [загрузка сертификатов](/azure/app-service/app-service-web-ssl-cert-load#load-your-certificates).

Хотя эти шаги упомянуть SSL, имеется раздел «Закрытые сертификаты» на портале, где мы можем передать наших подготовленной сертификат, используемый вместе с приложением.

После выполнения этого шага мы должны получить возможность перезапуска наше приложение и должно быть полностью работоспособным.

## <a name="other-configuration-options"></a>Другие параметры конфигурации
Наши поддержка авторизации API строится поверх Identity Server с набором соглашений, значения по умолчанию и усовершенствования для упрощения работы для одностраничных приложений. Нечего и говорить всю мощь Identity Server доступна в фоновом, если интеграций, которые мы предлагаем не занимают вашего сценария. Получение поддержки сосредоточена на так называемых «основных» приложения, где все приложения создаваемых и развертываемых решением нашей организации. Таким образом, мы не предоставляем поддержку согласия или федерации. Для этих сценариев мы рекомендуем использовать сервер удостоверений и выполните его документации.

### <a name="application-profiles"></a>Профили приложений
Профили приложений являются стандартных конфигураций для приложений, уточнить свои параметры. В настоящее время мы поддерживаем два профиля:
* IdentityServerSPA: Представляет одностраничного приложения, размещенного вместе с Identity Server как единое целое.
  * По умолчанию используется URI перенаправления `/authentication/login-callback`.
  * По умолчанию используется post_logout_redirect_uri `/authentication/logout-callback`.
  * Включает в себя набор областей `openid`, `profile`и всех областях, определенных для интерфейсов API в приложение.
  * Набор разрешенных типов ответов OIDC, `id_token token` или каждого из них по отдельности (`id_token`, `token`).
  * Режим допустимый ответ — `fragment`.
* SPA: Представляет одностраничного приложения, которая не размещена с сервера удостоверений.
  * Включает в себя набор областей `openid`, `profile`и всех областях, определенных для интерфейсов API в приложение.
  * Набор разрешенных типов ответов OIDC, `id_token token` или каждого из них по отдельности (`id_token`, `token`).
  * Режим допустимый ответ — `fragment`.
* IdentityServerJwt: Представляет API, размещенного вместе с с помощью сервера удостоверений.
  * Приложение настроено для одной области, по умолчанию используется имя приложения.
* API: Представляет API, который не будет размещено с сервера удостоверений.
  * Приложение настроено для одной области, по умолчанию используется имя приложения.

### <a name="configuration-through-appsettings"></a>Настройка с помощью AppSettings
Приложения можно настроить через наша система конфигурации, добавив их в список клиентам или ресурсов, соответственно. 

При настройке клиентов можно настроить `redirect_uri` и `post_logout_redirect_uri` как показано ниже:
```json
  "IdentityServer": {
    "Clients": {
      "MySPA": {
        "Profile": "SPA",
        "RedirectUri": "https://www.example.com/authentication/login-callback",
        "LogoutUri": "https://www.example.com/authentication/logout-callback"
      }
    }
  }
```

При настройке ресурсов мы можно настроить области для ресурса, как показано ниже:
```json
"IdentityServer": {
  "Resources": {
    "MyExternalApi": {
      "Profile": "API",
      "Scopes": "a b c",
    }
  }
}
```

### <a name="configuration-through-code"></a>Настройка с помощью кода
Можно также настроить клиентов и ресурсов с помощью кода, с помощью перегрузки AddApiAuthorization, который принимает действие для настройки параметров.
```csharp
AddApiAuthorization<ApplicationUser, ApplicationDbContext>(options =>
{
    options.Clients.AddSPA(
        "My SPA",
        spa => spa.WithRedirectUri("http://www.example.com/authentication/login-callback")
            .WithLogoutRedirectUri("http://www.example.com/authentication/logout-callback"));

    options.ApiResources.AddApiResource("MyExternalApi", resource => resource.WithScopes("a", "b", "c"));
});
```
